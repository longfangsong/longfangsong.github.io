<!DOCTYPE html><html lang="zh-CN"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><meta name="author" content="longfangsong"><title>Domain Driven Design —— Can it work on Infrastructure Software Development? · Blog</title><meta name="description" content="I used to work on some Web products, and leared a lot about domain driven design(DDD), that’s a useful design method, and works well for making concep"><meta name="keywords"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="renderer" content="webkit"><link rel="short icon" href="/images/favicon.png" type="image/x-icon"><link rel="apple-touch-icon-precomposed" sizes="144x144" href="/images/apple-touch-icon-144x144.png"><link rel="apple-touch-icon-precomposed" sizes="120x120" href="/images/apple-touch-icon-120x120.png"><link rel="apple-touch-icon-precomposed" sizes="72x72" href="/images/apple-touch-icon-72x72.png"><link rel="apple-touch-icon-precomposed" sizes="57x57" href="/images/apple-touch-icon-57x57.png"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/blog_basic.css"><link rel="stylesheet" href="/css/font-awesome.min.css"><link rel="stylesheet" href="/css/source-code-pro.css"><link rel="alternate" type="application/atom+xml" title="ATOM 1.0" href="/atom.xml"><meta name="generator" content="Hexo 4.2.1"></head><body><div class="sidebar animated fadeInDown"><div class="logo-title"><div class="title"><img src="/images/logo@2x.png" style="width:127px;"><h3 title=""><a href="/">Blog</a></h3><div class="description"><p>生命是灰色的，而理论之树常青</p></div></div><div id="pirate" data-wordart-src="//cdn.wordart.com/json/685czi4rqil5" style="width: 100%;" data-wordart-show-attribution></div><script src="//cdn.wordart.com/wordart.min.js" async defer></script></div><ul class="social-links"><li><a href="http://github.com/longfangsong" target="_blank" rel="noopener"><i class="fa fa-github"></i></a></li></ul><div class="footer"><a target="_blank" href="/"><span>Theme by </span></a><a href="https://www.caicai.me" target="_blank" rel="noopener"> CaiCai </a><span>&</span><a href="https://github.com/Ben02/hexo-theme-Anatole" target="_blank" rel="noopener"> Ben</a><div class="by_farbox"><a href="https://hexo.io/zh-cn/" target="_blank">Proudly published with Hexo&#65281;</a></div><script src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" async></script><span id="busuanzi_container_site_pv">本站总访问量<span id="busuanzi_value_site_pv"></span>次</span></div></div><div class="main"><div class="page-top animated fadeInDown"><div class="nav"><li><a href="/">首页</a></li><li><a href="/about">关于</a></li><li><a href="/tags">标签</a></li><li><a href="/archives">归档</a></li><li><a href="/links">友链</a></li></div><div class="information"><div class="back_btn"><li><a class="fa fa-chevron-left" onclick="window.history.go(-1)"> </a></li></div><div class="avatar"><img src="/images/logo.png"></div></div></div><div class="autopagerize_page_element"><div class="content"><div class="post-page"><div class="post animated fadeInDown"><div class="post-title"><h1><a>Domain Driven Design —— Can it work on Infrastructure Software Development?</a></h1></div><div class="post-content"><link rel="stylesheet noopener" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css" target="_blank"><p>I used to work on some Web products, and leared a lot about domain driven design(DDD), that’s a useful design method, and works well for making concepts clear during the development process. Many patterns introduced in DDD do helped me a lot.</p>
<p>And now I’m working on some database (TiKV, and its trasaction part for specific) development. Though might be less “infrastructure” than compiler and operating system (but might be harder than these two), database is still a kind of infrastructure software. And I found that <strong>some</strong> of DDD’s practice remain good here.</p>
<p>Recently, with the development process of async-commit and 1pc, I found the complexity of our software is becoming higher and higher, many compatable problems occurred, so I wish we may take some good practice in DDD when designing our software.</p>
<h2 id="What’s-so-special-about-Infrastructure-Software"><a href="#What’s-so-special-about-Infrastructure-Software" class="headerlink" title="What’s so special about Infrastructure Software?"></a>What’s so special about Infrastructure Software?</h2><p>If you read the DDD book, you may find most examples there are not from infrastructure software, it is reasonable because it is easier to show the benefits to integrate domain knowledge into the model and the software with some non-infrastructure cases. Most developers<sup id="fnref:1"><a href="#fn:1" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="Except me, after some work on database and distrubuted system, I think I know nothing about database or distrubuted system 😭……
">[1]</span></a></sup> of infrastructure software are just the expert of the domain, they have already know the domain well.</p>
<p>In the meanwhile, the performance of infrastructure software is always much import than ordinary softwares, and some patterns introduced in DDD do have costs on performance. For example, we do can make many of our functions side-effect-free, but it will lead to more network or disk access, and make the performance regression, for the same reason, sometimes we cannot seperate a function which seems do different things into some small ones. Performance do force us to do some trade off.</p>
<p>In my opinion, there are some patterns we can learn from DDD, while others won’t apply here.</p>
<h2 id="Patterns-can-we-take-from-DDD"><a href="#Patterns-can-we-take-from-DDD" class="headerlink" title="Patterns can we take from DDD"></a>Patterns can we take from DDD</h2><h3 id="Ubiquitous-Language"><a href="#Ubiquitous-Language" class="headerlink" title="Ubiquitous Language"></a>Ubiquitous Language</h3><p>I think this is the most important pattern! And we already have it! Most concept of our domain are just terminology in database domain, and we are familiar with them. There are also some implementation related concepts, which I think the names in the code has become our Ubiquitous Language.</p>
<p>The tricky part is, some of our Ubiquitous Language has ambiguity<sup id="fnref:2"><a href="#fn:2" rel="footnote">&lt;span class=”hint–top hint–error hint–medium hint–rounded hint–bounce” aria-label=”Some database terminologies have ambiguity too, for example, consistency has at least 4 different meanings, see part Ⅱ, chapter 7 in the DDIA book. And in percolator, commit can mean commit of the transaction (prewrite + commit stage) or just the “commit stage”. Naming is really hard!<br>“&gt;[2]</span></a></sup>, I found at least 3 different <code>Mutation</code> types in our code (TiKV and client-rust), and they stand for different things, which is confusing when reading the code. I think always specifying the module name is a good practice in these situations.</p>
<p>I’m tring to collect some “dictionary” to give us a place for searching around our Ubiquitous Language, including monitoring items.</p>
<h3 id="Model-Driven-Design"><a href="#Model-Driven-Design" class="headerlink" title="Model-Driven Design"></a>Model-Driven Design</h3><p>Now I think this one is most important for us: our code is somehow not so tightly related with our model. Most our model is aimed for one feature rather than the whole picture. Some times I think maybe we pay too much attention on “features” (which is reasonable because features do can bring us real benefits and deliverable for costomers) instead of the existing codes and models<sup id="fnref:4"><a href="#fn:4" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="I'm always tring to build a (visible) model which cover all aspects in TiKV, at least the txn system. Which is not only good for understanding the code, but also helpful when diagnosising problems and finding possible optimizing. 
">[4]</span></a></sup> (which I think are also important). So, as a result, we have design doc for Pessimistic Lock, for large transaction, for async commit, for 1pc, and for downstream components like cdc, regardless (while sometimes trying to regard, but not very comprehensive) of the fact that these things work together, with a shared (raft) storage, and some even share the same requests/commands. I think we should have a unified model for all of these, or just implement these in separated structures. Maybe we can ident which kind of transaction each request is in, and use it to dispatch these request to different executing routes.</p>
<p>And, I don’t know, maybe we stick too hard to the model percolator provide us, so adding new feature become hard and make the code ugly, would it be better if we do some large change, eg. many of our tricks are done by doing some magical encode/decode on keys, but what if we add some more column family, eg. <code>gc_fence</code> which temporary lives in the write CF now, into that model?</p>
<h3 id="Hands-on-Modelers"><a href="#Hands-on-Modelers" class="headerlink" title="Hands-on Modelers"></a>Hands-on Modelers</h3><p>It’s lucky we don’t really have something like consultants now, everyone can and design the model and write the code.</p>
<h3 id="Layered-Architecture"><a href="#Layered-Architecture" class="headerlink" title="Layered Architecture"></a>Layered Architecture</h3><p>TiKV and our transaction layer has already layered! We have command &amp; scheduler layer, actions layer and mvcc layer.</p>
<h3 id="Entities"><a href="#Entities" class="headerlink" title="Entities"></a>Entities</h3><p>I think commands are entities. And in fact we have transaction as an entity, distinguished by its <code>start_ts</code>, though we cannot make it a clear object.</p>
<h3 id="Value-Objects"><a href="#Value-Objects" class="headerlink" title="Value Objects"></a>Value Objects</h3><p>Don’t find a clear usage now.</p>
<h3 id="Services"><a href="#Services" class="headerlink" title="Services"></a>Services</h3><p>This is an interesting pattern, I think action module provide a lot of services, some of them are too simple to make into a struct/trait, I think a function is enough. But for huge functions like prewrite, make it a real Service is necessary. I think <code>Prewriter</code> might be an attempt of doing so.</p>
<h3 id="Modules"><a href="#Modules" class="headerlink" title="Modules"></a>Modules</h3><p>Thanks to Rust, we can devide modules in a natural way. Meanwhile Golang suffers problems about circular reference among modules, which requires carefully design.</p>
<h3 id="Aggregates"><a href="#Aggregates" class="headerlink" title="Aggregates"></a>Aggregates</h3><p>Don’t find a clear usage now.</p>
<h3 id="Factories"><a href="#Factories" class="headerlink" title="Factories"></a>Factories</h3><p>I think <code>Builder</code> is similar with this, and it is already a common pattern in TiKV, while not so related to modeling.</p>
<p>Maybe we can add some more factories, eg. factories to construct commands from requests.</p>
<h3 id="Repositories"><a href="#Repositories" class="headerlink" title="Repositories"></a>Repositories</h3><p>I used to thinking whether it would be better if we have a repository for transactions, and finally found out this approach will result in a centralized transaction coordinator, which is definitely not we want.</p>
<h3 id="Specification"><a href="#Specification" class="headerlink" title="Specification"></a>Specification</h3><p>This one is interesting! I think we can apply this in a lot of places. Currently our code is full of code to check for rules during the trasaction handling stage, and a cohesive specification struct instead of a bunch of condition judges everywhere might result in better design.</p>
<h3 id="Intention-Revealing-Interfaces"><a href="#Intention-Revealing-Interfaces" class="headerlink" title="Intention-Revealing Interfaces"></a>Intention-Revealing Interfaces</h3><p>I think there’re some not so intention-revealing parts in our code, take the <code>Request</code>s as an example, we always use the word “version” or “start version”, but in fact, sometimes these value represents the transaction id in these requests, and other times they reprents the start time of the transaction, all these usages are not really a version. But I’m afraid it is too late to do an interface changing which will break our backward compatibility 😭</p>
<h3 id="Side-Effect-Free-Functions"><a href="#Side-Effect-Free-Functions" class="headerlink" title="Side-Effect-Free Functions"></a>Side-Effect-Free Functions</h3><p>Just as I mentioned, due to some performance issues, we cannot make many our functions side-effect-free. I think the MvccTxn and the reader in it has a lot of read functions which seems should be side-effect-free but in fact not. Many of them are related with putting cursors at a certain place. Hope we can find a good way to optimize this.</p>
<h3 id="Assertions"><a href="#Assertions" class="headerlink" title="Assertions"></a>Assertions</h3><p>This is the pattern I want to put great emphasis on: there are many rules (pre/post-conditions of function call) in our code, and some of them are hidden, we need to check the code carefully to find it out. We should make them clear by using assertions. <a href="https://github.com/longfangsong/tikv/blob/ec2e1362af8bc769bd0a80dd0176eb8bddaf2c17/src/storage/txn/actions/prewrite/mutation.rs#L142" target="_blank" rel="noopener">Here</a> is an example in TiKV. And <a href="https://github.com/longfangsong/client-rust/blob/ccea287e2261e2777254ee03ddd1c73832fba4b5/src/transaction/transaction.rs#L618" target="_blank" rel="noopener">here</a> is an example in client-rust, which do helped me found an bug<sup id="fnref:3"><a href="#fn:3" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="I used to set primary key for all `insert`s of mutations, but we should not set it for `Cache` variant, when I run a read-only transaction, this assert helped me to found this bug">[3]</span></a></sup>.</p>
<p>DDD also suggest to check pre/post-conditions during the unit test, which I think we can put more work on.</p>
<p>One thing to consider when using assertions is whether the condition should be checked by using assertion or return a run time error, eg. I don’t know whether we should <code>assert!(for_update_ts&gt;0)</code> or just return some error when the user tries to acquire pessimistic lock.</p>
<h3 id="Conceptual-Contours"><a href="#Conceptual-Contours" class="headerlink" title="Conceptual Contours"></a>Conceptual Contours</h3><p>Don’t find a clear usage now.</p>
<h3 id="Standalone-Classes"><a href="#Standalone-Classes" class="headerlink" title="Standalone Classes"></a>Standalone Classes</h3><p>Don’t find a clear usage now.</p>
<h3 id="Closure-of-Operations"><a href="#Closure-of-Operations" class="headerlink" title="Closure of Operations"></a>Closure of Operations</h3><p>Don’t find a clear usage now.</p>
<h3 id="Declarative-Design"><a href="#Declarative-Design" class="headerlink" title="Declarative Design"></a>Declarative Design</h3><p>This one is what I really want to have, I think this is really import for make our product to have less bugs.</p>
<p>See [intention-revealing interfaces](#Intention-Revealing Interfaces), [side-effect-free functions](#Side-Effect-Free Functions), and <a href="#Assertions">assertions</a> for details.</p>
<h3 id="Bounded-Context"><a href="#Bounded-Context" class="headerlink" title="Bounded Context"></a>Bounded Context</h3><p>I think we somehow has several bounded contexts, things like transaction layer, mvcc layer, raft layer can be regarded as having their own bounded context, though sometimes we have to went out of the context bondary for performance optimization. We always see relational-database related things in TiKV.</p>
<h3 id="Continuous-Integration"><a href="#Continuous-Integration" class="headerlink" title="Continuous Integration"></a>Continuous Integration</h3><p>We’ve done a great job at doing Continuous Integration on our produces, CI runs for every pr and TiPocket can check how components other than TiDB/PD/TiKV works with them. But I’m not very sure whether we done a great job at doing Continuous Integration on our concepts.</p>
<h3 id="Context-Map"><a href="#Context-Map" class="headerlink" title="Context Map"></a>Context Map</h3><p>I hope this one can solve some of our incompatible problems.</p>
<p>We should:</p>
<blockquote>
<p>Describe the points of contact between the models, outlining explicit translation for any communication, highlighting any sharing, isolation mechanisms, and levels of influence.</p>
</blockquote>
<p>For different parts in our software.</p>
<p>For example, I don’t really know what property of our transaction layer must hold for cdc to work properly, and I cannot find a document for that.</p>
<h3 id="Shared-Kernel"><a href="#Shared-Kernel" class="headerlink" title="Shared Kernel"></a>Shared Kernel</h3><p>Don’t find a clear usage now.</p>
<h3 id="Customer-Supplier-Development"><a href="#Customer-Supplier-Development" class="headerlink" title="Customer/Supplier Development"></a>Customer/Supplier Development</h3><p>This is another pattern which is important to prevent compatibility issues. We should consider all downstream<sup id="fnref:5"><a href="#fn:5" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="TiKV is really upstream in our development process! Maybe the only component which is in upstream of TiKV is rocksdb.">[5]</span></a></sup> components when designing features.</p>
<p>To achieve these, we probably need to:</p>
<ul>
<li>Identify all our downstream components, AFAIK, these components are:<ul>
<li>TiDB (or in a more detail style: DDL and DML)</li>
<li>TiSpark</li>
<li>TiFlash</li>
<li>PD</li>
<li>TiKV clients</li>
<li>CDC</li>
<li>BR</li>
<li>Lightning</li>
</ul>
</li>
<li>Identify how they expect TiKV txn system to work (<a href="https://docs.google.com/document/d/1pbtEx49F9VXJzphCt-PzfypOk_DVKCkD0F3BXoioDO4/edit#heading=h.9xq88so7dy1q" target="_blank" rel="noopener">this</a> is a good example), and <strong>write them down</strong>. Maybe we need to add several related docs in <code>sig-transaction</code>.</li>
<li>Write tests according to these specs, and use them to check our implementation.</li>
<li>Consider all these spec when trying to implement something new.</li>
</ul>
<h3 id="Conformist"><a href="#Conformist" class="headerlink" title="Conformist"></a>Conformist</h3><p>Don’t find a clear usage now.</p>
<h3 id="Anticorruption-Layer"><a href="#Anticorruption-Layer" class="headerlink" title="Anticorruption Layer"></a>Anticorruption Layer</h3><p>Don’t find a clear usage now.</p>
<h3 id="Separate-Ways"><a href="#Separate-Ways" class="headerlink" title="Separate Ways"></a>Separate Ways</h3><p>I’m always considering do some clear separation between differnt kinds of transaction. Do we really benefit a lot from sharing codes among different transaction types? What if we completly seperatate the handling process of different kinds of transactions, and extract the <strong>Shared Kernel</strong>? Will it be better if we keep some duplicate code but make the process of handling different kinds of transaction?</p>
<h3 id="Open-host-Service"><a href="#Open-host-Service" class="headerlink" title="Open-host Service"></a>Open-host Service</h3><p>Can we implement several “hooks” during the whole process of transaction handling, and systems which need to preserve this process can use these hooks to check the status like cdc instead of designing an interface by their own?</p>
<h3 id="Published-Language"><a href="#Published-Language" class="headerlink" title="Published Language"></a>Published Language</h3><p>Don’t find a clear usage now.</p>
<h3 id="Core-Domain"><a href="#Core-Domain" class="headerlink" title="Core Domain"></a>Core Domain</h3><p>Don’t find a clear usage now.</p>
<h3 id="Generic-Subdomains"><a href="#Generic-Subdomains" class="headerlink" title="Generic Subdomains"></a>Generic Subdomains</h3><p>Don’t find a clear usage now.</p>
<h3 id="Domain-Vision-Statement"><a href="#Domain-Vision-Statement" class="headerlink" title="Domain Vision Statement"></a>Domain Vision Statement</h3><p>Don’t find a clear usage now.</p>
<h3 id="Highlighted-Core"><a href="#Highlighted-Core" class="headerlink" title="Highlighted Core"></a>Highlighted Core</h3><p>Don’t find a clear usage now.</p>
<h3 id="Cohesive-Mechanisms"><a href="#Cohesive-Mechanisms" class="headerlink" title="Cohesive Mechanisms"></a>Cohesive Mechanisms</h3><p>Don’t find a clear usage now.</p>
<h3 id="Segregated-Core"><a href="#Segregated-Core" class="headerlink" title="Segregated Core"></a>Segregated Core</h3><p>Don’t find a clear usage now.</p>
<h3 id="Abstract-Core"><a href="#Abstract-Core" class="headerlink" title="Abstract Core"></a>Abstract Core</h3><p>Don’t find a clear usage now.</p>
<h3 id="Evolving-Order"><a href="#Evolving-Order" class="headerlink" title="Evolving Order"></a>Evolving Order</h3><p>Don’t find a clear usage now.</p>
<h3 id="System-Metaphor"><a href="#System-Metaphor" class="headerlink" title="System Metaphor"></a>System Metaphor</h3><p>Don’t find a clear usage now.</p>
<h3 id="Responsibility-Layers"><a href="#Responsibility-Layers" class="headerlink" title="Responsibility Layers"></a>Responsibility Layers</h3><p>Don’t find a clear usage now.</p>
<h3 id="Knowledge-Level"><a href="#Knowledge-Level" class="headerlink" title="Knowledge Level"></a>Knowledge Level</h3><p>Don’t find a clear usage now.</p>
<h3 id="Pluggable-Component-Framework"><a href="#Pluggable-Component-Framework" class="headerlink" title="Pluggable Component Framework"></a>Pluggable Component Framework</h3><p>The “Holy Grail” I hope TiKV to have! Imaging what we can do if we can remove/change/extend the max supported isolation level, the transaction model, the consensus algorithm, different kinds of coprocessor, the storage engine freely with just config change!</p>
<p>But this is just a hope, it is impossible to implement such a great work with acceptable development time, and it is hard to keep the performance, it is also not very useful for our customers.</p>
<p>But for some component it is possible and valuable, I think a pluggable copr layer is WIP now.</p>
<h2 id="Summary"><a href="#Summary" class="headerlink" title="Summary"></a>Summary</h2><p>I have viewed all patterns in DDD now, I think there’re something I metioned above for several times, which means we do can put some efforts on:</p>
<ul>
<li>Collect some “dictionary” or wiki for the concepts (code structures, config items or even slang we use only during discussion) in TiKV, which can make us find the meaning of a word in our <strong>Ubiquitous Language</strong>.</li>
<li>Build an all-in-one <strong>model</strong> which cover all aspects in TiKV, at least the txn system, which can help us to understand the code, diagnosising problems and finding possible optimizing.</li>
<li>Make the hidden <strong>specification</strong> in our code clear, by using <strong>assertions</strong>, unit tests and so on.</li>
</ul>
<div id="footnotes"><hr><div id="footnotelist"><ol style="list-style: none; padding-left: 0; margin-left: 40px"><li id="fn:1"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">1.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;">Except me, after some work on database and distrubuted system, I think I know nothing about database or distrubuted system 😭……<a href="#fnref:1" rev="footnote"> ↩</a></span></li><li id="fn:2"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">2.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;">Some database terminologies have ambiguity too, for example, consistency has at least 4 different meanings, see part Ⅱ, chapter 7 in the DDIA book. And in percolator, commit can mean commit of the transaction (prewrite + commit stage) or just the &quot;commit stage&quot;. Naming is really hard!<a href="#fnref:2" rev="footnote"> ↩</a></span></li><li id="fn:3"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">3.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;">I used to set primary key for all <code>insert</code>s of mutations, but we should not set it for <code>Cache</code> variant, when I run a read-only transaction, this assert helped me to found this bug<a href="#fnref:3" rev="footnote"> ↩</a></span></li><li id="fn:4"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">4.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;">I'm always tring to build a (visible) model which cover all aspects in TiKV, at least the txn system. Which is not only good for understanding the code, but also helpful when diagnosising problems and finding possible optimizing.<a href="#fnref:4" rev="footnote"> ↩</a></span></li><li id="fn:5"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">5.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;">TiKV is really upstream in our development process! Maybe the only component which is in upstream of TiKV is rocksdb.<a href="#fnref:5" rev="footnote"> ↩</a></span></li></ol></div></div></div><div class="post-footer"><div class="meta"><div class="info"><i class="fa fa-sun-o"></i><span class="date">2021-01-04</span><i class="fa fa-tag"></i><a class="tag" href="/tags/软件工程/" title="软件工程">软件工程 </a><a class="tag" href="/tags/DDD/" title="DDD">DDD </a><a class="tag" href="/tags/TiKV/" title="TiKV">TiKV </a></div></div></div></div><div class="share"><div class="evernote"><a class="fa fa-bookmark" href="javascript:(function(){EN_CLIP_HOST='http://www.evernote.com';try{var%20x=document.createElement('SCRIPT');x.type='text/javascript';x.src=EN_CLIP_HOST+'/public/bookmarkClipper.js?'+(new%20Date().getTime()/100000);document.getElementsByTagName('head')[0].appendChild(x);}catch(e){location.href=EN_CLIP_HOST+'/clip.action?url='+encodeURIComponent(location.href)+'&amp;title='+encodeURIComponent(document.title);}})();" ref="nofollow" target="_blank"></a></div><div class="weibo"><a class="fa fa-weibo" href="javascript:void((function(s,d,e){try{}catch(e){}var f='http://service.weibo.com/share/share.php?',u=d.location.href,p=['url=',e(u),'&amp;title=',e(d.title),'&amp;appkey=2924220432'].join('');function a(){if(!window.open([f,p].join(''),'mb',['toolbar=0,status=0,resizable=1,width=620,height=450,left=',(s.width-620)/2,',top=',(s.height-450)/2].join('')))u.href=[f,p].join('');};if(/Firefox/.test(navigator.userAgent)){setTimeout(a,0)}else{a()}})(screen,document,encodeURIComponent));"></a></div><div class="twitter"><a class="fa fa-twitter" href="http://twitter.com/home?status=,http://longfangsong.github.io/2021/01/04/Domain-Driven-Design-——-Can-it-work-on-Infrastructure-Software-Development/,Blog,Domain Driven Design —— Can it work on Infrastructure Software Development?,;" target="_blank" rel="noopener"></a></div></div><div class="pagination"><ul class="clearfix"><li class="next pagbuttons"><a class="btn" role="navigation" href="/2020/12/10/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E4%B8%AD%E7%9A%84%E6%97%B6%E9%92%9F/" title="分布式系统中的时钟">下一篇</a></li></ul></div><a id="comments"></a><div id="vcomments" style="margin:0 30px;"></div><script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script><script src="//cdn.jsdelivr.net/gh/xcss/valine@v1.1.7/dist/Valine.min.js?v=undefined"></script><script>var valine = new Valine({
  el:'#vcomments',
  notify:false || false, 
  verify:false|| false, 
  app_id:'HcCTt2sXmRChcaE4nMoSibwJ-gzGzoHsz',
  app_key:'6eevqWRr7jsWPUavkkAQjIMi',
  placeholder:'随便说点啥吧……',
  path: window.location.pathname,
  avatar:'mm'
})</script></div></div></div></div><script src="/js/jquery.js"></script><script src="/js/jquery-migrate-1.2.1.min.js"></script><script src="/js/jquery.appear.js"></script></body></html>