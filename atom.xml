<?xml version="1.0" encoding="UTF-8"?>
<feed xmlns="http://www.w3.org/2005/Atom" xml:lang="zh">
    <title>Blog</title>
    <subtitle>生命是灰色的，而理论之树常青</subtitle>
    <link href="https://longfangsong.github.io/atom.xml" rel="self" type="application/atom+xml"/>
    <link href="https://longfangsong.github.io"/>
    <generator uri="https://www.getzola.org/">Zola</generator>
    <updated>2023-10-19T11:58:34.553+00:00</updated>
    <id>https://longfangsong.github.io/atom.xml</id>
    <entry xml:lang="zh">
        <title>重新开始学数学 • 贝叶斯因果推理（4）</title>
        <published>2023-10-19T11:58:34.553+00:00</published>
        <updated>2023-10-19T11:58:34.553+00:00</updated>
        <author>
          <name>Unknown</name>
        </author>
        <link rel="alternate" href="https://longfangsong.github.io/restart-math-stastic-bayesian-4/" type="text/html"/>
        <id>https://longfangsong.github.io/restart-math-stastic-bayesian-4/</id>
        
        <content type="html">&lt;p&gt;Overfitting 和 Underfitting 的概念大家都很熟悉，就不赘述了。&lt;&#x2F;p&gt;
&lt;h2 id=&quot;ping-gu-mo-xing-hao-pi&quot;&gt;评估模型好坏&lt;&#x2F;h2&gt;
&lt;h3 id=&quot;cross-validation&quot;&gt;Cross Validation&lt;&#x2F;h3&gt;
&lt;blockquote&gt;
&lt;p&gt;test the model’s predictive accuracy on a small part of the sample.&lt;&#x2F;p&gt;
&lt;&#x2F;blockquote&gt;
&lt;h3 id=&quot;xin-xi-liang-zhun-ze-information-criteria&quot;&gt;信息量准则（information criteria）&lt;&#x2F;h3&gt;
&lt;blockquote&gt;
&lt;p&gt;likelihood-based measures of model fit that include a penalty for complexity.&lt;&#x2F;p&gt;
&lt;&#x2F;blockquote&gt;
&lt;p&gt;AIC、WAIC 等都是信息量准则的例子。&lt;&#x2F;p&gt;
&lt;h2 id=&quot;fang-zhi-overfitting-de-shou-duan&quot;&gt;防止 Overfitting 的手段&lt;&#x2F;h2&gt;
&lt;h3 id=&quot;regularizing-prior&quot;&gt;regularizing prior&lt;&#x2F;h3&gt;
&lt;p&gt;简单来说就是选择更“紧”的 prior。&lt;&#x2F;p&gt;
&lt;h3 id=&quot;multilevel-model&quot;&gt;Multilevel model&lt;&#x2F;h3&gt;
&lt;p&gt;有时数据中可以显现出一些明显的分组（cluster）。使用 Multilevel model 可以更好地处理这种情况，防止由于重复采样、不均衡采样导致的 underfit 或 overfit 问题，同时能更好的捕捉组间、组内的差异。&lt;&#x2F;p&gt;
&lt;h4 id=&quot;li-zi&quot;&gt;例子&lt;&#x2F;h4&gt;
&lt;p&gt;比如关于蝌蚪死亡率的模型：&lt;&#x2F;p&gt;
&lt;p&gt;$$
\begin{align}
S_i &amp;amp;\sim Binomial(N_i, p_i) \\
logit(p_i) &amp;amp;= \alpha_{Tank[i]} \\
\alpha_{i} &amp;amp;\sim Normal(0, 1.5) \\
\end{align}
$$&lt;&#x2F;p&gt;
&lt;p&gt;我们可以将这个模型“升级”为 Multilevel model：&lt;&#x2F;p&gt;
&lt;p&gt;$$
\begin{align}
S_i &amp;amp;\sim Binomial(N_i, p_i) \\
logit(p_i) &amp;amp;= \alpha_{Tank[i]} \\
\alpha_{i} &amp;amp;\sim Normal(\overline \alpha, \sigma) \\
\overline \alpha &amp;amp;\sim Normal(0, 1.5) \\
\sigma &amp;amp;\sim Exp(1)
\end{align}
$$&lt;&#x2F;p&gt;
&lt;p&gt;相比于针对每个 Tank 估计一个完全无关 $\alpha$，这个新模型限制了 $\alpha$ 的分布，使得 $\alpha$ 之间的差异更小，同时也更好地捕捉了 $\alpha$ 的分布。&lt;&#x2F;p&gt;
&lt;h4 id=&quot;shrinkage&quot;&gt;shrinkage&lt;&#x2F;h4&gt;
&lt;p&gt;Multilevel model 的一个重要特性是 shrinkage。&lt;&#x2F;p&gt;
&lt;p&gt;对于每个组，我们都会估计一个 $\alpha$，这些 $\alpha$ 都遵循以 $\overline \alpha$ 为均值的正态分布。&lt;&#x2F;p&gt;
&lt;p&gt;如果某个组的数据很少，因为这个组的数据对 $\alpha$ 的估计相对不是很可靠，这个组的 $\alpha$ 会更接近利用 $\overline \alpha$ 计算出的值。&lt;&#x2F;p&gt;
&lt;p&gt;如果某个组的数据很多，因为这个组的数据对 $\alpha$ 的估计相对可靠，这个组的 $\alpha$ 会更接近利用这个组的数据计算出的值。&lt;&#x2F;p&gt;
&lt;p&gt;但无论如何，所有使用含 $\overline \alpha$ 的 multilevel 模型做出的估计都会比原模型更接近直接 $\overline \alpha$ 代替 $\alpha$ 的估计，这个效应称为 shrinkage。&lt;&#x2F;p&gt;
&lt;h4 id=&quot;pooling&quot;&gt;Pooling&lt;&#x2F;h4&gt;
&lt;ul&gt;
&lt;li&gt;Complete pooling. This means we assume that the population of clusters is invariant, the same as estimating a common intercept for all clusters.&lt;&#x2F;li&gt;
&lt;li&gt;No pooling. This means we assume that each cluster tells us nothing about any other cluster.&lt;&#x2F;li&gt;
&lt;li&gt;Partial pooling. This means using an adaptive regularizing prior.&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;一般来说使用 Multilevel model 就是采用了 partial pooling。&lt;&#x2F;p&gt;
&lt;h4 id=&quot;varying-effects&quot;&gt;Varying effects&lt;&#x2F;h4&gt;
&lt;p&gt;varying intercepts: For each cluster in the data, we use a unique intercept parameter. eg. liveness of tadpoles in different tanks&lt;&#x2F;p&gt;
&lt;p&gt;varying slope: For each cluster in the data, we use a unique slope parameter. eg. busy&#x2F;unbusy café -&amp;gt; waitime&lt;&#x2F;p&gt;
</content>
        
    </entry>
    <entry xml:lang="zh">
        <title>重新开始学数学 • 贝叶斯因果推理（3）</title>
        <published>2023-10-16T20:53:15.303+00:00</published>
        <updated>2023-10-16T20:53:15.303+00:00</updated>
        <author>
          <name>Unknown</name>
        </author>
        <link rel="alternate" href="https://longfangsong.github.io/restart-math-stastic-bayesian-3/" type="text/html"/>
        <id>https://longfangsong.github.io/restart-math-stastic-bayesian-3/</id>
        
        <content type="html">&lt;h2 id=&quot;bei-xie-si-mo-xing&quot;&gt;贝叶斯模型&lt;&#x2F;h2&gt;
&lt;p&gt;要建立一个贝叶斯模型，我们需要确定模型的&lt;strong&gt;输出&lt;&#x2F;strong&gt;（outcome）符合什么分布，这意味着我们需要选择一个似然函数。&lt;&#x2F;p&gt;
&lt;p&gt;eg.&lt;&#x2F;p&gt;
&lt;p&gt;$$
height \sim Normal(\mu, \sigma)
$$&lt;&#x2F;p&gt;
&lt;h3 id=&quot;ru-he-xuan-ze-si-ran-han-shu&quot;&gt;如何选择似然函数&lt;&#x2F;h3&gt;
&lt;p&gt;选择似然函数的时候，要考虑：&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;数据本身的情况，比如是整数还是浮点数，是否有上下界等（Epistemological, which means philosophy behind knowledge）。&lt;&#x2F;li&gt;
&lt;li&gt;要描述的对象在现实中是如何分布的，比如大量随机影响下，数据常常（天然地）呈正态分布（Ontological, which means the nature of the world）。&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;所选择的似然函数常常会需要传入&lt;strong&gt;参数&lt;&#x2F;strong&gt;(parameters)，对于每个参数，我们需要在一开始估计它的分布，这个分布称为这个参数的先验(prior)。&lt;&#x2F;p&gt;
&lt;p&gt;eg.&lt;&#x2F;p&gt;
&lt;p&gt;$$
\sigma \sim Exp(?)
$$&lt;&#x2F;p&gt;
&lt;p&gt;有些参数可能和你所知道的其他输入有关，此时，这些输入称为&lt;strong&gt;自变量&lt;&#x2F;strong&gt;（predictor variable）。&lt;&#x2F;p&gt;
&lt;p&gt;eg.&lt;&#x2F;p&gt;
&lt;p&gt;$$
\mu = \alpha + \beta \times (weight - 150)
$$&lt;&#x2F;p&gt;
&lt;p&gt;这里的 $\alpha$ 和 $\beta$ 是新增加的参数，而 $weight$ 就是自变量。&lt;&#x2F;p&gt;
&lt;p&gt;所以我们整个的模型就是：&lt;&#x2F;p&gt;
&lt;p&gt;$$
\displaylines {
height &amp;amp; \sim &amp;amp;  Normal(\mu, \sigma) \\
\mu &amp;amp; = &amp;amp; \alpha + \beta \times weight \\
\alpha &amp;amp; \sim &amp;amp;  Normal(?, ?) \\
\beta &amp;amp; \sim &amp;amp;  Normal(?, ?) \\
\sigma &amp;amp; \sim &amp;amp; Exp(?)
}
$$&lt;&#x2F;p&gt;
&lt;p&gt;现在我们需要确定模型中这些 $?$ 的值，并验证这些值是相对好的，这个过程称为 prior predictive check。&lt;&#x2F;p&gt;
&lt;h3 id=&quot;prior-predictive-check&quot;&gt;Prior predictive check&lt;&#x2F;h3&gt;
&lt;p&gt;Prior predictive check 的目的是检查模型中的先验分布是否合理。&lt;&#x2F;p&gt;
&lt;p&gt;一般来说 prior predictive check 的方法是选定一组 prior，然后用这组 prior 生成一些数据，看这些数据是否合理。&lt;&#x2F;p&gt;
&lt;p&gt;比如以上面的例子来说，如果取以下的 prior：&lt;&#x2F;p&gt;
&lt;p&gt;$$
\displaylines {
height &amp;amp; \sim &amp;amp; Normal(\mu, \sigma) \\
\mu &amp;amp; = &amp;amp; \alpha + \beta \times (weight - 150) \\
\alpha &amp;amp; \sim &amp;amp;  Normal(0, 1) \\
\beta &amp;amp; \sim &amp;amp;  Normal(0, 1) \\
\sigma &amp;amp; \sim &amp;amp; Exp(1)
}
$$&lt;&#x2F;p&gt;
&lt;p&gt;那么模型可以生成（大量的）负数的 height，这显然是不合理的。&lt;&#x2F;p&gt;
&lt;p&gt;根据经验，人的身高大约在 165 厘米左右，且身高和体重呈正相关，因此一组更好的 prior 可以是：&lt;&#x2F;p&gt;
&lt;p&gt;$$
\displaylines {
height &amp;amp; \sim &amp;amp; Normal(\mu, \sigma) \\
\mu &amp;amp; = &amp;amp; \alpha + \beta \times (weight - 60) \\
\alpha &amp;amp; \sim &amp;amp; Normal(165, 20) \\
\beta &amp;amp; \sim &amp;amp;  Normal(0.5, 0.2) \\
\sigma &amp;amp; \sim &amp;amp; Exp(1)
}
$$&lt;&#x2F;p&gt;
&lt;p&gt;当然你也可以搜集更多的知识选择更好的 prior，或者换用更合理的分布函数，比如让 $\beta &amp;amp; \sim &amp;amp; log-Normal(?, ?)$。&lt;&#x2F;p&gt;
&lt;h3 id=&quot;ru-he-xue-xi-can-shu-de-zhi&quot;&gt;如何学习参数的值&lt;&#x2F;h3&gt;
&lt;p&gt;一个常用的方法是使用 MCMC（Markov chain Monte Carlo）。&lt;&#x2F;p&gt;
&lt;p&gt;例如，我们对于以下模型：&lt;&#x2F;p&gt;
&lt;p&gt;$$
\displaylines {
W  &amp;amp; \sim &amp;amp; Binomial(9, p) \\
\p &amp;amp; \sim &amp;amp; Normal(0.5, 0.1)
}
$$&lt;&#x2F;p&gt;
&lt;p&gt;可以使用 MCMC 方法来学习 $p$ 的值，使用 rethinking 包如下：&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;r&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-r &quot;&gt;&lt;code class=&quot;language-r&quot; data-lang=&quot;r&quot;&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;ulam&lt;&#x2F;span&gt;&lt;span&gt;(
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;alist&lt;&#x2F;span&gt;&lt;span&gt;(
&lt;&#x2F;span&gt;&lt;span&gt;        W &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;~ &lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;dbinom&lt;&#x2F;span&gt;&lt;span&gt;(W + L, p), &lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;# binomial likelihood
&lt;&#x2F;span&gt;&lt;span&gt;        p &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;~ &lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;dnorm&lt;&#x2F;span&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;0.5&lt;&#x2F;span&gt;&lt;span&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;0.1&lt;&#x2F;span&gt;&lt;span&gt;) &lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;# uniform prior
&lt;&#x2F;span&gt;&lt;span&gt;    ),
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;data &lt;&#x2F;span&gt;&lt;span&gt;= &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;list&lt;&#x2F;span&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;W &lt;&#x2F;span&gt;&lt;span&gt;= &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;6&lt;&#x2F;span&gt;&lt;span&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;L &lt;&#x2F;span&gt;&lt;span&gt;= &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;3&lt;&#x2F;span&gt;&lt;span&gt;)
&lt;&#x2F;span&gt;&lt;span&gt;)
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;功能上相当于：&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;r&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-r &quot;&gt;&lt;code class=&quot;language-r&quot; data-lang=&quot;r&quot;&gt;&lt;span&gt;W &amp;lt;- &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;6
&lt;&#x2F;span&gt;&lt;span&gt;L &amp;lt;- &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;3
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;# MCMC 的一个 chain
&lt;&#x2F;span&gt;&lt;span&gt;n_samples &amp;lt;- &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;1000
&lt;&#x2F;span&gt;&lt;span&gt;p &amp;lt;- &lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;rep&lt;&#x2F;span&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;NA&lt;&#x2F;span&gt;&lt;span&gt;, n_samples)
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;# prior
&lt;&#x2F;span&gt;&lt;span&gt;p[&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;1&lt;&#x2F;span&gt;&lt;span&gt;] &amp;lt;- &lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;rnorm&lt;&#x2F;span&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;1&lt;&#x2F;span&gt;&lt;span&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;0.5&lt;&#x2F;span&gt;&lt;span&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;0.1&lt;&#x2F;span&gt;&lt;span&gt;)
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;for &lt;&#x2F;span&gt;&lt;span&gt;(i in &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;2&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;:&lt;&#x2F;span&gt;&lt;span&gt;n_samples) {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;# 选取一个新的 p
&lt;&#x2F;span&gt;&lt;span&gt;    p_new &amp;lt;- &lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;rnorm&lt;&#x2F;span&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;1&lt;&#x2F;span&gt;&lt;span&gt;, p[i - &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;1&lt;&#x2F;span&gt;&lt;span&gt;], &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;0.1&lt;&#x2F;span&gt;&lt;span&gt;)
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;# 比较新旧 p 的结果
&lt;&#x2F;span&gt;&lt;span&gt;    q0 &amp;lt;- &lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;dbinom&lt;&#x2F;span&gt;&lt;span&gt;(W, W + L, p[i - &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;1&lt;&#x2F;span&gt;&lt;span&gt;])
&lt;&#x2F;span&gt;&lt;span&gt;    q1 &amp;lt;- &lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;dbinom&lt;&#x2F;span&gt;&lt;span&gt;(W, W + L, p_new)
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;# 判断是否接受新的 p
&lt;&#x2F;span&gt;&lt;span&gt;    p[i] &amp;lt;- &lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;ifelse&lt;&#x2F;span&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;runif&lt;&#x2F;span&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;1&lt;&#x2F;span&gt;&lt;span&gt;) &amp;lt; q1 &#x2F; q0, p_new, p[i - &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;1&lt;&#x2F;span&gt;&lt;span&gt;])
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
</content>
        
    </entry>
    <entry xml:lang="zh">
        <title>重新开始学数学 • 贝叶斯因果推理（2）</title>
        <published>2023-10-16T20:52:15.303+00:00</published>
        <updated>2023-10-16T20:52:15.303+00:00</updated>
        <author>
          <name>Unknown</name>
        </author>
        <link rel="alternate" href="https://longfangsong.github.io/restart-math-stastic-bayesian-2/" type="text/html"/>
        <id>https://longfangsong.github.io/restart-math-stastic-bayesian-2/</id>
        
        <content type="html">&lt;h2 id=&quot;yin-guo-guan-xi-tu-causal-graph-causal-dag&quot;&gt;因果关系图（Causal graph, Causal DAG）&lt;&#x2F;h2&gt;
&lt;blockquote&gt;
&lt;p&gt;causal graphs (also known as path diagrams, causal Bayesian networks or DAGs) are probabilistic graphical models used to encode assumptions about the data-generating process.&lt;&#x2F;p&gt;
&lt;&#x2F;blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;The causal graph can be drawn in the following way. Each variable in the model has a corresponding vertex or node and an arrow is drawn from a variable X to a variable Y whenever Y is judged to respond to changes in X when all other variables are being held constant. Variables connected to Y through direct arrows are called parents of Y, or &amp;quot;direct causes of Y,&amp;quot; and are denoted by Pa(Y).&lt;&#x2F;p&gt;
&lt;&#x2F;blockquote&gt;
&lt;p&gt;简单来说就是用来描述因果关系的有向无环图。&lt;&#x2F;p&gt;
&lt;iframe class=&quot;quiver-embed&quot; src=&quot;https:&#x2F;&#x2F;q.uiver.app&#x2F;#q=WzAsMixbMCwwLCJQcmVkaWN0b3IiXSxbMiwwLCJPdXRjb21lIl0sWzAsMV1d&amp;embed&quot; width=&quot;432&quot; height=&quot;176&quot; style=&quot;border-radius: 8px; border: none; width: 688px; height: 176px&quot;&gt;&lt;&#x2F;iframe&gt;
&lt;h3 id=&quot;hun-za-confounding&quot;&gt;混杂（confounding）&lt;&#x2F;h3&gt;
&lt;blockquote&gt;
&lt;p&gt;Let’s define confounding as any context in which the association between an outcome Y and a predictor of interest X is not the same as it would be, if we had experimentally determined the values of X.&lt;&#x2F;p&gt;
&lt;&#x2F;blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;Let X be some independent variable, and Y some dependent variable. To estimate the effect of X on Y, the statistician must suppress the effects of extraneous variables that influence both X and Y. We say that X and Y are confounded by some other variable Z whenever Z causally influences both X and Y.&lt;&#x2F;p&gt;
&lt;&#x2F;blockquote&gt;
&lt;p&gt;简单来说就是，在研究 $X$ 对 $Y$ 的影响时，如果 $X$ 和 $Y$ 之间的关系被其他变量 $Z$ 所影响，那么 $Z$ 就是 $X$ 与 $Y$ 之间的混杂因素。&lt;&#x2F;p&gt;
&lt;p&gt;Will produce false inferences about causal effects.&lt;&#x2F;p&gt;
&lt;p&gt;存在 4 种基本的混杂情况。&lt;&#x2F;p&gt;
&lt;h4 id=&quot;fork&quot;&gt;Fork&lt;&#x2F;h4&gt;
&lt;iframe class=&quot;quiver-embed&quot; src=&quot;https:&#x2F;&#x2F;q.uiver.app&#x2F;#q=WzAsMyxbMCwxLCJQcmVkaWN0b3IiXSxbMiwxLCJPdXRjb21lIl0sWzEsMCwiQ29uZm91bmRpbmcgVmFyaWFibGUiXSxbMiwwXSxbMiwxXV0=&amp;embed&quot; width=&quot;432&quot; height=&quot;176&quot; style=&quot;border-radius: 8px; border: none; width: 688px; height: 176px&quot;&gt;&lt;&#x2F;iframe&gt;
&lt;h4 id=&quot;pipe-mediator&quot;&gt;Pipe &#x2F; Mediator&lt;&#x2F;h4&gt;
&lt;iframe class=&quot;quiver-embed&quot; src=&quot;https:&#x2F;&#x2F;q.uiver.app&#x2F;#q=WzAsMyxbMCwxLCJQcmVkaWN0b3IiXSxbMiwxLCJPdXRjb21lIl0sWzEsMCwiQ29uZm91bmRpbmdWYXJpYWJsZSJdLFswLDJdLFsyLDFdXQ==&amp;embed&quot; width=&quot;432&quot; height=&quot;176&quot; style=&quot;border-radius: 8px; border: none; width: 688px; height: 176px&quot;&gt;&lt;&#x2F;iframe&gt;
&lt;h4 id=&quot;collider&quot;&gt;Collider&lt;&#x2F;h4&gt;
&lt;iframe class=&quot;quiver-embed&quot; src=&quot;https:&#x2F;&#x2F;q.uiver.app&#x2F;#q=WzAsMyxbMCwxLCJQcmVkaWN0b3IiXSxbMiwxLCJPdXRjb21lIl0sWzEsMCwiQ29uZm91bmRpbmcgVmFyaWFibGUiXSxbMCwyXSxbMSwyXV0=&amp;embed&quot; width=&quot;432&quot; height=&quot;176&quot; style=&quot;border-radius: 8px; border: none; width: 688px; height: 176px&quot;&gt;&lt;&#x2F;iframe&gt;
&lt;h4 id=&quot;descendant&quot;&gt;Descendant&lt;&#x2F;h4&gt;
&lt;iframe class=&quot;quiver-embed&quot; src=&quot;https:&#x2F;&#x2F;q.uiver.app&#x2F;#q=WzAsNCxbMCwxLCJQcmVkaWN0b3IiXSxbMiwxLCJPdXRjb21lIl0sWzEsMCwiQ29uZm91bmRpbmdWYXJpYWJsZTEiXSxbMSwyLCJDb25mb3VuZGluZ1ZhcmlhYmxlMiJdLFswLDJdLFsxLDJdLFsyLDNdXQ==&amp;embed&quot; width=&quot;432&quot; height=&quot;176&quot; style=&quot;border-radius: 8px; border: none; width: 688px; height: 176px&quot;&gt;&lt;&#x2F;iframe&gt;
&lt;iframe class=&quot;quiver-embed&quot; src=&quot;https:&#x2F;&#x2F;q.uiver.app&#x2F;#q=WzAsNCxbMCwxLCJQcmVkaWN0b3IiXSxbMiwxLCJPdXRjb21lIl0sWzEsMCwiQ29uZm91bmRpbmdWYXJpYWJsZTEiXSxbMSwyLCJDb25mb3VuZGluZ1ZhcmlhYmxlMiJdLFswLDJdLFsyLDNdLFsyLDFdXQ==&amp;embed&quot; width=&quot;432&quot; height=&quot;176&quot; style=&quot;border-radius: 8px; border: none; width: 688px; height: 176px&quot;&gt;&lt;&#x2F;iframe&gt;
&lt;p&gt;其中 $ConfoundVariable2$ 是 Descendant 。&lt;&#x2F;p&gt;
&lt;h3 id=&quot;qu-chu-hun-za-dui-bian-liang-jian-yin-guo-guan-xi-de-ying-xiang&quot;&gt;去除混杂对变量间因果关系的影响&lt;&#x2F;h3&gt;
&lt;h4 id=&quot;path&quot;&gt;Path&lt;&#x2F;h4&gt;
&lt;p&gt;忽略 DAG 中边的方向，如果能从 $X$ 到达 $Y$，那么称 $X$ 到 $Y$ 有一条路径（path）。&lt;&#x2F;p&gt;
&lt;h5 id=&quot;backdoor-path&quot;&gt;Backdoor path&lt;&#x2F;h5&gt;
&lt;blockquote&gt;
&lt;p&gt;In a causal DAG, a backdoor path is a noncausal path between treatment and outcome that remains even if all arrows pointing from treatment to other variables (the descendants of treatment) are re- moved. That is, the path has an arrow pointing into treatment.&lt;&#x2F;p&gt;
&lt;&#x2F;blockquote&gt;
&lt;p&gt;简单来说就是有箭头指向自变量的路径。&lt;&#x2F;p&gt;
&lt;h5 id=&quot;da-kai-guan-bi-path&quot;&gt;打开&#x2F;关闭 Path&lt;&#x2F;h5&gt;
&lt;p&gt;如果一个路径上包含了一个 collider，那么这个路径就是关闭的，否则就是打开的。&lt;&#x2F;p&gt;
&lt;p&gt;在分析 $X$ 到对 $Y$ 的影响时，如果包含了一个打开的 backdoor path，那么这个路径就会干扰我们研究 $X$ 到 $Y$ 的（直接）影响，此时，我们需要关闭这个路径。&lt;&#x2F;p&gt;
&lt;p&gt;假设路径从 $X$ 到 $Y$， 要关闭一个正打开的路径，有两个方法：&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;通过搜集数据、进行实验等方式让 $X$ 随机分布，这样，所有进入 $X$ 的箭头都会被打断，从而关闭路径。&lt;&#x2F;li&gt;
&lt;li&gt;&amp;quot;condition on&amp;quot; 路径上的 fork 和 pipe，即对 fork 和 pipe 上的变量进行控制（即分别对这个变量为不同的值时的模型进行研究），使其不再影响 $X$ 和 $Y$ 之间的关系。
对于 descendent，控制 Descendent 节点可以部分关闭路径。&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;关闭 Path 时，如果 Path 上有多个可以控制的节点，控制其中离 $Y$ 最近的节点对于估计 $X$ 到 $Y$ 之间的影响精度比较有利。&lt;&#x2F;p&gt;
&lt;p&gt;此外，控制 collider 会打开原本在这个 collider 上关闭的 Path。&lt;&#x2F;p&gt;
</content>
        
    </entry>
    <entry xml:lang="zh">
        <title>形式语义学 • 操作语义</title>
        <published>2023-09-25T20:26:11.203+00:00</published>
        <updated>2023-09-25T20:26:11.203+00:00</updated>
        <author>
          <name>Unknown</name>
        </author>
        <link rel="alternate" href="https://longfangsong.github.io/operational-semantics/" type="text/html"/>
        <id>https://longfangsong.github.io/operational-semantics/</id>
        
        <content type="html">&lt;h2 id=&quot;shi-shi-yao&quot;&gt;是什么&lt;&#x2F;h2&gt;
&lt;p&gt;一种着重于描述语言的执行过程的，对程序语言语义的形式化描述方法。&lt;&#x2F;p&gt;
&lt;blockquote&gt;
&lt;p&gt;An operational semantics for a programming language is a mathematical definition of its computation relation, $e ⇒ v$ &lt;sup class=&quot;footnote-reference&quot;&gt;&lt;a href=&quot;#1&quot;&gt;1&lt;&#x2F;a&gt;&lt;&#x2F;sup&gt;, where e is a program in the language.&lt;&#x2F;p&gt;
&lt;&#x2F;blockquote&gt;
&lt;h2 id=&quot;wei-shi-yao&quot;&gt;为什么&lt;&#x2F;h2&gt;
&lt;blockquote&gt;
&lt;p&gt;the goal is to give a precise mathematical model of computations&#x2F;programs —— Lecture notes of DAT350, Chalmers&#x2F;GU&lt;&#x2F;p&gt;
&lt;&#x2F;blockquote&gt;
&lt;h2 id=&quot;cao-zuo-yu-yi-vs-zhi-cheng-yu-yi-vs-gong-li-yu-yi&quot;&gt;操作语义 vs 指称语义 vs 公理语义&lt;&#x2F;h2&gt;
&lt;p&gt;指称语义更重视“找到代表程序所做所为的数学对象”，比如把无类型 lambda 演算映射到 Martin Lof type theory，从而证明这个语言是 soundness 的。&lt;&#x2F;p&gt;
&lt;p&gt;公理语义的想法是“给出一些公理，以此定义程序的含义”，最常见的例子就是 Hoare logic，可以理解为是关注程序在一些（作为 pre&#x2F;postcondition 的 ）prediction 上的作用效果。&lt;&#x2F;p&gt;
&lt;p&gt;操作语义则关注“程序的执行过程”，它的目标是给出一个形式化的执行模型。&lt;&#x2F;p&gt;
&lt;h2 id=&quot;zen-yao-zuo&quot;&gt;怎么做&lt;&#x2F;h2&gt;
&lt;p&gt;比如说我们要给只有整数的数学表达式定义操作语义。&lt;&#x2F;p&gt;
&lt;p&gt;这个语言的语法是：&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;agda&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-agda &quot;&gt;&lt;code class=&quot;language-agda&quot; data-lang=&quot;agda&quot;&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;data Nat &lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;Set where
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;zero &lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;Nat
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;suc  &lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;Nat &lt;&#x2F;span&gt;&lt;span&gt;-&amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;Nat
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;data &lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;exp &lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;Set where
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;Const &lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;Nat &lt;&#x2F;span&gt;&lt;span&gt;-&amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;exp
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;Add &lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;exp &lt;&#x2F;span&gt;&lt;span&gt;-&amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;exp &lt;&#x2F;span&gt;&lt;span&gt;-&amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;exp
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;我们可以定义一些语义规则：&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;agda&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-agda &quot;&gt;&lt;code class=&quot;language-agda&quot; data-lang=&quot;agda&quot;&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;add &lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;Nat &lt;&#x2F;span&gt;&lt;span&gt;-&amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;Nat &lt;&#x2F;span&gt;&lt;span&gt;-&amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;Nat
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;add n zero    &lt;&#x2F;span&gt;&lt;span&gt;= &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;n
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;add n&lt;&#x2F;span&gt;&lt;span&gt; (&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;suc m&lt;&#x2F;span&gt;&lt;span&gt;) = &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;suc&lt;&#x2F;span&gt;&lt;span&gt; (&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;add n m&lt;&#x2F;span&gt;&lt;span&gt;)
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;data &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;_&lt;&#x2F;span&gt;&lt;span&gt;=&amp;gt;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;_ &lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;exp &lt;&#x2F;span&gt;&lt;span&gt;-&amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;exp &lt;&#x2F;span&gt;&lt;span&gt;-&amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;Set where
&lt;&#x2F;span&gt;&lt;span&gt;    =&amp;gt;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;A &lt;&#x2F;span&gt;&lt;span&gt;: {&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;n0 n1 &lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;Nat&lt;&#x2F;span&gt;&lt;span&gt;} -&amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;Add&lt;&#x2F;span&gt;&lt;span&gt; (&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;Const &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;n0&lt;&#x2F;span&gt;&lt;span&gt;) (&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;Const &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;n1&lt;&#x2F;span&gt;&lt;span&gt;) =&amp;gt;  &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;Const&lt;&#x2F;span&gt;&lt;span&gt; (&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;add n0 n1&lt;&#x2F;span&gt;&lt;span&gt;)
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;    =&amp;gt;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;L &lt;&#x2F;span&gt;&lt;span&gt;: {&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;e e&amp;#39; e1 &lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;exp&lt;&#x2F;span&gt;&lt;span&gt;} -&amp;gt;
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;e &lt;&#x2F;span&gt;&lt;span&gt;=&amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;e&amp;#39;
&lt;&#x2F;span&gt;&lt;span&gt;    -&amp;gt;  &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;Add &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;e e1 &lt;&#x2F;span&gt;&lt;span&gt;=&amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;Add &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;e&amp;#39; e1
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;    =&amp;gt;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;R &lt;&#x2F;span&gt;&lt;span&gt;: {&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;n &lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;Nat&lt;&#x2F;span&gt;&lt;span&gt;} -&amp;gt; {&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;e e&amp;#39; &lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;exp&lt;&#x2F;span&gt;&lt;span&gt;} -&amp;gt;
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;e &lt;&#x2F;span&gt;&lt;span&gt;=&amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;e&amp;#39;
&lt;&#x2F;span&gt;&lt;span&gt;    -&amp;gt;  &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;Add&lt;&#x2F;span&gt;&lt;span&gt; (&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;Const &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;n&lt;&#x2F;span&gt;&lt;span&gt;) &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;e &lt;&#x2F;span&gt;&lt;span&gt;=&amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;Add&lt;&#x2F;span&gt;&lt;span&gt; (&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;Const &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;n&lt;&#x2F;span&gt;&lt;span&gt;) &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;e&amp;#39;
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;这里的 &lt;code&gt;=&amp;gt;&lt;&#x2F;code&gt; 指是“左边的表达式可以（一步）转化为右边的表达式”。&lt;&#x2F;p&gt;
&lt;p&gt;这些规则就构成了一个可以用数理逻辑证明程序的各种性质的证明系统。&lt;&#x2F;p&gt;
&lt;p&gt;比如我们可以证明一个符合这个语法的数学表达式一定是 &amp;quot;progress&amp;quot;&lt;sup class=&quot;footnote-reference&quot;&gt;&lt;a href=&quot;#2&quot;&gt;2&lt;&#x2F;a&gt;&lt;&#x2F;sup&gt; 的：&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;agda&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-agda &quot;&gt;&lt;code class=&quot;language-agda&quot; data-lang=&quot;agda&quot;&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;makes&lt;&#x2F;span&gt;&lt;span&gt;-&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;progress&lt;&#x2F;span&gt;&lt;span&gt;-&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;add &lt;&#x2F;span&gt;&lt;span&gt;: {&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;e0 e1 &lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;exp&lt;&#x2F;span&gt;&lt;span&gt;} -&amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;makes&lt;&#x2F;span&gt;&lt;span&gt;-&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;progress e0 &lt;&#x2F;span&gt;&lt;span&gt;-&amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;makes&lt;&#x2F;span&gt;&lt;span&gt;-&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;progress e1 &lt;&#x2F;span&gt;&lt;span&gt;-&amp;gt;
&lt;&#x2F;span&gt;&lt;span&gt;                                   &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;makes&lt;&#x2F;span&gt;&lt;span&gt;-&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;progress&lt;&#x2F;span&gt;&lt;span&gt; (&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;Add &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;e0 e1&lt;&#x2F;span&gt;&lt;span&gt;)
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;makes&lt;&#x2F;span&gt;&lt;span&gt;-&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;progress&lt;&#x2F;span&gt;&lt;span&gt;-&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;add isValue isValue &lt;&#x2F;span&gt;&lt;span&gt;= &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;hasReduction &lt;&#x2F;span&gt;&lt;span&gt;=&amp;gt;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;A
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;makes&lt;&#x2F;span&gt;&lt;span&gt;-&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;progress&lt;&#x2F;span&gt;&lt;span&gt;-&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;add isValue&lt;&#x2F;span&gt;&lt;span&gt; (&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;hasReduction x&lt;&#x2F;span&gt;&lt;span&gt;) = &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;hasReduction&lt;&#x2F;span&gt;&lt;span&gt; (=&amp;gt;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;R &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;x&lt;&#x2F;span&gt;&lt;span&gt;)
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;makes&lt;&#x2F;span&gt;&lt;span&gt;-&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;progress&lt;&#x2F;span&gt;&lt;span&gt;-&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;add&lt;&#x2F;span&gt;&lt;span&gt; (&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;hasReduction x&lt;&#x2F;span&gt;&lt;span&gt;) &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;progress1 &lt;&#x2F;span&gt;&lt;span&gt;= &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;hasReduction&lt;&#x2F;span&gt;&lt;span&gt; (=&amp;gt;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;L &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;x&lt;&#x2F;span&gt;&lt;span&gt;)
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;exp&lt;&#x2F;span&gt;&lt;span&gt;-&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;makes&lt;&#x2F;span&gt;&lt;span&gt;-&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;progress &lt;&#x2F;span&gt;&lt;span&gt;: (&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;e &lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;exp&lt;&#x2F;span&gt;&lt;span&gt;) -&amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;makes&lt;&#x2F;span&gt;&lt;span&gt;-&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;progress e
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;exp&lt;&#x2F;span&gt;&lt;span&gt;-&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;makes&lt;&#x2F;span&gt;&lt;span&gt;-&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;progress&lt;&#x2F;span&gt;&lt;span&gt; (&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;Const &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;x&lt;&#x2F;span&gt;&lt;span&gt;) = &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;isValue
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;exp&lt;&#x2F;span&gt;&lt;span&gt;-&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;makes&lt;&#x2F;span&gt;&lt;span&gt;-&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;progress&lt;&#x2F;span&gt;&lt;span&gt; (&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;Add &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;e1 e2&lt;&#x2F;span&gt;&lt;span&gt;) = &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;makes&lt;&#x2F;span&gt;&lt;span&gt;-&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;progress&lt;&#x2F;span&gt;&lt;span&gt;-&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;add&lt;&#x2F;span&gt;&lt;span&gt; (&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;exp&lt;&#x2F;span&gt;&lt;span&gt;-&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;makes&lt;&#x2F;span&gt;&lt;span&gt;-&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;progress e1&lt;&#x2F;span&gt;&lt;span&gt;) (&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;exp&lt;&#x2F;span&gt;&lt;span&gt;-&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;makes&lt;&#x2F;span&gt;&lt;span&gt;-&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;progress e2&lt;&#x2F;span&gt;&lt;span&gt;) 
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;如果我们无法根据这些语义规则进一步 reduce 某个表达式，这个表达式就称之为“范式”（normal form）。&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;agda&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-agda &quot;&gt;&lt;code class=&quot;language-agda&quot; data-lang=&quot;agda&quot;&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;data &lt;&#x2F;span&gt;&lt;span&gt;⊥ : &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;Set where
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;elim&lt;&#x2F;span&gt;&lt;span&gt;-⊥ : {&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;A &lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;Set&lt;&#x2F;span&gt;&lt;span&gt;} -&amp;gt; ⊥ -&amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;A
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;elim&lt;&#x2F;span&gt;&lt;span&gt;-⊥ {&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;A&lt;&#x2F;span&gt;&lt;span&gt;} ()
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;¬ : &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;Set &lt;&#x2F;span&gt;&lt;span&gt;-&amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;Set
&lt;&#x2F;span&gt;&lt;span&gt;¬ &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;A &lt;&#x2F;span&gt;&lt;span&gt;= &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;A &lt;&#x2F;span&gt;&lt;span&gt;-&amp;gt; ⊥
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;cannot&lt;&#x2F;span&gt;&lt;span&gt;-&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;reduce&lt;&#x2F;span&gt;&lt;span&gt;-&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;further &lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;exp &lt;&#x2F;span&gt;&lt;span&gt;-&amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;Set
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;cannot&lt;&#x2F;span&gt;&lt;span&gt;-&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;reduce&lt;&#x2F;span&gt;&lt;span&gt;-&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;further e &lt;&#x2F;span&gt;&lt;span&gt;= {&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;e&amp;#39; &lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;exp&lt;&#x2F;span&gt;&lt;span&gt;} -&amp;gt; ¬ (&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;e &lt;&#x2F;span&gt;&lt;span&gt;=&amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;e&amp;#39;&lt;&#x2F;span&gt;&lt;span&gt;)
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;我们可以证明，在这个系统中范式一定是一个值：&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;agda&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-agda &quot;&gt;&lt;code class=&quot;language-agda&quot; data-lang=&quot;agda&quot;&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;data &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;is&lt;&#x2F;span&gt;&lt;span&gt;-&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;value &lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;exp &lt;&#x2F;span&gt;&lt;span&gt;-&amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;Set where
&lt;&#x2F;span&gt;&lt;span&gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;ConstIsVal &lt;&#x2F;span&gt;&lt;span&gt;: {&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;n &lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;Nat&lt;&#x2F;span&gt;&lt;span&gt;} -&amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;is&lt;&#x2F;span&gt;&lt;span&gt;-&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;value&lt;&#x2F;span&gt;&lt;span&gt; (&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;Const &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;n&lt;&#x2F;span&gt;&lt;span&gt;)
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;norm&lt;&#x2F;span&gt;&lt;span&gt;-&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;form&lt;&#x2F;span&gt;&lt;span&gt;-&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;is&lt;&#x2F;span&gt;&lt;span&gt;-&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;value &lt;&#x2F;span&gt;&lt;span&gt;: {&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;e &lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;exp&lt;&#x2F;span&gt;&lt;span&gt;} -&amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;cannot&lt;&#x2F;span&gt;&lt;span&gt;-&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;reduce&lt;&#x2F;span&gt;&lt;span&gt;-&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;further e &lt;&#x2F;span&gt;&lt;span&gt;-&amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;is&lt;&#x2F;span&gt;&lt;span&gt;-&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;value e
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;norm&lt;&#x2F;span&gt;&lt;span&gt;-&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;form&lt;&#x2F;span&gt;&lt;span&gt;-&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;is&lt;&#x2F;span&gt;&lt;span&gt;-&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;value &lt;&#x2F;span&gt;&lt;span&gt;{&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;e&lt;&#x2F;span&gt;&lt;span&gt;} = &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;lemma&lt;&#x2F;span&gt;&lt;span&gt; (&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;exp&lt;&#x2F;span&gt;&lt;span&gt;-&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;makes&lt;&#x2F;span&gt;&lt;span&gt;-&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;progress e&lt;&#x2F;span&gt;&lt;span&gt;)
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;where &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;lemma &lt;&#x2F;span&gt;&lt;span&gt;: {&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;e &lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;exp&lt;&#x2F;span&gt;&lt;span&gt;} -&amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;makes&lt;&#x2F;span&gt;&lt;span&gt;-&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;progress e &lt;&#x2F;span&gt;&lt;span&gt;-&amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;cannot&lt;&#x2F;span&gt;&lt;span&gt;-&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;reduce&lt;&#x2F;span&gt;&lt;span&gt;-&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;further e &lt;&#x2F;span&gt;&lt;span&gt;-&amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;is&lt;&#x2F;span&gt;&lt;span&gt;-&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;value e
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;lemma isValue cannotReduceEFurther &lt;&#x2F;span&gt;&lt;span&gt;= &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;ConstIsVal
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;lemma&lt;&#x2F;span&gt;&lt;span&gt; (&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;hasReduction eToe&amp;#39;&lt;&#x2F;span&gt;&lt;span&gt;) &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;cannotReduceEFurther &lt;&#x2F;span&gt;&lt;span&gt;= &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;elim&lt;&#x2F;span&gt;&lt;span&gt;-⊥ (&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;cannotReduceEFurther eToe&amp;#39;&lt;&#x2F;span&gt;&lt;span&gt;) &lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;-- absurd
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;h3 id=&quot;xiao-bu-yu-yi-he-da-bu-yu-yi&quot;&gt;小步语义和大步语义&lt;&#x2F;h3&gt;
&lt;p&gt;上面的例子是小步语义，它是一步一步地描述程序的执行过程。&lt;&#x2F;p&gt;
&lt;p&gt;而大步语义定义如何从一个表达式或者语句直接得到它的结果。&lt;&#x2F;p&gt;
&lt;p&gt;例如上面的小步语义对应的大步语义可以是：&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;agda&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-agda &quot;&gt;&lt;code class=&quot;language-agda&quot; data-lang=&quot;agda&quot;&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;data &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;_&lt;&#x2F;span&gt;&lt;span&gt;⇓&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;_ &lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;exp &lt;&#x2F;span&gt;&lt;span&gt;-&amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;exp &lt;&#x2F;span&gt;&lt;span&gt;-&amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;Set where
&lt;&#x2F;span&gt;&lt;span&gt;    ⇓&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;suc &lt;&#x2F;span&gt;&lt;span&gt;: {&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;e v &lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;exp&lt;&#x2F;span&gt;&lt;span&gt;} -&amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;e &lt;&#x2F;span&gt;&lt;span&gt;⇓ &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;v &lt;&#x2F;span&gt;&lt;span&gt;-&amp;gt;
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;suc e  &lt;&#x2F;span&gt;&lt;span&gt;⇓ &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;suc v 
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;    ⇓&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;prd0 &lt;&#x2F;span&gt;&lt;span&gt;: {&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;e &lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;exp&lt;&#x2F;span&gt;&lt;span&gt;} -&amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;e &lt;&#x2F;span&gt;&lt;span&gt;⇓ &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;zero &lt;&#x2F;span&gt;&lt;span&gt;-&amp;gt;
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;prd e &lt;&#x2F;span&gt;&lt;span&gt;⇓ &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;zero
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;    ⇓&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;prdS &lt;&#x2F;span&gt;&lt;span&gt;: {&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;e v &lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;exp&lt;&#x2F;span&gt;&lt;span&gt;} -&amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;e &lt;&#x2F;span&gt;&lt;span&gt;⇓ &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;suc v &lt;&#x2F;span&gt;&lt;span&gt;-&amp;gt;
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;prd&lt;&#x2F;span&gt;&lt;span&gt; (&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;suc e&lt;&#x2F;span&gt;&lt;span&gt;) ⇓ &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;v
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;v0 &lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;zero &lt;&#x2F;span&gt;&lt;span&gt;⇓ &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;zero
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;小步语义相当于为程序实现了一种迭代式的解释器，而大步语义则相当于为程序实现了一种递归式的解释器。&lt;&#x2F;p&gt;
&lt;div class=&quot;footnote-definition&quot; id=&quot;1&quot;&gt;&lt;sup class=&quot;footnote-definition-label&quot;&gt;1&lt;&#x2F;sup&gt;
&lt;p&gt;$v$ 是这个语言中的一个值。&lt;&#x2F;p&gt;
&lt;&#x2F;div&gt;
&lt;div class=&quot;footnote-definition&quot; id=&quot;2&quot;&gt;&lt;sup class=&quot;footnote-definition-label&quot;&gt;2&lt;&#x2F;sup&gt;
&lt;p&gt;progress 的意思是“某个表达式 $e$ 要么是一个值，要么存在 $e&#x27;$，使得 $e ⇒ e&#x27;$”，可以参考下面 agda 代码中 &lt;code&gt;makes-progress&lt;&#x2F;code&gt; 的定义。&lt;&#x2F;p&gt;
&lt;&#x2F;div&gt;
</content>
        
    </entry>
    <entry xml:lang="zh">
        <title>重新开始学数学 • 贝叶斯因果推理（1）</title>
        <published>2023-09-05T12:40:19+00:00</published>
        <updated>2023-09-05T12:40:19+00:00</updated>
        <author>
          <name>Unknown</name>
        </author>
        <link rel="alternate" href="https://longfangsong.github.io/restart-math-stastic-bayesian-1/" type="text/html"/>
        <id>https://longfangsong.github.io/restart-math-stastic-bayesian-1/</id>
        
        <content type="html">&lt;h2 id=&quot;fu-hao-biao&quot;&gt;符号表&lt;&#x2F;h2&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;符号&lt;&#x2F;th&gt;&lt;th&gt;中文&lt;&#x2F;th&gt;&lt;th&gt;English&lt;&#x2F;th&gt;&lt;th&gt;例子&lt;&#x2F;th&gt;&lt;&#x2F;tr&gt;&lt;&#x2F;thead&gt;&lt;tbody&gt;
&lt;tr&gt;&lt;td&gt;$A ∼ B$&lt;&#x2F;td&gt;&lt;td&gt;A&lt;sup class=&quot;footnote-reference&quot;&gt;&lt;a href=&quot;#1&quot;&gt;1&lt;&#x2F;a&gt;&lt;&#x2F;sup&gt; 服从 B 分布&lt;&#x2F;td&gt;&lt;td&gt;A is subject to distribution B&lt;&#x2F;td&gt;&lt;td&gt;$W ∼ Binomial(N, p)$&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;$Pr(E_A)$&lt;&#x2F;td&gt;&lt;td&gt;事件 $E_A$ 的概率分布&lt;&#x2F;td&gt;&lt;td&gt;probability of $E_A$&lt;&#x2F;td&gt;&lt;td&gt;&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;$Pr(E_A, E_B)$&lt;sup class=&quot;footnote-reference&quot;&gt;&lt;a href=&quot;#2&quot;&gt;2&lt;&#x2F;a&gt;&lt;&#x2F;sup&gt;&lt;&#x2F;td&gt;&lt;td&gt;事件 $E_A$ 和 $E_B$ 的联合概率分布（$E_A$ 且 $E_B$ 的概率分布）&lt;&#x2F;td&gt;&lt;td&gt;joint probability distribution of $E_A$ and $E_B$&lt;&#x2F;td&gt;&lt;td&gt;&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;$Pr(E_A|E_B)$&lt;sup class=&quot;footnote-reference&quot;&gt;&lt;a href=&quot;#2&quot;&gt;2&lt;&#x2F;a&gt;&lt;&#x2F;sup&gt;&lt;&#x2F;td&gt;&lt;td&gt;确定事件 $E_B$ 发生时 $E_A$ 发生的概率&lt;&#x2F;td&gt;&lt;td&gt;“the conditional probability of $E_A$ given $E_B$” or “the probability of $E_A$ under the condition $E_B$”&lt;&#x2F;td&gt;&lt;td&gt;&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;$E_A \mathrel{\rlap{\perp}\mkern1mu\perp} E_B$&lt;sup class=&quot;footnote-reference&quot;&gt;&lt;a href=&quot;#3&quot;&gt;3&lt;&#x2F;a&gt;&lt;&#x2F;sup&gt;&lt;&#x2F;td&gt;&lt;td&gt;$E_A$ 和 $E_B$ 无关&lt;&#x2F;td&gt;&lt;td&gt;$E_A$ is independent of $E_B$&lt;&#x2F;td&gt;&lt;td&gt;&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;$E_A {\llap{\not}}{\mathrel{\rlap{\perp}\mkern1mu\perp}} E_B$&lt;&#x2F;td&gt;&lt;td&gt;$E_A$ 和 $E_B$ 有关&lt;&#x2F;td&gt;&lt;td&gt;$E_A$ is not independent of $E_B$&lt;&#x2F;td&gt;&lt;td&gt;&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;&#x2F;tbody&gt;&lt;&#x2F;table&gt;
&lt;h2 id=&quot;ming-ci-jie-shi&quot;&gt;名词解释&lt;&#x2F;h2&gt;
&lt;h3 id=&quot;xian-yan-gai-lu-prior-probability&quot;&gt;先验概率&#x2F;Prior (probability)&lt;&#x2F;h3&gt;
&lt;blockquote&gt;
&lt;p&gt;在贝叶斯统计中，某一不确定量p的先验概率（Prior probability）分布是在考虑「观测数据」前，能表达p不确定性的概率分布。&lt;&#x2F;p&gt;
&lt;&#x2F;blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;A prior probability distribution of an uncertain quantity, often simply called the prior, is its assumed probability distribution before some evidence is taken into account. —— Wikipedia&lt;&#x2F;p&gt;
&lt;&#x2F;blockquote&gt;
&lt;p&gt;简单来说就是在考虑观测数据前，对不确定量的概率分布的一个猜测。&lt;&#x2F;p&gt;
&lt;h3 id=&quot;si-ran-han-shu-likelihood-function&quot;&gt;似然函数&#x2F;Likelihood function&lt;&#x2F;h3&gt;
&lt;blockquote&gt;
&lt;p&gt;似然函数（英語：likelihood function）是一种关于统计模型中的参数的函数，表示模型参数中的似然性（英語：likelihood）&lt;&#x2F;p&gt;
&lt;&#x2F;blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;The likelihood function (often simply called the likelihood) is the joint probability (or probability density) of observed data viewed as a function of the parameters of a statistical model.&lt;&#x2F;p&gt;
&lt;&#x2F;blockquote&gt;
&lt;p&gt;简单来说就是要求不确定量服从的概率分布函数。&lt;&#x2F;p&gt;
&lt;h3 id=&quot;hou-yan-gai-lu-posterior-probability&quot;&gt;后验概率&#x2F;Posterior (probability)&lt;&#x2F;h3&gt;
&lt;blockquote&gt;
&lt;p&gt;在贝叶斯统计中，一个随机事件或者一个不确定事件的后验概率（Posterior probability）是在考虑和给出相关证据或数据后所得到的条件概率。&lt;&#x2F;p&gt;
&lt;&#x2F;blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;The posterior probability is a type of conditional probability that results from updating the prior probability with information summarized by the likelihood via an application of Bayes&#x27; rule.&lt;&#x2F;p&gt;
&lt;&#x2F;blockquote&gt;
&lt;p&gt;简单来说就是在考虑观测数据后，不确定量的概率分布。&lt;&#x2F;p&gt;
&lt;h3 id=&quot;berkson-s-paradox-selection-distortion-effect&quot;&gt;Berkson’s paradox &#x2F; selection-distortion effect&lt;&#x2F;h3&gt;
&lt;blockquote&gt;
&lt;p&gt;(Berkson’s paradox) is a result in conditional probability and statistics which is often found to be counterintuitive, and hence a veridical paradox.&lt;&#x2F;p&gt;
&lt;&#x2F;blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;是指人们的直觉观察与实际上真实的条件概率和严谨的统计结果不相符，也就是说人们所发现的看似两个相关的因素实际上根本无关。&lt;&#x2F;p&gt;
&lt;&#x2F;blockquote&gt;
&lt;h3 id=&quot;duo-zhong-gong-xian-xing-multicollinearity&quot;&gt;多重共线性&#x2F;Multicollinearity&lt;&#x2F;h3&gt;
&lt;blockquote&gt;
&lt;p&gt;Multicollinearity means very strong correlation between two or more predictor variables.&lt;&#x2F;p&gt;
&lt;&#x2F;blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;In statistics, multicollinearity (also collinearity) is a phenomenon in which one predictor variable in a multiple regression model can be perfectly predicted from the others.&lt;&#x2F;p&gt;
&lt;&#x2F;blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;多重共线性（Multicollinearity）是指多变量线性回归中，变量之间由于存在高度相关关系而使回归估计不准确。在该情况下，多元回归的系数可能会因为模型或数据的微小变化发生剧烈改变。&lt;&#x2F;p&gt;
&lt;&#x2F;blockquote&gt;
&lt;p&gt;Will produce false inferences about causal effects.&lt;&#x2F;p&gt;
&lt;h3 id=&quot;kullback-leible-san-du&quot;&gt;Kullback-Leible 散度&lt;&#x2F;h3&gt;
&lt;blockquote&gt;
&lt;p&gt;The additional uncertainty induced by using probabilities from one distribution to describe another distribution.&lt;&#x2F;p&gt;
&lt;&#x2F;blockquote&gt;
&lt;p&gt;即一个概率分布相对于另一个概率分布的差异程度。&lt;&#x2F;p&gt;
&lt;p&gt;We can quantify distance to the target using Kullback-Leibler divergence.&lt;&#x2F;p&gt;
&lt;h3 id=&quot;log-pointwise-predictive-density&quot;&gt;log-pointwise-predictive-density&lt;&#x2F;h3&gt;
&lt;blockquote&gt;
&lt;p&gt;the log of the average probability for each observation i, where the average is taken over the posterior distribution&lt;&#x2F;p&gt;
&lt;&#x2F;blockquote&gt;
&lt;h3 id=&quot;zui-da-shang-fen-bu&quot;&gt;最大熵分布&lt;&#x2F;h3&gt;
&lt;blockquote&gt;
&lt;p&gt;a maximum entropy probability distribution has entropy that is at least as great as that of all other members of a specified class of probability distributions&lt;&#x2F;p&gt;
&lt;&#x2F;blockquote&gt;
&lt;h3 id=&quot;divergent-transitions&quot;&gt;divergent transitions&lt;&#x2F;h3&gt;
&lt;blockquote&gt;
&lt;p&gt;when the posterior distribution is very steep in some region of parameter space. Steep changes in probability are hard for a discrete physics simulation to follow. When that happens, the algorithm notices by comparing the energy at the start to the energy at the end.&lt;&#x2F;p&gt;
&lt;&#x2F;blockquote&gt;
&lt;p&gt;解决方式包括修改 MCMC 的接受率（&lt;code&gt;adapt_delta&lt;&#x2F;code&gt;）、reparameterize、用更好的 prior 等。&lt;&#x2F;p&gt;
&lt;h3 id=&quot;interactions&quot;&gt;Interactions&lt;&#x2F;h3&gt;
&lt;blockquote&gt;
&lt;p&gt;One variable may depend upon another. For example, plants benefit from both light and water. But in the absence of either, the other is no benefit at all.&lt;&#x2F;p&gt;
&lt;&#x2F;blockquote&gt;
&lt;h3 id=&quot;over-dispersion&quot;&gt;over-dispersion&lt;&#x2F;h3&gt;
&lt;p&gt;Variance of a variable is larger than what would be expected from a given statistical model.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;chang-yong-fen-bu&quot;&gt;常用分布&lt;&#x2F;h2&gt;
&lt;h3 id=&quot;jun-yun-fen-bu-uniform-distribution&quot;&gt;均匀分布 &#x2F; Uniform distribution&lt;&#x2F;h3&gt;
&lt;p&gt;$$
Uniform(a, b)
$$&lt;&#x2F;p&gt;
&lt;p&gt;即等可能地选取 $[a, b]$ 之间的任何一个数所得到的概率分布。&lt;&#x2F;p&gt;
&lt;h3 id=&quot;bo-nu-li-fen-bu-bernoulli-distribution&quot;&gt;伯努利分布 &#x2F; Bernoulli distribution&lt;&#x2F;h3&gt;
&lt;p&gt;$$
Bernoulli(p)
$$&lt;&#x2F;p&gt;
&lt;p&gt;做试验得到“成功”结果的概率为 $p$，那么做一次实验结果为“成功”的概率分布。&lt;&#x2F;p&gt;
&lt;h3 id=&quot;categorical-fen-bu&quot;&gt;Categorical 分布&lt;&#x2F;h3&gt;
&lt;p&gt;$$
Categorical(\textbf{p})
$$&lt;&#x2F;p&gt;
&lt;p&gt;做试验得到第 i 种结果的概率为 $\textbf{p}_i$，那么做一次实验结果为第 i 种的概率分布。&lt;&#x2F;p&gt;
&lt;h3 id=&quot;er-xiang-fen-bu-binomial-distribution&quot;&gt;二项分布 &#x2F; Binomial distribution&lt;&#x2F;h3&gt;
&lt;p&gt;$$
Binomial(N, p)
$$&lt;&#x2F;p&gt;
&lt;p&gt;每次试验得到“成功”结果的概率为 $p$，做 $N$ 次试验，得到“成功”次数的概率分布。&lt;&#x2F;p&gt;
&lt;p&gt;$N$ 为 1 时，退化为伯努利分布。&lt;&#x2F;p&gt;
&lt;p&gt;$N$ 很大而 $p$ 很小时，逼近泊松分布。&lt;&#x2F;p&gt;
&lt;p&gt;$N$ 很大而 $p$ 接近 0.5 时近似于正态分布。&lt;&#x2F;p&gt;
&lt;h3 id=&quot;duo-xiang-fen-bu-multinomial-distribution&quot;&gt;多项分布 &#x2F; Multinomial distribution&lt;&#x2F;h3&gt;
&lt;p&gt;$$
Multinomial(N, \textbf{p})
$$&lt;&#x2F;p&gt;
&lt;p&gt;每次试验得到第 i 种结果的概率为 $\textbf{p}_i$，做 $N$ 次试验，得到某个值的次数的概率分布。&lt;&#x2F;p&gt;
&lt;h3 id=&quot;beta-fen-bu-beta-distribution&quot;&gt;$\beta$ 分布 &#x2F; Beta distribution&lt;&#x2F;h3&gt;
&lt;p&gt;$$
Beta(a, b)
$$&lt;&#x2F;p&gt;
&lt;p&gt;做 $a + b$ 次实验，发现其中 a 次成功，b 次失败则实验本身的成功率 $p$ 的概率分布。&lt;sup class=&quot;footnote-reference&quot;&gt;&lt;a href=&quot;#4&quot;&gt;4&lt;&#x2F;a&gt;&lt;&#x2F;sup&gt;&lt;&#x2F;p&gt;
&lt;h3 id=&quot;dirichlet-fen-bu-multivariate-beta-distribution&quot;&gt;Dirichlet 分布 &#x2F; Multivariate beta distribution&lt;&#x2F;h3&gt;
&lt;p&gt;$$
Dir(\textbf{a})
$$&lt;&#x2F;p&gt;
&lt;p&gt;$\beta$ 分布的多变量扩展，做 $\Sigma \textbf{a}$ 次实验，其中第 $i$ 种结果出现 $\textbf{a}_i$ 次，$Dir(\textbf{a})$ 描述了其中每个结果的出现率。&lt;&#x2F;p&gt;
&lt;h3 id=&quot;zhi-shu-fen-bu-exponential-distribution&quot;&gt;指数分布 &#x2F; Exponential distribution&lt;&#x2F;h3&gt;
&lt;p&gt;$$
Exp(λ)
$$&lt;&#x2F;p&gt;
&lt;p&gt;每单位时间发生某事件 $\lambda$ 次，则 $Exp(λ)$ 代表每次发生的时间间隔的概率分布。&lt;&#x2F;p&gt;
&lt;h3 id=&quot;bo-song-fen-bu-poisson-distribution&quot;&gt;泊松分布 &#x2F; Poisson distribution&lt;&#x2F;h3&gt;
&lt;p&gt;$$
Poisson(λ)
$$&lt;&#x2F;p&gt;
&lt;p&gt;随机事件发生次数的数学期望值和方差均为 $\lambda$，则 $Poisson(λ)$ 为单位时间内随机事件发生的次数的概率分布。&lt;&#x2F;p&gt;
&lt;p&gt;服从泊松分布的随机变量，其数学期望与方差相等，均为 $\lambda$。&lt;&#x2F;p&gt;
&lt;p&gt;取样样本数很大时将近似正态分布。&lt;&#x2F;p&gt;
&lt;h3 id=&quot;jia-ma-fen-bu-gamma-distribution&quot;&gt;伽玛分布 &#x2F; Gamma distribution&lt;&#x2F;h3&gt;
&lt;p&gt;$$
Gamma(a, \lambda)
$$&lt;&#x2F;p&gt;
&lt;p&gt;发生 a 次独立的随机事件，每单位时间发生某事件 $\lambda$ 次，则 $Gamma(a, \lambda)$ 代表这 a 次事件发生总共所用时间的分布。&lt;&#x2F;p&gt;
&lt;p&gt;a 为 1 时，退化为指数分布。&lt;&#x2F;p&gt;
&lt;h3 id=&quot;ji-he-fen-bu-geometric-distribution&quot;&gt;几何分布 &#x2F; Geometric distribution&lt;&#x2F;h3&gt;
&lt;p&gt;$$
G(p)
$$&lt;&#x2F;p&gt;
&lt;p&gt;即不停做实验直到成功为止，做实验的次数的概率分布。&lt;&#x2F;p&gt;
&lt;h3 id=&quot;fu-er-xiang-fen-bu-negative-binomial-distribution&quot;&gt;负二项分布 &#x2F; Negative binomial distribution&lt;&#x2F;h3&gt;
&lt;p&gt;$$
NB(r, p)
$$&lt;&#x2F;p&gt;
&lt;p&gt;即不停做实验直到第 r 次成功为止，做实验的次数的概率分布。&lt;&#x2F;p&gt;
&lt;p&gt;r 为 1 时，退化为几何分布。&lt;&#x2F;p&gt;
&lt;p&gt;负二项分布可以看作是 Gamma 分布和 Poisson 分布的组合。&lt;&#x2F;p&gt;
&lt;p&gt;$$
GammaPoisson(\lambda, \Phi)
$$&lt;&#x2F;p&gt;
&lt;p&gt;其中：&lt;&#x2F;p&gt;
&lt;p&gt;$$
r = \frac \lambda \Phi
$$&lt;&#x2F;p&gt;
&lt;p&gt;$$
p = \frac 1 {1 + \Phi}
$$&lt;&#x2F;p&gt;
&lt;h3 id=&quot;zheng-tai-fen-bu-normal-distribution&quot;&gt;正态分布 &#x2F; Normal distribution&lt;&#x2F;h3&gt;
&lt;p&gt;$$
N(\mu, \sigma^2)
$$&lt;&#x2F;p&gt;
&lt;p&gt;假设一个实验可能有几种等可能的不同的结果，以多个（越多越好）这样的实验为一组，大量做这样的实验，每组实验的结果之和服从正态分布。&lt;&#x2F;p&gt;
&lt;h3 id=&quot;beta-binomial-fen-bu&quot;&gt;$\beta$-binomial 分布&lt;&#x2F;h3&gt;
&lt;p&gt;$$
BetaBinomial(N, a, b)
$$&lt;&#x2F;p&gt;
&lt;p&gt;是 Beta 和 Binomial 组合的结果，当 $p$ 服从 $Beta(a, b)$ 时，$Binomial(N, p)$ 的分布。&lt;&#x2F;p&gt;
&lt;p&gt;即每次试验得到“成功”结果的概率符合 $Beta(a, b)$，做 $N$ 次试验，得到“成功”次数的概率分布。&lt;&#x2F;p&gt;
&lt;h2 id=&quot;bayes-theorem&quot;&gt;Bayes’ theorem&lt;&#x2F;h2&gt;
&lt;p&gt;$$
后验概率 = normalize(似然函数 \times 先验概率)
$$&lt;&#x2F;p&gt;
&lt;p&gt;或者用符号写：&lt;&#x2F;p&gt;
&lt;p&gt;$$
Pr(p|W) = \frac {Pr(W|p)Pr(p)} {Pr(W)}
$$&lt;&#x2F;p&gt;
&lt;h2 id=&quot;bei-xie-si-shu-ju-fen-xi-de-bu-zou&quot;&gt;贝叶斯数据分析的步骤&lt;&#x2F;h2&gt;
&lt;p&gt;&lt;img src=&quot;https:&#x2F;&#x2F;longfangsong.github.io&#x2F;restart-math-stastic-bayesian-1&#x2F;workflow.png&quot; alt=&quot;Alt text&quot; &#x2F;&gt;&lt;&#x2F;p&gt;
&lt;div class=&quot;footnote-definition&quot; id=&quot;1&quot;&gt;&lt;sup class=&quot;footnote-definition-label&quot;&gt;1&lt;&#x2F;sup&gt;
&lt;p&gt;本文严格区分事件（写作 $E_{大写英文字母}$）和变量（用普通大写英文字母表示），例如 $E_A$ 可能代表事件 $X=1$，同时可以给他分配变量 $A$，因此 $Pr(E_A) \equiv Pr\{X=1\} \equiv Pr(A)$。&lt;&#x2F;p&gt;
&lt;&#x2F;div&gt;
&lt;div class=&quot;footnote-definition&quot; id=&quot;2&quot;&gt;&lt;sup class=&quot;footnote-definition-label&quot;&gt;2&lt;&#x2F;sup&gt;
&lt;p&gt;$,$ 的优先级高于 $|$，例如 $Pr(p|W,L)$ 是 $Pr(p|(W,L))$。&lt;&#x2F;p&gt;
&lt;&#x2F;div&gt;
&lt;div class=&quot;footnote-definition&quot; id=&quot;3&quot;&gt;&lt;sup class=&quot;footnote-definition-label&quot;&gt;3&lt;&#x2F;sup&gt;
&lt;p&gt;$Y \mathrel{\rlap{\perp}\mkern1mu\perp} X | Z$ 的意义是：除去 $Z$ 的影响后（显示出） $Y$ 与 $X$ 无关，这是一个 conditional independency 的例子。&lt;&#x2F;p&gt;
&lt;&#x2F;div&gt;
&lt;div class=&quot;footnote-definition&quot; id=&quot;4&quot;&gt;&lt;sup class=&quot;footnote-definition-label&quot;&gt;4&lt;&#x2F;sup&gt;
&lt;p&gt;成功率并不一定是 $\frac a {(a+b)}$！$\frac a {(a+b)}$ 只是得到的分布中密度最大的点！&lt;&#x2F;p&gt;
&lt;&#x2F;div&gt;
</content>
        
    </entry>
    <entry xml:lang="zh">
        <title>Image 转 RGB565 工具</title>
        <published>2023-03-03T16:58:21.033+00:00</published>
        <updated>2023-03-03T16:58:21.033+00:00</updated>
        <author>
          <name>Unknown</name>
        </author>
        <link rel="alternate" href="https://longfangsong.github.io/image-to-rgb565/" type="text/html"/>
        <id>https://longfangsong.github.io/image-to-rgb565/</id>
        
        <content type="html">&lt;h1 id=&quot;just-use-it&quot;&gt;Just use it&lt;&#x2F;h1&gt;
&lt;input type=&quot;file&quot; id=&quot;imageInput&quot;&gt;
&lt;h1 id=&quot;why&quot;&gt;Why&lt;&#x2F;h1&gt;
&lt;p&gt;RGB565 格式在 embedded systems 中非常有用，可以直接喂给大部分 lcd 屏幕吃。&lt;&#x2F;p&gt;
&lt;h1 id=&quot;how&quot;&gt;How&lt;&#x2F;h1&gt;
&lt;p&gt;Basically，先用 &lt;code&gt;canvas&lt;&#x2F;code&gt; 得到每个 pixel 的 RGBA，然后直接位操作。&lt;&#x2F;p&gt;
&lt;p&gt;部分代码由 new Bing 的 AI 提供，但我还是做了些修改才达到效果。&lt;&#x2F;p&gt;
&lt;p&gt;结果为 little-endian。&lt;&#x2F;p&gt;
&lt;script&gt;
function rgbToRgb565(r, g, b) {
    const red = r &gt;&gt; 3;
    const green = g &gt;&gt; 2;
    const blue = b &gt;&gt; 3;
    return (red &lt;&lt; 11) | (green &lt;&lt; 5) | blue;
}

function download(uint16Array, filename) {
    var blob = new Blob([uint16Array], {type: &#x27;application&#x2F;octet-stream&#x27;});
    var url = URL.createObjectURL(blob);
    var a = document.createElement(&#x27;a&#x27;);
    a.href = url;
    a.download = filename;
    a.click();
}
let img = new Image();
let canvas = document.createElement(&#x27;canvas&#x27;);
let ctx = canvas.getContext(&#x27;2d&#x27;);
img.onload = function() {
    ctx.canvas.width = img.width;
    ctx.canvas.height = img.height;
    ctx.drawImage(img, 0, 0);
    let imgData = ctx.getImageData(0, 0, canvas.width, canvas.height).data;
    console.log(imgData);
    let rgb565Data = new ArrayBuffer(imgData.length &#x2F; 4 *2);
    let view = new DataView(rgb565Data);
    for (let i = 0; i &lt; imgData.length; i += 4) {
        const r = imgData[i];
        const g = imgData[i + 1];
        const b = imgData[i + 2];
        console.log(rgbToRgb565(r, g, b));
        view.setUint16(i &#x2F; 4* 2, rgbToRgb565(r, g, b), true);
    }
    download(rgb565Data, &#x27;rgb565data.bin&#x27;);
}

document.getElementById(&#x27;imageInput&#x27;).addEventListener(&#x27;change&#x27;, function(e) {
    var file = e.target.files[0];
    var reader = new FileReader();
    reader.onload = function(e) {
        img.src = e.target.result;
    }
    reader.readAsDataURL(file);
});

&lt;&#x2F;script&gt;
</content>
        
    </entry>
    <entry xml:lang="zh">
        <title>重新开始学数学 • 数理逻辑（5）</title>
        <published>2022-07-11T16:29:53.671+00:00</published>
        <updated>2022-07-13T00:20:17+00:00</updated>
        <author>
          <name>Unknown</name>
        </author>
        <link rel="alternate" href="https://longfangsong.github.io/restart-math-logic-5/" type="text/html"/>
        <id>https://longfangsong.github.io/restart-math-logic-5/</id>
        
        <content type="html">&lt;p&gt;我们的目标是写出一个函数，输入一个 CTL 模型和一个 Formula，输出模型中所有能 satisfy 这个 Formula 的状态集合。&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;satisfiable_states&lt;&#x2F;span&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;self&lt;&#x2F;span&gt;&lt;span&gt;: &amp;amp;CTLModule, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;formula&lt;&#x2F;span&gt;&lt;span&gt;: CTLFormula)
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;根据 CTL 中连接词的定义，我们可以写出：&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;satisfiable_states&lt;&#x2F;span&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;self&lt;&#x2F;span&gt;&lt;span&gt;: &amp;amp;CTLModule, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;formula&lt;&#x2F;span&gt;&lt;span&gt;: CTLFormula) {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;match&lt;&#x2F;span&gt;&lt;span&gt; formula {
&lt;&#x2F;span&gt;&lt;span&gt;        ⊤ =&amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;self&lt;&#x2F;span&gt;&lt;span&gt;.S,
&lt;&#x2F;span&gt;&lt;span&gt;        ⊥ =&amp;gt; ∅,
&lt;&#x2F;span&gt;&lt;span&gt;        Atomic(atomic) =&amp;gt; {s ∈ &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;self&lt;&#x2F;span&gt;&lt;span&gt;.S | atomic is &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;true &lt;&#x2F;span&gt;&lt;span&gt;in state s},
&lt;&#x2F;span&gt;&lt;span&gt;        Not(inner_formula) =&amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;self&lt;&#x2F;span&gt;&lt;span&gt;.S - model.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;sat&lt;&#x2F;span&gt;&lt;span&gt;(inner_formula),
&lt;&#x2F;span&gt;&lt;span&gt;        inner_formula1 ∧ inner_formula2 =&amp;gt; model.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;sat&lt;&#x2F;span&gt;&lt;span&gt;(inner_formula1) ∩ model.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;sat&lt;&#x2F;span&gt;&lt;span&gt;(inner_formula2),
&lt;&#x2F;span&gt;&lt;span&gt;        inner_formula1 ∨ inner_formula2 =&amp;gt; model.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;sat&lt;&#x2F;span&gt;&lt;span&gt;(inner_formula1) ∪ model.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;sat&lt;&#x2F;span&gt;&lt;span&gt;(inner_formula2),
&lt;&#x2F;span&gt;&lt;span&gt;        inner_formula1 → inner_formula2 =&amp;gt; model.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;sat&lt;&#x2F;span&gt;&lt;span&gt;(Not(inner_formula1) ∨ inner_formula2),
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;&#x2F;&#x2F; suppose we want to solve EX instead of AX, following ones are similar
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;AX&lt;&#x2F;span&gt;&lt;span&gt;(inner_formula) =&amp;gt; model.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;sat&lt;&#x2F;span&gt;&lt;span&gt;(Not(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;EX&lt;&#x2F;span&gt;&lt;span&gt;(Not(inner_formula)))),
&lt;&#x2F;span&gt;&lt;span&gt;        A[inner_formula1 U inner_formula2] =&amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;sat&lt;&#x2F;span&gt;&lt;span&gt;(Not(E[Not(inner_formula2) U (Not(inner_formula1) ∧ Not(inner_formula2))] ∨ &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;EG&lt;&#x2F;span&gt;&lt;span&gt; Not(inner_formula2)))
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;EF&lt;&#x2F;span&gt;&lt;span&gt;(inner_formula1) =&amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;sat&lt;&#x2F;span&gt;&lt;span&gt;(E[⊤ U inner_formula1])
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;EG&lt;&#x2F;span&gt;&lt;span&gt;(inner_formula1) =&amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;sat&lt;&#x2F;span&gt;&lt;span&gt;(Not(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;AF&lt;&#x2F;span&gt;&lt;span&gt;(Not(inner_formula1))))
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;AG&lt;&#x2F;span&gt;&lt;span&gt;(inner_formula1) =&amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;sat&lt;&#x2F;span&gt;&lt;span&gt;(Not(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;EF&lt;&#x2F;span&gt;&lt;span&gt;(Not(inner_formula1))))
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;EX&lt;&#x2F;span&gt;&lt;span&gt;(inner_formula) =&amp;gt; todo!(),
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;AF&lt;&#x2F;span&gt;&lt;span&gt;(inner_formula) =&amp;gt; todo!(),
&lt;&#x2F;span&gt;&lt;span&gt;        E[inner_formula1 U inner_formula2] =&amp;gt; todo!(),
&lt;&#x2F;span&gt;&lt;span&gt;    }
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Now we&#x27;ve done the trivial cases and &amp;quot;merged&amp;quot; the other cases into three.&lt;&#x2F;p&gt;
&lt;p&gt;然后我们一个个解这三个 case。&lt;&#x2F;p&gt;
&lt;h2 id=&quot;ex&quot;&gt;EX&lt;&#x2F;h2&gt;
&lt;p&gt;能满足 &lt;code&gt;EX(inner_formula)&lt;&#x2F;code&gt; 的状态，也就是“存在一个后继状态满足 &lt;code&gt;inner_formula&lt;&#x2F;code&gt;” 的状态。&lt;&#x2F;p&gt;
&lt;p&gt;只需要先找出所有能满足 &lt;code&gt;inner_formula&lt;&#x2F;code&gt; 的状态，再找出他们所有的前驱状态即可。&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;EX&lt;&#x2F;span&gt;&lt;span&gt;(inner_formula) =&amp;gt; {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; direct_satisfy = model.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;sat&lt;&#x2F;span&gt;&lt;span&gt;(inner_formula);
&lt;&#x2F;span&gt;&lt;span&gt;    direct_satisfy
&lt;&#x2F;span&gt;&lt;span&gt;        .&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;map&lt;&#x2F;span&gt;&lt;span&gt;(|&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;satisfying_state&lt;&#x2F;span&gt;&lt;span&gt;| model.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;predecessors&lt;&#x2F;span&gt;&lt;span&gt;(satisfying_state))
&lt;&#x2F;span&gt;&lt;span&gt;        .&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;union_all&lt;&#x2F;span&gt;&lt;span&gt;()
&lt;&#x2F;span&gt;&lt;span&gt;},
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;h2 id=&quot;af&quot;&gt;AF&lt;&#x2F;h2&gt;
&lt;p&gt;能满足 &lt;code&gt;AF(inner_formula)&lt;&#x2F;code&gt; 的状态，也就是“对于所有从这个点分散出去的 branch，inner_formula 都会在某状态下成立”的状态。&lt;&#x2F;p&gt;
&lt;p&gt;首先能满足 inner_formula 的所有 state 肯定满足上述条件，然后如果某个 state 的前驱的所有后继也都满足条件，那“这个 state 的前驱”也满足条件。&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;AF&lt;&#x2F;span&gt;&lt;span&gt;(inner_formula) =&amp;gt; {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; direct_satisfy = model.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;sat&lt;&#x2F;span&gt;&lt;span&gt;(inner_formula);
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;let mut&lt;&#x2F;span&gt;&lt;span&gt; current_satisfied = direct_satisfy;
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;let mut&lt;&#x2F;span&gt;&lt;span&gt; last_iteration_satisfied = None;
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;while&lt;&#x2F;span&gt;&lt;span&gt; last_iteration_satisfied != current_satisfied {
&lt;&#x2F;span&gt;&lt;span&gt;        last_iteration_satisfied = Some(current_satisfied);
&lt;&#x2F;span&gt;&lt;span&gt;        current_satisfied = current_satisfied.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;union&lt;&#x2F;span&gt;&lt;span&gt;({s ∈ &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;self&lt;&#x2F;span&gt;&lt;span&gt;.S | forall model.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;successor&lt;&#x2F;span&gt;&lt;span&gt;(s), s is in current_satisfied});
&lt;&#x2F;span&gt;&lt;span&gt;    }
&lt;&#x2F;span&gt;&lt;span&gt;    current_satisfied
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;h2 id=&quot;eu&quot;&gt;EU&lt;&#x2F;h2&gt;
&lt;p&gt;这个 case 稍微复杂些，&lt;code&gt;E[inner_formula1 U inner_formula2]&lt;&#x2F;code&gt; 的语意是存在某个 path，使得 &lt;code&gt;inner_formula1&lt;&#x2F;code&gt; 至少成立到 &lt;code&gt;inner_formula2&lt;&#x2F;code&gt; 成立为止。&lt;&#x2F;p&gt;
&lt;p&gt;首先由于 U 对 &lt;code&gt;inner_formula2&lt;&#x2F;code&gt; 成立后 &lt;code&gt;inner_formula1&lt;&#x2F;code&gt; 是否继续成立不做要求，所以所有 &lt;code&gt;inner_formula2&lt;&#x2F;code&gt; 成立的 state 都满足条件。&lt;&#x2F;p&gt;
&lt;p&gt;接着，对于所有已知满足条件的状态，如果他的前驱能满足 &lt;code&gt;inner_formula1&lt;&#x2F;code&gt;，那么这个状态也满足条件。&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span&gt;E[inner_formula1 U inner_formula2] =&amp;gt; {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; satisfy_formula1 = model.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;sat&lt;&#x2F;span&gt;&lt;span&gt;(inner_formula1);
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; satisfy_formula2 = model.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;sat&lt;&#x2F;span&gt;&lt;span&gt;(inner_formula2);
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;let mut&lt;&#x2F;span&gt;&lt;span&gt; current_satisfied = satisfy_formula2;
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;let mut&lt;&#x2F;span&gt;&lt;span&gt; last_iteration_satisfied = None;
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;while&lt;&#x2F;span&gt;&lt;span&gt; last_iteration_satisfied != current_satisfied {
&lt;&#x2F;span&gt;&lt;span&gt;        last_iteration_satisfied = Some(current_satisfied);
&lt;&#x2F;span&gt;&lt;span&gt;        current_satisfied = current_satisfied.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;union&lt;&#x2F;span&gt;&lt;span&gt;(model.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;successor&lt;&#x2F;span&gt;&lt;span&gt;(s).&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;intersect&lt;&#x2F;span&gt;&lt;span&gt;(satisfy_formula1));
&lt;&#x2F;span&gt;&lt;span&gt;    }
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;如此一来我们就完成了这整个算法。&lt;&#x2F;p&gt;
</content>
        
    </entry>
    <entry xml:lang="zh">
        <title>重新开始学数学 • 数理逻辑（4）</title>
        <published>2022-07-03T16:33:08.514+00:00</published>
        <updated>2022-07-03T16:33:08.514+00:00</updated>
        <author>
          <name>Unknown</name>
        </author>
        <link rel="alternate" href="https://longfangsong.github.io/restart-math-logic-4/" type="text/html"/>
        <id>https://longfangsong.github.io/restart-math-logic-4/</id>
        
        <content type="html">&lt;h2 id=&quot;shi-xu-luo-ji&quot;&gt;时序逻辑&lt;&#x2F;h2&gt;
&lt;blockquote&gt;
&lt;p&gt;在逻辑中，术语时间逻辑被用来描述为表现和推理关于时间限定的命题的规则和符号化的任何系统。 —— Wikipedia&lt;&#x2F;p&gt;
&lt;&#x2F;blockquote&gt;
&lt;p&gt;基于模型的程序正确性验证，比如现在常用的 TLA+，背后的原理就是时序逻辑。&lt;&#x2F;p&gt;
&lt;h3 id=&quot;xian-xing-shi-jian-shi-xu-luo-ji-ltl-linear-time-temporal-logic&quot;&gt;线性时间时序逻辑（LTL, Linear-time Temporal Logic）&lt;&#x2F;h3&gt;
&lt;blockquote&gt;
&lt;p&gt;In logic, linear temporal logic or linear-time temporal logic(LTL) is a modal temporal logic with modalities referring to time. —— Wikipedia&lt;&#x2F;p&gt;
&lt;&#x2F;blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;Linear-time temporal logic, or LTL for short, is a temporal logic, with connectives that allow us to refer to the future. —— Logic in Computer Science&lt;&#x2F;p&gt;
&lt;&#x2F;blockquote&gt;
&lt;p&gt;简单来说就是提供了描述时间的工具的时间逻辑系统。&lt;&#x2F;p&gt;
&lt;p&gt;这种逻辑系统将时间建模为一系列（不分支的）无限向未来延伸的状态。&lt;&#x2F;p&gt;
&lt;h4 id=&quot;xing-shi-hua-biao-shu&quot;&gt;形式化表述&lt;&#x2F;h4&gt;
&lt;p&gt;$$\displaylines {
Formula ::= \\
\top | \bot | p | \neg Formula | Formula \wedge Formula | Formula \vee Formula | Formula \rightarrow Formula \\
| X\ Formula | F\ Formula | G\ Formula | Formula\ U\ Formula | Formula\ W\ Formula | Formula\ R\ Formula
}
$$&lt;&#x2F;p&gt;
&lt;p&gt;其中 $p$ 是一个原子命题。&lt;&#x2F;p&gt;
&lt;h5 id=&quot;yu-yi&quot;&gt;语意&lt;&#x2F;h5&gt;
&lt;p&gt;除了喜闻乐见的 $\wedge$、$\vee$ 等，时序逻辑还添加了一些别的，用来描述状态之间关系的谓词符号&lt;sup class=&quot;footnote-reference&quot;&gt;&lt;a href=&quot;#1&quot;&gt;1&lt;&#x2F;a&gt;&lt;&#x2F;sup&gt;：&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;$X$ 代表 neXt state，比如 $X\ p$ 就是 $p$ 在下一个状态成立。&lt;&#x2F;li&gt;
&lt;li&gt;$F$ 代表 some Future state，比如 $F\ p$ 就是 $p$ 一定在某个未来&lt;sup class=&quot;footnote-reference&quot;&gt;&lt;a href=&quot;#2&quot;&gt;2&lt;&#x2F;a&gt;&lt;&#x2F;sup&gt;状态成立，常写作 $\diamond$。&lt;&#x2F;li&gt;
&lt;li&gt;$G$ 代表 all future states (Globally)，比如 $G\ p$ 就是 $p$ 在所有未来状态成立，常写作 $\square$。&lt;&#x2F;li&gt;
&lt;li&gt;$U$ 代表 Until，比如 $p\ U\ q$ 就是 $p$ 一直成立，“直到”&lt;sup class=&quot;footnote-reference&quot;&gt;&lt;a href=&quot;#3&quot;&gt;3&lt;&#x2F;a&gt;&lt;&#x2F;sup&gt;有一天 $q$ 成立，而且也 imply 了 $q$ 真的总有一天会成立。&lt;&#x2F;li&gt;
&lt;li&gt;$W$ 代表 Weak until，比如 $p\ W\ q$ 就是 $p$ 一直成立，直到有一天 $q$ 成立，&lt;strong&gt;但并不&lt;&#x2F;strong&gt; imply $q$ 真的总有一天会成立。&lt;&#x2F;li&gt;
&lt;li&gt;$R$ 代表 Release，$p\ R\ q$ 等价于 $\neg (\neg p\ U \neg q)$，也就是说，$p$ 的成立 释放了 $q$，使得 $q$ 可以不再成立。&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;h3 id=&quot;fen-zhi-shi-xu-luo-ji-ctl-computation-tree-logic&quot;&gt;分支时序逻辑（CTL，Computation Tree Logic）&lt;&#x2F;h3&gt;
&lt;blockquote&gt;
&lt;p&gt;Computation tree logic (CTL) is a branching-time logic, meaning that its model of time is a tree-like structure in which the future is not determined; there are different paths in the future, any one of which might be an actual path that is realized. —— Wikipedia &amp;amp; Logic in Computer Science&lt;&#x2F;p&gt;
&lt;&#x2F;blockquote&gt;
&lt;p&gt;简单来说就是可以描述整个执行树的逻辑系统。&lt;&#x2F;p&gt;
&lt;p&gt;相比 LTL，CTL 多出了“分支”，使得原本在 LTL 里无法表达的 “存在” 可以表达了。&lt;&#x2F;p&gt;
&lt;h4 id=&quot;xing-shi-hua-biao-shu-1&quot;&gt;形式化表述&lt;&#x2F;h4&gt;
&lt;p&gt;$$\displaylines {
Formula ::= \\
\top | \bot | p | \neg Formula | Formula \wedge Formula | Formula \vee Formula | Formula \rightarrow Formula \\
| AX\ Formula | EX\ Formula | AF\ Formula | EF\ Formula | AG\ Formula | EG\ Formula | A[Formula\ U\ Formula] | E[Formula\ U\ Formula]
}
$$&lt;&#x2F;p&gt;
&lt;p&gt;其中 $p$ 是一个原子命题。&lt;&#x2F;p&gt;
&lt;p&gt;CTL 一般不包含 $W$ 和 $R$。&lt;&#x2F;p&gt;
&lt;p&gt;需要注意的是，CTL 不包括“连用” LTL 新引入的连接词 的句子，比如 LTL $FG\ p$ 是合法的 LTL，但 $A(FG\ p)$ 却不是合法的 CTL。&lt;&#x2F;p&gt;
&lt;h4 id=&quot;yu-yi-1&quot;&gt;语意&lt;&#x2F;h4&gt;
&lt;p&gt;A 是 along All paths（但我更倾向于继续使用 Always）, 即后面的 LTL 在所有路径上成立。
E 是 there Exists one path，即后面的 LTL-like 的公式在某条路径上成立。&lt;&#x2F;p&gt;
&lt;h3 id=&quot;ctl&quot;&gt;CTL*&lt;&#x2F;h3&gt;
&lt;p&gt;CTL* 可以看作是 LTL 和 CTL “取长补短” 得到的结果，它也是 LTL 和 CTL 的超集。&lt;&#x2F;p&gt;
&lt;p&gt;在 CTL* 中，可以自由地使用 $A$&#x2F;$E$ 和 $X$&#x2F;$F$&#x2F;$G$&#x2F;$U$ 来连结命题。&lt;&#x2F;p&gt;
&lt;div class=&quot;footnote-definition&quot; id=&quot;1&quot;&gt;&lt;sup class=&quot;footnote-definition-label&quot;&gt;1&lt;&#x2F;sup&gt;
&lt;p&gt;当然书中给出了形式化的描述，但是 for most of the times, who cares?&lt;&#x2F;p&gt;
&lt;&#x2F;div&gt;
&lt;div class=&quot;footnote-definition&quot; id=&quot;2&quot;&gt;&lt;sup class=&quot;footnote-definition-label&quot;&gt;2&lt;&#x2F;sup&gt;
&lt;p&gt;这里说的所有“未来”都包含“现在”。&lt;&#x2F;p&gt;
&lt;&#x2F;div&gt;
&lt;div class=&quot;footnote-definition&quot; id=&quot;3&quot;&gt;&lt;sup class=&quot;footnote-definition-label&quot;&gt;3&lt;&#x2F;sup&gt;
&lt;p&gt;但并不说明 $q$ 成立之后 $p$ 一定就不成立了。&lt;&#x2F;p&gt;
&lt;&#x2F;div&gt;
</content>
        
    </entry>
    <entry xml:lang="zh">
        <title>定理证明器背后的数学原理</title>
        <published>2022-06-24T08:10:17.031+00:00</published>
        <updated>2022-06-30T13:04:33+00:00</updated>
        <author>
          <name>Unknown</name>
        </author>
        <link rel="alternate" href="https://longfangsong.github.io/why-lean-proof/" type="text/html"/>
        <id>https://longfangsong.github.io/why-lean-proof/</id>
        
        <content type="html">&lt;h2 id=&quot;how-it-looks-like&quot;&gt;How it looks like&lt;&#x2F;h2&gt;
&lt;p&gt;相比一上来就掰扯复杂的数学理论，我们不如先来看看一个使用定理证明器 Lean &lt;sup class=&quot;footnote-reference&quot;&gt;&lt;a href=&quot;#1&quot;&gt;1&lt;&#x2F;a&gt;&lt;&#x2F;sup&gt; 编写数学定理的证明的实际例子，我们就选择比较容易证明的德摩根定律来证：&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;lean&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-lean &quot;&gt;&lt;code class=&quot;language-lean&quot; data-lang=&quot;lean&quot;&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;open&lt;&#x2F;span&gt;&lt;span&gt; Classical
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;theorem &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;deMorgan &lt;&#x2F;span&gt;&lt;span&gt;: ¬(p ∧ q) ↔ ¬p ∨ ¬q :=
&lt;&#x2F;span&gt;&lt;span&gt;  Iff.intro
&lt;&#x2F;span&gt;&lt;span&gt;    (&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;λ&lt;&#x2F;span&gt;&lt;span&gt; (left: ¬(p ∧ q)) =&amp;gt; (
&lt;&#x2F;span&gt;&lt;span&gt;      Or.elim (em p) 
&lt;&#x2F;span&gt;&lt;span&gt;        (&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;λ&lt;&#x2F;span&gt;&lt;span&gt; (hp: p) =&amp;gt; Or.intro_right (¬p) (
&lt;&#x2F;span&gt;&lt;span&gt;          &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;λ&lt;&#x2F;span&gt;&lt;span&gt; (hq: q) =&amp;gt; absurd ⟨ hp, hq ⟩ left
&lt;&#x2F;span&gt;&lt;span&gt;        ))
&lt;&#x2F;span&gt;&lt;span&gt;        (&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;λ&lt;&#x2F;span&gt;&lt;span&gt; (hnp: ¬p) =&amp;gt; Or.intro_left (¬q) hnp)
&lt;&#x2F;span&gt;&lt;span&gt;    ))
&lt;&#x2F;span&gt;&lt;span&gt;    (&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;λ&lt;&#x2F;span&gt;&lt;span&gt; (left: ¬p ∨ ¬q) =&amp;gt; (
&lt;&#x2F;span&gt;&lt;span&gt;      Or.elim left
&lt;&#x2F;span&gt;&lt;span&gt;        (&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;λ&lt;&#x2F;span&gt;&lt;span&gt; (hnp: ¬p) (inner: p ∧ q) =&amp;gt; absurd inner.left hnp)
&lt;&#x2F;span&gt;&lt;span&gt;        (&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;λ&lt;&#x2F;span&gt;&lt;span&gt; (hnq: ¬q) (inner: p ∧ q) =&amp;gt; absurd inner.right hnq)
&lt;&#x2F;span&gt;&lt;span&gt;    ))
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;看起来这个证明好像是由一些 λ（就像 Python 中的 &lt;code&gt;lambda&lt;&#x2F;code&gt;，in case 你没学过“正规”的 FP 语言）和一些高阶函数（比如 &lt;code&gt;Or.elim&lt;&#x2F;code&gt;）组成的。&lt;&#x2F;p&gt;
&lt;p&gt;那这些东西凭什么能证明这个命题呢。&lt;&#x2F;p&gt;
&lt;p&gt;这就要牵扯到一个叫 Curry-Howard 同构的东西了。&lt;&#x2F;p&gt;
&lt;h2 id=&quot;curry-howard-tong-gou&quot;&gt;Curry-Howard 同构&lt;&#x2F;h2&gt;
&lt;p&gt;Curry-Howard 同构建立了 “证明”&lt;sup class=&quot;footnote-reference&quot;&gt;&lt;a href=&quot;#2&quot;&gt;2&lt;&#x2F;a&gt;&lt;&#x2F;sup&gt; 和 “程序”&lt;sup class=&quot;footnote-reference&quot;&gt;&lt;a href=&quot;#3&quot;&gt;3&lt;&#x2F;a&gt;&lt;&#x2F;sup&gt; 的对应关系：&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;一个程序（常体现为一个函数）的内容对应于一个证明&lt;&#x2F;p&gt;
&lt;p&gt;比如我们上面证明 &lt;code&gt;deMorgan&lt;&#x2F;code&gt; 定律时，无非就是把几个更基本的结论的证明组合起来（比如使用 &lt;code&gt;Iff.intro&lt;&#x2F;code&gt; 来结合 &lt;code&gt;↔&lt;&#x2F;code&gt; 从左至右和从右至左的结论的证明，来组成最终的证明），因此编写证明的过程就是在编写一个把 旧有结论的证明 结合成 新结论的证明 的程序。&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;一个类型对应于一个命题&lt;&#x2F;p&gt;
&lt;p&gt;比如我们上面证明的 &lt;code&gt;deMorgan&lt;&#x2F;code&gt; 定律，其对应的类型也就是之前提到过的“把旧有结论的证明结合成新结论的证明的程序”所对应的函数的类型。&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;比较简单的想法是，如果我们能从一个命题通过一些程序运算得到另一个命题，那如果前者成立，后者（因为是算出来的）也必定成立，所以这个程序就是两个命题间“实质蕴涵”的一个构造性证明；而为了让这个程序中的 “类型检查” 可以用于保证这个证明是有效的，我们可以用类型的形式“书写”这个命题。&lt;&#x2F;p&gt;
&lt;h2 id=&quot;zen-yao-yong-ye-ji-yi-xie-ji-suan-ji-fu-zhu-zheng-ming-de-li-zi&quot;&gt;怎么用，也即一些计算机辅助证明的例子&lt;&#x2F;h2&gt;
&lt;p&gt;例如我们要在 lean 中证明 &lt;code&gt;(p → (q → r)) → (p ∧ q → r)&lt;&#x2F;code&gt;，或者读作：&lt;&#x2F;p&gt;
&lt;p&gt;For all proposition p, q, and r, &amp;quot;p → (q → r)&amp;quot; implies &amp;quot;(p ∧ q) → r&amp;quot;.&lt;&#x2F;p&gt;
&lt;p&gt;根据“程序即证明”的思想接下来我们要写一个类型为 &lt;code&gt;(p → (q → r)) → (p ∧ q → r)&lt;&#x2F;code&gt; 的程序。&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;lean&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-lean &quot;&gt;&lt;code class=&quot;language-lean&quot; data-lang=&quot;lean&quot;&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;-- fill &amp;quot;sorry&amp;quot; here
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;theorem &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;tt&lt;&#x2F;span&gt;&lt;span&gt;: (p → (q → r)) → (p ∧ q → r) := &lt;&#x2F;span&gt;&lt;span style=&quot;background-color:#bf616a;color:#2b303b;&quot;&gt;sorry&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;我们直接创建一个这个类型的匿名函数：&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;lean&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-lean &quot;&gt;&lt;code class=&quot;language-lean&quot; data-lang=&quot;lean&quot;&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;theorem &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;tt&lt;&#x2F;span&gt;&lt;span&gt;: (p → (q → r)) → (p ∧ q → r) := 
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;λ&lt;&#x2F;span&gt;&lt;span&gt; (lhs: p → (q → r)) (hp_and_q: p ∧ q) =&amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;background-color:#bf616a;color:#2b303b;&quot;&gt;sorry&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;现在要做的就是填入函数体，考虑到 &lt;code&gt;∧&lt;&#x2F;code&gt; 的性质，直接将其拆分成 &lt;code&gt;left&lt;&#x2F;code&gt; 和 &lt;code&gt;right&lt;&#x2F;code&gt;，然后作为 &lt;code&gt;lhs&lt;&#x2F;code&gt; 的参数（由于 Curry-Howard 同构，lhs 既是类型为 命题 &lt;code&gt;p → (q → r)&lt;&#x2F;code&gt; 对应的类型 的一个函数，也是这个命题的证明）填入即可。&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;lean&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-lean &quot;&gt;&lt;code class=&quot;language-lean&quot; data-lang=&quot;lean&quot;&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;theorem &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;tt&lt;&#x2F;span&gt;&lt;span&gt;: (p → (q → r)) → (p ∧ q → r) := 
&lt;&#x2F;span&gt;&lt;span&gt;  &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;λ&lt;&#x2F;span&gt;&lt;span&gt; (lhs: p → (q → r)) (hp_and_q: p ∧ q) =&amp;gt; 
&lt;&#x2F;span&gt;&lt;span&gt;      lhs hp_and_q.left hp_and_q.right
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;现在，我们写出了一个类型是 &lt;code&gt;(p → (q → r)) → (p ∧ q → r)&lt;&#x2F;code&gt; 的函数，同时也就构造出了对应命题的证明，由于 lean 的类型检查器没有抱怨，我们就可以认为这个证明是正确的。&lt;&#x2F;p&gt;
&lt;p&gt;实际证明命题的时候，我们可以利用到一些事先已经证明好的定理或者公理（也就是对应的函数），比如：&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;Or.elim&lt;&#x2F;code&gt;，其类型为 &lt;code&gt;Or a b → (a → c) → (b → c) → c&lt;&#x2F;code&gt;，也就是说它是一个 &lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;接受一个形如 &lt;code&gt;Or a b&lt;&#x2F;code&gt; （常被写作 &lt;code&gt;a ∨ b&lt;&#x2F;code&gt;）的类型（也就是对应的命题）&lt;&#x2F;li&gt;
&lt;li&gt;再接受一个 &lt;code&gt;a → c&lt;&#x2F;code&gt; 类型的函数（或者说 命题 &lt;code&gt;a → c&lt;&#x2F;code&gt; 的证明）&lt;&#x2F;li&gt;
&lt;li&gt;再接受一个 &lt;code&gt;b → c&lt;&#x2F;code&gt; 类型的函数（或者说 命题 &lt;code&gt;b → c&lt;&#x2F;code&gt; 的证明）&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;的函数，也即是对应命题的证明。&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;更多 Lean 证明中可以使用的定理和公理，可以查看 &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;leanprover&#x2F;lean4&#x2F;blob&#x2F;master&#x2F;src&#x2F;&quot;&gt;Lean 源码&lt;&#x2F;a&gt; 里的库的部分，比如 &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;leanprover&#x2F;lean4&#x2F;blob&#x2F;master&#x2F;src&#x2F;Init&#x2F;Prelude.lean&quot;&gt;&lt;code&gt;Prelude.lean&lt;&#x2F;code&gt;&lt;&#x2F;a&gt; 和包含&lt;a href=&quot;https:&#x2F;&#x2F;zh.wikipedia.org&#x2F;wiki&#x2F;%E7%BB%8F%E5%85%B8%E9%80%BB%E8%BE%91&quot;&gt;经典逻辑&lt;&#x2F;a&gt; 的 &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;leanprover&#x2F;lean4&#x2F;blob&#x2F;master&#x2F;src&#x2F;Init&#x2F;Classical.lean&quot;&gt;&lt;code&gt;Classical.lean&lt;&#x2F;code&gt;&lt;&#x2F;a&gt;。&lt;&#x2F;p&gt;
&lt;div class=&quot;footnote-definition&quot; id=&quot;1&quot;&gt;&lt;sup class=&quot;footnote-definition-label&quot;&gt;1&lt;&#x2F;sup&gt;
&lt;p&gt;本文使用 Lean 4，但更多研究者使用 Lean 3。相比 Lean3，Lean 4 的“自动档” mathlib 还没有实装，但用来证明一些基本的逻辑命题已经足够了。&lt;&#x2F;p&gt;
&lt;&#x2F;div&gt;
&lt;div class=&quot;footnote-definition&quot; id=&quot;2&quot;&gt;&lt;sup class=&quot;footnote-definition-label&quot;&gt;2&lt;&#x2F;sup&gt;
&lt;p&gt;更专业的说法是“自然演绎”。&lt;&#x2F;p&gt;
&lt;&#x2F;div&gt;
&lt;div class=&quot;footnote-definition&quot; id=&quot;3&quot;&gt;&lt;sup class=&quot;footnote-definition-label&quot;&gt;3&lt;&#x2F;sup&gt;
&lt;p&gt;更专业的说法是“简单类型 λ 演算”。&lt;&#x2F;p&gt;
&lt;&#x2F;div&gt;
&lt;div class=&quot;footnote-definition&quot; id=&quot;4&quot;&gt;&lt;sup class=&quot;footnote-definition-label&quot;&gt;4&lt;&#x2F;sup&gt;
&lt;p&gt;假设所有函数都是科里化的，即 &lt;code&gt;Fn(a: T1) -&amp;gt; Fn(b: T2)&lt;&#x2F;code&gt; 和 &lt;code&gt;Fn(a: T1, b: T2)&lt;&#x2F;code&gt; 完全是一回事。&lt;&#x2F;p&gt;
&lt;&#x2F;div&gt;
</content>
        
    </entry>
    <entry xml:lang="zh">
        <title>midi 文件转蜂鸣器乐谱</title>
        <published>2022-06-05T11:56:50+00:00</published>
        <updated>2022-06-05T11:56:50+00:00</updated>
        <author>
          <name>Unknown</name>
        </author>
        <link rel="alternate" href="https://longfangsong.github.io/midi/" type="text/html"/>
        <id>https://longfangsong.github.io/midi/</id>
        
        <content type="html">&lt;p&gt;本工具可以将 midi 文件重新编码为 (频率[单位 Hz, 16位无符号数], 持续时间 [单位us, 32位无符号数]) 格式的数组。&lt;&#x2F;p&gt;
&lt;p&gt;对有多个通道的 midi 文件，只会保留第一个通道的数据。&lt;&#x2F;p&gt;
&lt;p&gt;对同一时间点的多个音符（柱状和弦），只保留最低音。&lt;&#x2F;p&gt;
&lt;p&gt;上传文件即可开始转换。&lt;&#x2F;p&gt;
&lt;p&gt;源代码：&lt;&#x2F;p&gt;
&lt;p&gt;&lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;longfangsong&#x2F;midi-compiler&quot;&gt;&lt;img src=&quot;https:&#x2F;&#x2F;gh-card.dev&#x2F;repos&#x2F;longfangsong&#x2F;midi-compiler.svg&quot; alt=&quot;longfangsong&#x2F;midi-compiler - GitHub&quot; &#x2F;&gt;&lt;&#x2F;a&gt;&lt;&#x2F;p&gt;
&lt;input type=&quot;file&quot; id=&quot;input&quot;&gt;
&lt;script type=&quot;module&quot;&gt;
import init, { convert_midi } from &#x27;.&#x2F;lib&#x2F;midi_compiler_lib.js&#x27;;

document.getElementById(&#x27;input&#x27;).disabled = true;
async function load_wasm() {
    await init();
    let inputElement = document.getElementById(&#x27;input&#x27;);
    inputElement.addEventListener(&#x27;change&#x27;, function () {
        const file = inputElement.files[0];
        const reader = new FileReader();
        const filename = file.name;
        reader.onload = (e) =&gt; {
            const data = new Uint8Array(e.target.result);
            const result = convert_midi(data);
            const blob = new Blob([result]);
            const url = window.URL.createObjectURL(blob);
            const a = document.createElement(&quot;a&quot;);
            let pathSegments = filename.split(&#x27;.&#x27;);
            if (pathSegments.length &gt; 1) {
                pathSegments.pop();
            }
            pathSegments.push(&#x27;notes&#x27;);
            a.download = pathSegments.join(&#x27;.&#x27;);
            a.href = url;
            a.click();
            window.URL.revokeObjectURL(url);
            inputElement.value = null;
        };
        reader.readAsArrayBuffer(file);
    });
    inputElement.disabled = false;
}
load_wasm();
&lt;&#x2F;script&gt;</content>
        
    </entry>
    <entry xml:lang="zh">
        <title>交流电基础</title>
        <published>2022-02-28T22:21:20+00:00</published>
        <updated>2022-02-28T22:21:20+00:00</updated>
        <author>
          <name>Unknown</name>
        </author>
        <link rel="alternate" href="https://longfangsong.github.io/alternating-current/" type="text/html"/>
        <id>https://longfangsong.github.io/alternating-current/</id>
        
        <content type="html">&lt;blockquote&gt;
&lt;p&gt;交流电流是指电流强度和电流方向都发生周期性变化的电流，在一个周期内的运行平均值为零。—— 维基百科&lt;&#x2F;p&gt;
&lt;&#x2F;blockquote&gt;
&lt;p&gt;虽然定义上是这么说的，但是分析交流电的方法也适合分析一些没那么周期性的变化的，平均值不为 0 的电流，比如高速信号的传输。&lt;&#x2F;p&gt;
&lt;h2 id=&quot;zheng-xian-jiao-liu-dian&quot;&gt;正弦交流电&lt;&#x2F;h2&gt;
&lt;p&gt;最常见的交流电，比如平常我们生活中的插头接出来的 220V 电就是正弦交流电，即电流变化符合正弦函数的交流电。&lt;&#x2F;p&gt;
&lt;p&gt;正弦交流电的电流值可以用如下函数表示：&lt;&#x2F;p&gt;
&lt;p&gt;$$
I(t) = I_{max} sin(k t + I_0)
$$&lt;&#x2F;p&gt;
&lt;p&gt;&lt;canvas id=&quot;sineCanvas&quot;&gt;&lt;&#x2F;canvas&gt;
&lt;button id=&quot;pause&quot;&gt;暂停&lt;&#x2F;button&gt;&lt;&#x2F;p&gt;
&lt;script&gt;
    let paused = false;
    let canvas = document.getElementById(&quot;sineCanvas&quot;);
    canvas.width = window.innerWidth * 0.7;
    canvas.height = 300;
    let context = canvas.getContext(&quot;2d&quot;);
    let height = canvas.height;
    let width = canvas.width;
    const dpr = window.devicePixelRatio;
    canvas.width = width * dpr;
    canvas.height = height * dpr;
    canvas.style.width = width + &#x27;px&#x27;;
    canvas.style.height = height + &#x27;px&#x27;;
    context.scale(dpr, dpr);
    context.font = &#x27;18px sans-serif&#x27;;
    context.strokeStyle = &#x27;#000&#x27;;
    context.lineJoin = &#x27;round&#x27;;
    let xAxis = Math.floor(height &#x2F; 2);
    let yAxis = Math.floor(width &#x2F; 4);
    let t = 0;
    let seconds = 0;
    const unit = window.innerWidth * 0.07;
    context.save();
    draw();
    function draw() {
        if (!paused) {
            context.clearRect(0, 0, width, height);
            context.beginPath();
            drawAxes();
            context.stroke();
            context.save();
            context.strokeStyle = &#x27;#00f&#x27;;
            context.fillStyle = &#x27;#fff&#x27;;
            context.lineWidth = 2;
            context.beginPath();
            drawSine(t);
            drawCircle();
            context.stroke();
            drawArrow(t);
            context.restore();
            context.fillText(&quot;Imax&quot;, yAxis + unit + 10, 18 + xAxis);
            seconds = seconds - .007;
            t = seconds * Math.PI;
        }
        setTimeout(draw, 35);
    };
    function drawAxes() {
        context.moveTo(0, xAxis);
        context.lineTo(width, xAxis);
        context.moveTo(yAxis, 0);
        context.lineTo(yAxis, height);
        context.moveTo(yAxis + Math.PI * unit, xAxis + 5);
        context.lineTo(yAxis + Math.PI * unit, xAxis - 5);
    }
    function drawSine(t) {
        let x = t;
        let y = Math.sin(x);
        context.moveTo(yAxis, unit * y + xAxis);
        for (i = yAxis; i &lt;= width; i += 10) {
            x = t + (-yAxis + i) &#x2F; unit;
            y = Math.sin(x);
            context.lineTo(i, unit * y + xAxis);
        }
    }
    function drawCircle() {
        context.moveTo(yAxis + unit, xAxis);
        context.arc(yAxis, xAxis, unit, 0, 2 * Math.PI, false);
    }
    function drawArrow(t) {
        let x = yAxis + unit * Math.cos(t);
        let y = xAxis + unit * Math.sin(t);
        context.beginPath();
        context.moveTo(yAxis, xAxis);
        context.lineTo(x, y);
        context.stroke();
        context.beginPath();
        context.arc(x, y, 5, 0, 2 * Math.PI, false);
        context.fill();
        context.stroke();
        context.beginPath();
        let direction = (Math.cos(t) &lt; 0) ? 1 : -1;
        let start = (direction == -1) ? -5 : 0;
        for (let i = x; direction * i &lt; direction * yAxis - 5; i = i + direction * 10) {
            context.moveTo(i + direction * 5, y);
            context.lineTo(i + direction * 10, y);
        }
        context.stroke();
        context.beginPath();
        context.arc(yAxis, y, 5, 0, 2 * Math.PI, false);
        context.fill();
        context.stroke();
        context.fillStyle = &quot;black&quot;;
        context.fillText(`I=${-Math.sin(t).toFixed(2)}Imax`, yAxis + 0.15*unit, y);
    }
    let pauseButton = document.getElementById(&quot;pause&quot;);
    pauseButton.addEventListener(&quot;click&quot;, function () {
        paused = !paused;
    });
&lt;&#x2F;script&gt;
&lt;p&gt;其中数值的正负自然代表电流的方向。&lt;&#x2F;p&gt;
&lt;h2 id=&quot;li-xiang-dian-zu-zai-jiao-liu-dian-lu-zhong-de-te-xing&quot;&gt;（理想）电阻在交流电路中的特性&lt;&#x2F;h2&gt;
&lt;p&gt;电阻没啥好说的，和直流电路中一样。&lt;&#x2F;p&gt;
&lt;h2 id=&quot;li-xiang-dian-rong-zai-jiao-liu-dian-lu-zhong-de-te-xing&quot;&gt;（理想）电容在交流电路中的特性&lt;&#x2F;h2&gt;
&lt;p&gt;最简单的电容就是两块平行金属板，在外部电压的作用下，接到低电压的一侧会聚集负电荷，另一端会聚集正电荷。&lt;&#x2F;p&gt;
&lt;p&gt;在交流电&lt;sup class=&quot;footnote-reference&quot;&gt;&lt;a href=&quot;#1&quot;&gt;1&lt;&#x2F;a&gt;&lt;&#x2F;sup&gt;中，由于电流的方向不断变化，电容两侧的电压高低也不断变化，因此两侧聚集的电荷也不断变化。&lt;&#x2F;p&gt;
&lt;p&gt;由于产生电流的是&lt;strong&gt;电压差&lt;&#x2F;strong&gt;，稍微思考一下就知道，当电容两侧电压达到最大值时，电流为 0 ，此时就是电容“充饱”了；反之当电容两侧电压为 0 时，电流达到最大 ，此时就是电容“放空”了。&lt;&#x2F;p&gt;
&lt;p&gt;&lt;canvas id=&quot;capacitorCanvas&quot;&gt;&lt;&#x2F;canvas&gt;
&lt;button id=&quot;pauseCapacitor&quot;&gt;暂停&lt;&#x2F;button&gt;&lt;&#x2F;p&gt;
&lt;script&gt;
    let capacitorPaused = false;
    let capacitorCanvas = document.getElementById(&quot;capacitorCanvas&quot;);
    capacitorCanvas.width = window.innerWidth * 0.7;
    capacitorCanvas.height = 300;
    let capacitorContext = capacitorCanvas.getContext(&quot;2d&quot;);
    let capacitorHeight = capacitorCanvas.height;
    let capacitorWidth = capacitorCanvas.width;
    capacitorCanvas.width = width * dpr;
    capacitorCanvas.height = height * dpr;
    capacitorCanvas.style.width = width + &#x27;px&#x27;;
    capacitorCanvas.style.height = height + &#x27;px&#x27;;
    capacitorContext.scale(dpr, dpr);
    capacitorContext.font = &#x27;18px sans-serif&#x27;;
    capacitorContext.strokeStyle = &#x27;#000&#x27;;
    capacitorContext.lineJoin = &#x27;round&#x27;;
    capacitorContext.save();
    let capacitorSeconds = 0;
    let capacitorT = 0;
    drawCapacitor();
    function drawCapacitor() {
        if (!capacitorPaused) {
            capacitorContext.clearRect(0, 0, width, height);
            drawCapacitorAxes();
            drawCapacitorSine(capacitorT);
            drawCapacitorCircle();
            drawCapacitorArrow(capacitorT);
            capacitorSeconds = capacitorSeconds - .007;
            capacitorT = capacitorSeconds * Math.PI;
        }
        setTimeout(drawCapacitor, 50);
    };
    function drawCapacitorAxes() {
        capacitorContext.beginPath();
        capacitorContext.moveTo(0, xAxis);
        capacitorContext.lineTo(width, xAxis);
        capacitorContext.moveTo(yAxis, 0);
        capacitorContext.lineTo(yAxis, height);
        capacitorContext.moveTo(yAxis + Math.PI * unit, xAxis + 5);
        capacitorContext.lineTo(yAxis + Math.PI * unit, xAxis - 5);
        capacitorContext.fillText(&quot;Imax&quot;, yAxis + unit + 10, 18 + xAxis);
        capacitorContext.fillText(&quot;Umax&quot;, yAxis + unit - 70, 18 + xAxis);
        capacitorContext.stroke();
    }
    function drawCapacitorSine(t) {
        capacitorContext.save();
        capacitorContext.strokeStyle = &#x27;#00f&#x27;;
        capacitorContext.fillStyle = &#x27;#fff&#x27;;
        capacitorContext.lineWidth = 2;
        capacitorContext.beginPath();
        let x = t;
        let y = Math.sin(x);
        capacitorContext.moveTo(yAxis, unit * y + xAxis);
        for (i = yAxis; i &lt;= width; i += 10) {
            x = t + (-yAxis + i) &#x2F; unit;
            y = Math.sin(x);
            capacitorContext.lineTo(i, unit * y + xAxis);
        }
        capacitorContext.stroke();
        capacitorContext.restore();
        capacitorContext.save();
        capacitorContext.strokeStyle = &#x27;#0f0&#x27;;
        capacitorContext.fillStyle = &#x27;rgba(0,0,0,0)&#x27;;
        capacitorContext.lineWidth = 2;
        capacitorContext.beginPath();
        x = t;
        y = Math.sin(x+Math.PI&#x2F;2)*0.8;
        capacitorContext.moveTo(yAxis, unit * y + xAxis);
        for (i = yAxis; i &lt;= width; i += 10) {
            x = t + (-yAxis + i) &#x2F; unit;
            y = Math.sin(x+Math.PI&#x2F;2)*0.8;
            capacitorContext.lineTo(i, unit * y + xAxis);
        }
        capacitorContext.stroke();
        capacitorContext.restore();
    }
    function drawCapacitorCircle() {
        capacitorContext.save();
        capacitorContext.strokeStyle = &#x27;#00f&#x27;;
        capacitorContext.fillStyle = &#x27;#fff&#x27;;
        capacitorContext.lineWidth = 2;
        capacitorContext.beginPath();
        capacitorContext.moveTo(yAxis + unit, xAxis);
        capacitorContext.arc(yAxis, xAxis, unit, 0, 2 * Math.PI, false);
        capacitorContext.stroke();
        capacitorContext.restore();
        capacitorContext.save();
        capacitorContext.strokeStyle = &#x27;#0f0&#x27;;
        capacitorContext.fillStyle = &#x27;#fff&#x27;;
        capacitorContext.lineWidth = 2;
        capacitorContext.moveTo(yAxis + unit, xAxis);
        capacitorContext.beginPath();
        capacitorContext.arc(yAxis, xAxis, unit*0.8, 0, 2 * Math.PI, false);
        capacitorContext.stroke();
        capacitorContext.restore();
    }
    function drawCapacitorArrow(t) {
        capacitorContext.save();
        capacitorContext.strokeStyle = &#x27;#00f&#x27;;
        capacitorContext.fillStyle = &#x27;#fff&#x27;;
        capacitorContext.lineWidth = 2;
        let x = yAxis + unit * Math.cos(t);
        let y = xAxis + unit * Math.sin(t);
        capacitorContext.beginPath();
        capacitorContext.moveTo(yAxis, xAxis);
        capacitorContext.lineTo(x, y);
        capacitorContext.stroke();
        capacitorContext.beginPath();
        capacitorContext.arc(x, y, 5, 0, 2 * Math.PI, false);
        capacitorContext.fill();
        capacitorContext.stroke();
        capacitorContext.beginPath();
        let direction = (Math.cos(t) &lt; 0) ? 1 : -1;
        let start = (direction == -1) ? -5 : 0;
        for (let i = x; direction * i &lt; direction * yAxis - 5; i = i + direction * 10) {
            capacitorContext.moveTo(i + direction * 5, y);
            capacitorContext.lineTo(i + direction * 10, y);
        }
        capacitorContext.stroke();
        capacitorContext.beginPath();
        capacitorContext.arc(yAxis, y, 5, 0, 2 * Math.PI, false);
        capacitorContext.fill();
        capacitorContext.stroke();
        capacitorContext.fillStyle = &quot;black&quot;;
        capacitorContext.fillText(`I=${-Math.sin(t).toFixed(2)}Imax`, yAxis + 0.15*unit, y);
        capacitorContext.fillStyle = &quot;white&quot;;
        x = yAxis + unit * 0.8 * Math.cos(t+Math.PI&#x2F;2);
        y = xAxis + unit * 0.8 * Math.sin(t+Math.PI&#x2F;2);
        capacitorContext.restore();
        capacitorContext.save();
        capacitorContext.strokeStyle = &#x27;#0f0&#x27;;
        capacitorContext.fillStyle = &#x27;#fff&#x27;;
        capacitorContext.lineWidth = 2;
        capacitorContext.beginPath();
        capacitorContext.moveTo(yAxis, xAxis);
        capacitorContext.lineTo(x, y);
        capacitorContext.stroke();
        capacitorContext.beginPath();
        capacitorContext.arc(x, y, 5, 0, 2 * Math.PI, false);
        capacitorContext.fill();
        capacitorContext.stroke();
        capacitorContext.beginPath();
        direction = (Math.cos(t+Math.PI&#x2F;2) &lt; 0) ? 1 : -1;
        start = (direction == -1) ? -5 : 0;
        for (let i = x; direction * i &lt; direction * yAxis - 5; i = i + direction * 10) {
            capacitorContext.moveTo(i + direction * 5, y);
            capacitorContext.lineTo(i + direction * 10, y);
        }
        capacitorContext.stroke();
        capacitorContext.beginPath();
        capacitorContext.arc(yAxis, y, 5, 0, 2 * Math.PI, false);
        capacitorContext.fill();
        capacitorContext.stroke();
        capacitorContext.fillStyle = &quot;black&quot;;
        capacitorContext.fillText(`U=${-Math.sin(t+Math.PI&#x2F;2).toFixed(2)}Umax`, yAxis + 0.15*unit, y);
        capacitorContext.restore();
    }
    let capacitorPauseButton = document.getElementById(&quot;pauseCapacitor&quot;);
    capacitorPauseButton.addEventListener(&quot;click&quot;, function () {
        capacitorPaused = !capacitorPaused;
    });
&lt;&#x2F;script&gt;
&lt;p&gt;从图中可以看到，电容两侧的电压和电流变化差四分之一周期，或者说相位差 90 度。&lt;&#x2F;p&gt;
&lt;h2 id=&quot;li-xiang-dian-gan-zai-jiao-liu-dian-lu-zhong-de-te-xing&quot;&gt;（理想）电感在交流电路中的特性&lt;&#x2F;h2&gt;
&lt;p&gt;最简单的电感就一个绕起来的线圈，流过线圈的电流变化时，就会感应出磁场，而磁场会反过来感应出和原本电流相反的电压。&lt;&#x2F;p&gt;
&lt;p&gt;在交流电中，电感总是不断感应出和电流相反的电压，电感某时刻电感感应出的电压和电感该时刻的电流变化量（即电流变化的导数）成正相关，因此若电流变化曲线为正弦曲线，则电感上的电压就是余弦曲线。&lt;&#x2F;p&gt;
&lt;p&gt;&lt;canvas id=&quot;inductorCanvas&quot;&gt;&lt;&#x2F;canvas&gt;
&lt;button id=&quot;pauseInductor&quot;&gt;暂停&lt;&#x2F;button&gt;&lt;&#x2F;p&gt;
&lt;script&gt;
    let inductorPaused = false;
    let inductorCanvas = document.getElementById(&quot;inductorCanvas&quot;);
    inductorCanvas.width = window.innerWidth * 0.7;
    inductorCanvas.height = 300;
    let inductorContext = inductorCanvas.getContext(&quot;2d&quot;);
    let inductorHeight = inductorCanvas.height;
    let inductorWidth = inductorCanvas.width;
    inductorCanvas.width = width * dpr;
    inductorCanvas.height = height * dpr;
    inductorCanvas.style.width = width + &#x27;px&#x27;;
    inductorCanvas.style.height = height + &#x27;px&#x27;;
    inductorContext.scale(dpr, dpr);
    inductorContext.font = &#x27;18px sans-serif&#x27;;
    inductorContext.strokeStyle = &#x27;#000&#x27;;
    inductorContext.lineJoin = &#x27;round&#x27;;
    inductorContext.save();
    let inductorSeconds = 0;
    let inductorT = 0;
    drawInductor();
    function drawInductor() {
        if (!inductorPaused) {
            inductorContext.clearRect(0, 0, width, height);
            drawInductorAxes();
            drawInductorSine(inductorT);
            drawInductorCircle();
            drawInductorArrow(inductorT);
            inductorSeconds = inductorSeconds - .007;
            inductorT = inductorSeconds * Math.PI;
        }
        setTimeout(drawInductor, 50);
    };
    function drawInductorAxes() {
        inductorContext.beginPath();
        inductorContext.moveTo(0, xAxis);
        inductorContext.lineTo(width, xAxis);
        inductorContext.moveTo(yAxis, 0);
        inductorContext.lineTo(yAxis, height);
        inductorContext.moveTo(yAxis + Math.PI * unit, xAxis + 5);
        inductorContext.lineTo(yAxis + Math.PI * unit, xAxis - 5);
        inductorContext.fillText(&quot;Imax&quot;, yAxis + unit + 10, 18 + xAxis);
        inductorContext.fillText(&quot;Umax&quot;, yAxis + unit - 70, 18 + xAxis);
        inductorContext.stroke();
    }
    function drawInductorSine(t) {
        inductorContext.save();
        inductorContext.strokeStyle = &#x27;#00f&#x27;;
        inductorContext.fillStyle = &#x27;#fff&#x27;;
        inductorContext.lineWidth = 2;
        inductorContext.beginPath();
        let x = t;
        let y = Math.sin(x);
        inductorContext.moveTo(yAxis, unit * y + xAxis);
        for (i = yAxis; i &lt;= width; i += 10) {
            x = t + (-yAxis + i) &#x2F; unit;
            y = Math.sin(x);
            inductorContext.lineTo(i, unit * y + xAxis);
        }
        inductorContext.stroke();
        inductorContext.restore();
        inductorContext.save();
        inductorContext.strokeStyle = &#x27;#0f0&#x27;;
        inductorContext.fillStyle = &#x27;rgba(0,0,0,0)&#x27;;
        inductorContext.lineWidth = 2;
        inductorContext.beginPath();
        x = t;
        y = Math.sin(x-Math.PI&#x2F;2)*0.8;
        inductorContext.moveTo(yAxis, unit * y + xAxis);
        for (i = yAxis; i &lt;= width; i += 10) {
            x = t + (-yAxis + i) &#x2F; unit;
            y = Math.sin(x-Math.PI&#x2F;2)*0.8;
            inductorContext.lineTo(i, unit * y + xAxis);
        }
        inductorContext.stroke();
        inductorContext.restore();
    }
    function drawInductorCircle() {
        inductorContext.save();
        inductorContext.strokeStyle = &#x27;#00f&#x27;;
        inductorContext.fillStyle = &#x27;#fff&#x27;;
        inductorContext.lineWidth = 2;
        inductorContext.beginPath();
        inductorContext.moveTo(yAxis + unit, xAxis);
        inductorContext.arc(yAxis, xAxis, unit, 0, 2 * Math.PI, false);
        inductorContext.stroke();
        inductorContext.restore();
        inductorContext.save();
        inductorContext.strokeStyle = &#x27;#0f0&#x27;;
        inductorContext.fillStyle = &#x27;#fff&#x27;;
        inductorContext.lineWidth = 2;
        inductorContext.moveTo(yAxis + unit, xAxis);
        inductorContext.beginPath();
        inductorContext.arc(yAxis, xAxis, unit*0.8, 0, 2 * Math.PI, false);
        inductorContext.stroke();
        inductorContext.restore();
    }
    function drawInductorArrow(t) {
        inductorContext.save();
        inductorContext.strokeStyle = &#x27;#00f&#x27;;
        inductorContext.fillStyle = &#x27;#fff&#x27;;
        inductorContext.lineWidth = 2;
        let x = yAxis + unit * Math.cos(t);
        let y = xAxis + unit * Math.sin(t);
        inductorContext.beginPath();
        inductorContext.moveTo(yAxis, xAxis);
        inductorContext.lineTo(x, y);
        inductorContext.stroke();
        inductorContext.beginPath();
        inductorContext.arc(x, y, 5, 0, 2 * Math.PI, false);
        inductorContext.fill();
        inductorContext.stroke();
        inductorContext.beginPath();
        let direction = (Math.cos(t) &lt; 0) ? 1 : -1;
        let start = (direction == -1) ? -5 : 0;
        for (let i = x; direction * i &lt; direction * yAxis - 5; i = i + direction * 10) {
            inductorContext.moveTo(i + direction * 5, y);
            inductorContext.lineTo(i + direction * 10, y);
        }
        inductorContext.stroke();
        inductorContext.beginPath();
        inductorContext.arc(yAxis, y, 5, 0, 2 * Math.PI, false);
        inductorContext.fill();
        inductorContext.stroke();
        inductorContext.fillStyle = &quot;black&quot;;
        inductorContext.fillText(`I=${-Math.sin(t).toFixed(2)}Imax`, yAxis + 0.15*unit, y);
        inductorContext.fillStyle = &quot;white&quot;;
        x = yAxis + unit * 0.8 * Math.cos(t-Math.PI&#x2F;2);
        y = xAxis + unit * 0.8 * Math.sin(t-Math.PI&#x2F;2);
        inductorContext.restore();
        inductorContext.save();
        inductorContext.strokeStyle = &#x27;#0f0&#x27;;
        inductorContext.fillStyle = &#x27;#fff&#x27;;
        inductorContext.lineWidth = 2;
        inductorContext.beginPath();
        inductorContext.moveTo(yAxis, xAxis);
        inductorContext.lineTo(x, y);
        inductorContext.stroke();
        inductorContext.beginPath();
        inductorContext.arc(x, y, 5, 0, 2 * Math.PI, false);
        inductorContext.fill();
        inductorContext.stroke();
        inductorContext.beginPath();
        direction = (Math.cos(t+Math.PI&#x2F;2) &lt; 0) ? 1 : -1;
        start = (direction == -1) ? -5 : 0;
        for (let i = x; direction * i &lt; direction * yAxis - 5; i = i + direction * 10) {
            inductorContext.moveTo(i + direction * 5, y);
            inductorContext.lineTo(i + direction * 10, y);
        }
        inductorContext.stroke();
        inductorContext.beginPath();
        inductorContext.arc(yAxis, y, 5, 0, 2 * Math.PI, false);
        inductorContext.fill();
        inductorContext.stroke();
        inductorContext.fillStyle = &quot;black&quot;;
        inductorContext.fillText(`U=${-Math.sin(t-Math.PI&#x2F;2).toFixed(2)}Umax`, yAxis + 0.15*unit, y);
        inductorContext.restore();
    }
    let inductorPauseButton = document.getElementById(&quot;pauseInductor&quot;);
    inductorPauseButton.addEventListener(&quot;click&quot;, function () {
        inductorPaused = !inductorPaused;
    });
&lt;&#x2F;script&gt;
&lt;h2 id=&quot;zu-kang&quot;&gt;阻抗&lt;&#x2F;h2&gt;
&lt;p&gt;阻抗就是元件对交流电的阻碍作用，定义为电压与电流的频域比率。
&lt;strong&gt;概念&lt;&#x2F;strong&gt;上，&lt;&#x2F;p&gt;
&lt;p&gt;$$
阻抗 = 电阻部分 + 电抗部分
$$&lt;&#x2F;p&gt;
&lt;p&gt;电阻就和直流电里的电阻一样，恒定地阻碍电流的通过，在理想元件中只有电阻器有电阻。&lt;&#x2F;p&gt;
&lt;h3 id=&quot;dian-kang&quot;&gt;电抗&lt;&#x2F;h3&gt;
&lt;p&gt;电抗又可以分为容抗和感抗：&lt;&#x2F;p&gt;
&lt;p&gt;$$
X = X_C + X_L
$$&lt;&#x2F;p&gt;
&lt;p&gt;容抗和感抗分别表现了电容和电感对交流电的阻碍作用。&lt;&#x2F;p&gt;
&lt;h4 id=&quot;rong-kang&quot;&gt;容抗&lt;&#x2F;h4&gt;
&lt;p&gt;电容在电流充入的时候，由于两侧极板上都有很多的同电性的电荷，这些电荷就会排斥其他这种电性的电荷，从而导致电容会阻碍电流。&lt;&#x2F;p&gt;
&lt;p&gt;因此直觉上可以得出：&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;电流变化得越快，极板上的电荷就可以更快地被放掉，从而减少电容对电流的阻碍作用&lt;&#x2F;li&gt;
&lt;li&gt;电容总容量越大（可以看作“极板”越大），极板上的电荷产生的对其他电荷同种电荷的排斥力就越小，也可以减少电容对电流的阻碍作用&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;这个直觉&lt;sup class=&quot;footnote-reference&quot;&gt;&lt;a href=&quot;#2&quot;&gt;2&lt;&#x2F;a&gt;&lt;&#x2F;sup&gt;是非常准确的，容抗的公式正是：&lt;&#x2F;p&gt;
&lt;p&gt;$$
X_C = \frac{1}{\omega C} = \frac 1 {2\pi fC}
$$&lt;&#x2F;p&gt;
&lt;p&gt;其中 $\omega$ 就是交流电的角频率，$f$ 为其对应的频率，$C$ 就是电容的容量&lt;sup class=&quot;footnote-reference&quot;&gt;&lt;a href=&quot;#3&quot;&gt;3&lt;&#x2F;a&gt;&lt;&#x2F;sup&gt;。&lt;&#x2F;p&gt;
&lt;h4 id=&quot;gan-kang&quot;&gt;感抗&lt;&#x2F;h4&gt;
&lt;p&gt;电感产生的感应电压会生成和原本的电流相反的电流，使得总电流减小。&lt;&#x2F;p&gt;
&lt;p&gt;我们结合电磁感应定律，可以直觉上得出：&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;电流变化的越快，感应出的电流越大，电感的阻碍作用就越大&lt;&#x2F;li&gt;
&lt;li&gt;电感值越大（即线圈的匝数越多，磁导率越大，面积越大，线长越小），电感的阻碍作用就越大&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;因此电感的公式是：&lt;&#x2F;p&gt;
&lt;p&gt;$$
X_L = \omega C = 2\pi fC
$$&lt;&#x2F;p&gt;
&lt;h3 id=&quot;fu-zu-kang&quot;&gt;复阻抗&lt;&#x2F;h3&gt;
&lt;p&gt;为了计算方便，通过包括欧拉公式拉普拉斯变换在内的一系列手段&lt;sup class=&quot;footnote-reference&quot;&gt;&lt;a href=&quot;#4&quot;&gt;4&lt;&#x2F;a&gt;&lt;&#x2F;sup&gt;，我们将电压、电流和阻抗写成复数形式：&lt;&#x2F;p&gt;
&lt;p&gt;$$
U(t) = U_{max}cos(\omega t + U_0) + isin(\omega t + U_0) = U_{max}e^{i(\omega t + U_0)}
$$&lt;&#x2F;p&gt;
&lt;p&gt;$$
I(t) = I_{max}cos(\omega t + I_0) + isin(\omega t + I_0) = I_{max}e^{i(\omega t + I_0)}
$$&lt;&#x2F;p&gt;
&lt;p&gt;$$
Z = R + iX = |Z|\angle \theta = |Z| e^{i\theta}
$$&lt;&#x2F;p&gt;
&lt;p&gt;这样表示之后，许多在直流电中成立的定律可以直接 lift 到交流电上来：&lt;&#x2F;p&gt;
&lt;p&gt;比如欧姆定律：&lt;&#x2F;p&gt;
&lt;p&gt;$$
U(t) = I(t)X
$$&lt;&#x2F;p&gt;
&lt;h2 id=&quot;jiao-liu-dian-de-you-xiao-zhi&quot;&gt;交流电的有效值&lt;&#x2F;h2&gt;
&lt;p&gt;交流电的有效值指的是在相同的电阻上分别通过直流电流和交流电流，经过一个交流周期的时间，如果它们在电阻上所消耗的电能相等的话，则把该直流电流（电压）的大小等于交流电流（电压）的有效值。&lt;&#x2F;p&gt;
&lt;p&gt;总之就是在消耗电能方面和交流电等效的直流电流&#x2F;压的大小。&lt;&#x2F;p&gt;
&lt;p&gt;对于正弦交流电，有：&lt;&#x2F;p&gt;
&lt;p&gt;$$
I_{max} = \sqrt{2}I_{有效}
$$&lt;&#x2F;p&gt;
&lt;p&gt;$$
U_{max} = \sqrt{2}U_{有效}
$$&lt;&#x2F;p&gt;
&lt;h2 id=&quot;san-xiang-jiao-liu-dian&quot;&gt;三相交流电&lt;&#x2F;h2&gt;
&lt;p&gt;我们家用的 220V 50Hz&lt;sup class=&quot;footnote-reference&quot;&gt;&lt;a href=&quot;#5&quot;&gt;5&lt;&#x2F;a&gt;&lt;&#x2F;sup&gt; 的交流电就是电压有效值为 220V，频率为 50Hz 的三相交流电。（其实是其中的一相）&lt;&#x2F;p&gt;
&lt;h3 id=&quot;ji-yu-shao-kai-shui-de-fa-dian-han-shi-ru-he-fa-dian-de&quot;&gt;（基于烧开水的）发电厂是如何发电的&lt;&#x2F;h3&gt;
&lt;p&gt;一般基于烧开水的发电都是靠的往磁场里装个往死里转的线圈（或者在线圈里装个往死里转的磁体，反正运动是相对的），这线圈其中一头接的称为零线，另一头接的线称为火线。&lt;&#x2F;p&gt;
&lt;p&gt;现在的发电厂会在一个磁场里装三个这样的线圈，这三个线圈之间的角度为120度，发电时就会生成三组相位差为120度的交流电。&lt;&#x2F;p&gt;
&lt;h3 id=&quot;san-xiang-san-xian-zhi&quot;&gt;三相三线制&lt;&#x2F;h3&gt;
&lt;p&gt;我们把发电厂的三个线圈的零线接在一起，研究这跟线上的电流可以发现，三组线圈生成的电流在这跟线上恰好抵消了，也就是说实际上这跟线其实并不过电流，所以输电时可以把这跟线去掉，高压输电时为了节约材料，常采用这种方式供电。&lt;&#x2F;p&gt;
&lt;p&gt;在这种情况下，实际电压有效值是其中两个线圈电压的矢量和的模，如果每相都是220V交流电，那这种方式输电下最终得到的电压有效值就是 380V。&lt;&#x2F;p&gt;
&lt;h3 id=&quot;san-xiang-si-xian-zhi&quot;&gt;三相四线制&lt;&#x2F;h3&gt;
&lt;p&gt;在家庭用电过程中，由于很多电器不想要三相电，而只想要一相电，此时最简单的想法是每个电器直接从一根火线上取电，电器的另一端都接在一起。
但是这样如果三相电每根线上的负载不同，会导致三组线圈生成的电压不再相等，分配到较高电压的负载可能会过压烧毁。&lt;&#x2F;p&gt;
&lt;p&gt;因此三相电在输送给家庭时，会把发电机（如果发电机直接连到家里，这其实不太可能）或者变电站的零线和负载的零线接在一起（通常通过接地）。&lt;&#x2F;p&gt;
&lt;h3 id=&quot;san-xiang-wu-xian-zhi&quot;&gt;三相五线制&lt;&#x2F;h3&gt;
&lt;p&gt;在三相四线制的基础上，再加一个保护地，一般连接用电器的外壳，防止触电。&lt;&#x2F;p&gt;
&lt;p&gt;保护地和零线虽然一般都接地，但不能共用，因为零线是直接通过用电器连接到火线的，平时要过电流，如果零线断路，则零线会直接带上火线的电压，此时如果直接用零线当保护地，那碰一下外壳会非常危险。&lt;&#x2F;p&gt;
&lt;p&gt;而保护地是直接接的地，用电器的外壳带电就会直接从保护地流走，而只有在用 电器外壳带电+保护地接线断路 的情况下才会导致触电，显然比单独的零线断路即会触电更安全。&lt;&#x2F;p&gt;
&lt;div class=&quot;footnote-definition&quot; id=&quot;1&quot;&gt;&lt;sup class=&quot;footnote-definition-label&quot;&gt;1&lt;&#x2F;sup&gt;
&lt;p&gt;假设输入的交流电来自一个恒压源，由于我们假设电路中只有一个元件（电容&#x2F;电感），而元件对电流的阻碍作用恒定，所以这个恒压源同时也是恒流源，同时，由于电路中只有一个元件，电源电压也就是元件两端的电压，下同。&lt;&#x2F;p&gt;
&lt;&#x2F;div&gt;
&lt;div class=&quot;footnote-definition&quot; id=&quot;2&quot;&gt;&lt;sup class=&quot;footnote-definition-label&quot;&gt;2&lt;&#x2F;sup&gt;
&lt;p&gt;&lt;del&gt;列公式讲这些的都是傻逼&lt;&#x2F;del&gt; 直觉只能定性说明变化趋势，如果想知道这个定量公式是怎么来的，还是需要用各种更基础的公式一点点推的，不过真的不是所有人都 care 严密性😄。&lt;&#x2F;p&gt;
&lt;&#x2F;div&gt;
&lt;div class=&quot;footnote-definition&quot; id=&quot;3&quot;&gt;&lt;sup class=&quot;footnote-definition-label&quot;&gt;3&lt;&#x2F;sup&gt;
&lt;p&gt;其实 $2\pi$ 这个系数就是为了调单位的，我也可以发明一种新的单位直接让 $X_C = \frac 1 {fc}$ 让讨厌的 $\pi$ 和三角函数下地狱。&lt;&#x2F;p&gt;
&lt;&#x2F;div&gt;
&lt;div class=&quot;footnote-definition&quot; id=&quot;4&quot;&gt;&lt;sup class=&quot;footnote-definition-label&quot;&gt;4&lt;&#x2F;sup&gt;
&lt;p&gt;&lt;code&gt;todo_list++&lt;&#x2F;code&gt;&lt;&#x2F;p&gt;
&lt;&#x2F;div&gt;
&lt;div class=&quot;footnote-definition&quot; id=&quot;5&quot;&gt;&lt;sup class=&quot;footnote-definition-label&quot;&gt;5&lt;&#x2F;sup&gt;
&lt;p&gt;中国大陆是这个方案，其实供电方案最奇妙的是日本，关东关西频率不一样可还行，日本电工一定很难受。&lt;&#x2F;p&gt;
&lt;&#x2F;div&gt;
</content>
        
    </entry>
    <entry xml:lang="zh">
        <title>电阻阻值为什么这么奇怪</title>
        <published>2022-02-28T22:20:50+00:00</published>
        <updated>2022-02-28T22:20:50+00:00</updated>
        <author>
          <name>Unknown</name>
        </author>
        <link rel="alternate" href="https://longfangsong.github.io/resistor-value/" type="text/html"/>
        <id>https://longfangsong.github.io/resistor-value/</id>
        
        <content type="html">&lt;p&gt;如果你去购买电阻，会发现阻值都非常的奇怪，阻值常常是什么 39, 47, 51 之类的，咋就不取个整数呢？&lt;&#x2F;p&gt;
&lt;h2 id=&quot;dian-zu-de-wu-chai&quot;&gt;电阻的误差&lt;&#x2F;h2&gt;
&lt;p&gt;我们知道因为人类是有极限的，人类造出来的产品也都是有瑕疵的，所以我们人类造出来的电阻也都是有误差的。&lt;&#x2F;p&gt;
&lt;p&gt;以 10% 的误差为例，假如我们造这种电阻，要覆盖从 10 到 100 的整个数轴，那么我们应该制造的电阻阻值应该符合一个公差为 $10^{\frac {1} {12}}$ 指数等比数列。&lt;&#x2F;p&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;数列的值&lt;&#x2F;th&gt;&lt;th&gt;采用值&lt;&#x2F;th&gt;&lt;th&gt;最小&lt;&#x2F;th&gt;&lt;th&gt;最大&lt;&#x2F;th&gt;&lt;&#x2F;tr&gt;&lt;&#x2F;thead&gt;&lt;tbody&gt;
&lt;tr&gt;&lt;td&gt;10&lt;&#x2F;td&gt;&lt;td&gt;10&lt;&#x2F;td&gt;&lt;td&gt;9&lt;&#x2F;td&gt;&lt;td&gt;11&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;12.11527659&lt;&#x2F;td&gt;&lt;td&gt;12&lt;&#x2F;td&gt;&lt;td&gt;10.8&lt;&#x2F;td&gt;&lt;td&gt;13.2&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;14.67799268&lt;&#x2F;td&gt;&lt;td&gt;15&lt;&#x2F;td&gt;&lt;td&gt;13.5&lt;&#x2F;td&gt;&lt;td&gt;16.5&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;17.7827941&lt;&#x2F;td&gt;&lt;td&gt;18&lt;&#x2F;td&gt;&lt;td&gt;16.2&lt;&#x2F;td&gt;&lt;td&gt;19.8&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;21.5443469&lt;&#x2F;td&gt;&lt;td&gt;22&lt;&#x2F;td&gt;&lt;td&gt;19.8&lt;&#x2F;td&gt;&lt;td&gt;24.2&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;26.10157216&lt;&#x2F;td&gt;&lt;td&gt;27&lt;&#x2F;td&gt;&lt;td&gt;24.3&lt;&#x2F;td&gt;&lt;td&gt;29.7&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;31.6227766&lt;&#x2F;td&gt;&lt;td&gt;33&lt;&#x2F;td&gt;&lt;td&gt;29.7&lt;&#x2F;td&gt;&lt;td&gt;36.3&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;38.3118685&lt;&#x2F;td&gt;&lt;td&gt;39&lt;&#x2F;td&gt;&lt;td&gt;35.1&lt;&#x2F;td&gt;&lt;td&gt;42.9&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;46.41588834&lt;&#x2F;td&gt;&lt;td&gt;47&lt;&#x2F;td&gt;&lt;td&gt;42.3&lt;&#x2F;td&gt;&lt;td&gt;51.7&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;56.23413252&lt;&#x2F;td&gt;&lt;td&gt;56&lt;&#x2F;td&gt;&lt;td&gt;50.4&lt;&#x2F;td&gt;&lt;td&gt;61.6&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;68.12920691&lt;&#x2F;td&gt;&lt;td&gt;68&lt;&#x2F;td&gt;&lt;td&gt;61.2&lt;&#x2F;td&gt;&lt;td&gt;74.8&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;82.54041853&lt;&#x2F;td&gt;&lt;td&gt;82&lt;&#x2F;td&gt;&lt;td&gt;73.8&lt;&#x2F;td&gt;&lt;td&gt;90.2&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;100&lt;&#x2F;td&gt;&lt;td&gt;100&lt;&#x2F;td&gt;&lt;td&gt;90&lt;&#x2F;td&gt;&lt;td&gt;110&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;&#x2F;tbody&gt;&lt;&#x2F;table&gt;
&lt;p&gt;这样，如果我们需要某个阻值的一个电阻，我们就能在上述阻值所“负责”的范围内，找到你要的阻值所在的一个。&lt;&#x2F;p&gt;
&lt;p&gt;比如你要一个 70 欧的电阻，发现 68 欧的电阻可以管 61.2 到 74.8 这个范围，所以就用 68 欧的就行了&lt;sup class=&quot;footnote-reference&quot;&gt;&lt;a href=&quot;#1&quot;&gt;1&lt;&#x2F;a&gt;&lt;&#x2F;sup&gt;。&lt;&#x2F;p&gt;
&lt;p&gt;当然，同样的阻值范围可以推广到 1-10 欧、100-1k 欧等等范围，在此不再赘述。&lt;&#x2F;p&gt;
&lt;p&gt;国际上把这种在 用 12 个电阻覆盖从 10 到 100 的整个数轴的电阻标准称为 E12，同理有 E6、E24、E48 等等，分别代表不同精度下覆盖这一个范围需要的电阻数量。&lt;&#x2F;p&gt;
&lt;p&gt;可见，电阻阻值的数字奇怪是为了让电阻在一定精度下覆盖所有可能的阻值。&lt;&#x2F;p&gt;
&lt;h2 id=&quot;biao-zhun-zu-zhi-biao&quot;&gt;标准阻值表&lt;&#x2F;h2&gt;
&lt;table&gt;
    &lt;tbody&gt;
        &lt;tr&gt;
            &lt;th&gt;E6(20%)&lt;&#x2F;th&gt;
            &lt;th&gt;E12(10%)&lt;&#x2F;th&gt;
            &lt;th&gt;E24(5%)&lt;&#x2F;th&gt;
            &lt;th&gt;E48(2%)&lt;&#x2F;th&gt;
        &lt;&#x2F;tr&gt;
        &lt;tr&gt;
            &lt;td rowspan=&quot;8&quot;&gt;100&lt;&#x2F;td&gt;
            &lt;td rowspan=&quot;4&quot;&gt;100&lt;&#x2F;td&gt;
            &lt;td rowspan=&quot;2&quot;&gt;100&lt;&#x2F;td&gt;
            &lt;td rowspan=&quot;1&quot;&gt;100&lt;&#x2F;td&gt;
        &lt;&#x2F;tr&gt;
        &lt;tr&gt;
            &lt;td rowspan=&quot;1&quot;&gt;105&lt;&#x2F;td&gt;
        &lt;&#x2F;tr&gt;
        &lt;tr&gt;
            &lt;td rowspan=&quot;2&quot;&gt;110&lt;&#x2F;td&gt;
            &lt;td rowspan=&quot;1&quot;&gt;110&lt;&#x2F;td&gt;
        &lt;&#x2F;tr&gt;
        &lt;tr&gt;
            &lt;td rowspan=&quot;1&quot;&gt;115&lt;&#x2F;td&gt;
        &lt;&#x2F;tr&gt;
        &lt;tr&gt;
            &lt;td rowspan=&quot;4&quot;&gt;120&lt;&#x2F;td&gt;
            &lt;td rowspan=&quot;2&quot;&gt;120&lt;&#x2F;td&gt;
            &lt;td rowspan=&quot;1&quot;&gt;121&lt;&#x2F;td&gt;
        &lt;&#x2F;tr&gt;
        &lt;tr&gt;
            &lt;td rowspan=&quot;1&quot;&gt;127&lt;&#x2F;td&gt;
        &lt;&#x2F;tr&gt;
        &lt;tr&gt;
            &lt;td rowspan=&quot;2&quot;&gt;130&lt;&#x2F;td&gt;
            &lt;td rowspan=&quot;1&quot;&gt;133&lt;&#x2F;td&gt;
        &lt;&#x2F;tr&gt;
        &lt;tr&gt;
            &lt;td rowspan=&quot;1&quot;&gt;140&lt;&#x2F;td&gt;
        &lt;&#x2F;tr&gt;
        &lt;tr&gt;
            &lt;td rowspan=&quot;8&quot;&gt;150&lt;&#x2F;td&gt;
            &lt;td rowspan=&quot;4&quot;&gt;150&lt;&#x2F;td&gt;
            &lt;td rowspan=&quot;2&quot;&gt;150&lt;&#x2F;td&gt;
            &lt;td rowspan=&quot;1&quot;&gt;147&lt;&#x2F;td&gt;
        &lt;&#x2F;tr&gt;
        &lt;tr&gt;
            &lt;td rowspan=&quot;1&quot;&gt;154&lt;&#x2F;td&gt;
        &lt;&#x2F;tr&gt;
        &lt;tr&gt;
            &lt;td rowspan=&quot;2&quot;&gt;160&lt;&#x2F;td&gt;
            &lt;td rowspan=&quot;1&quot;&gt;162&lt;&#x2F;td&gt;
        &lt;&#x2F;tr&gt;
        &lt;tr&gt;
            &lt;td rowspan=&quot;1&quot;&gt;169&lt;&#x2F;td&gt;
        &lt;&#x2F;tr&gt;
        &lt;tr&gt;
            &lt;td rowspan=&quot;4&quot;&gt;180&lt;&#x2F;td&gt;
            &lt;td rowspan=&quot;2&quot;&gt;180&lt;&#x2F;td&gt;
            &lt;td rowspan=&quot;1&quot;&gt;178&lt;&#x2F;td&gt;
        &lt;&#x2F;tr&gt;
        &lt;tr&gt;
            &lt;td rowspan=&quot;1&quot;&gt;187&lt;&#x2F;td&gt;
        &lt;&#x2F;tr&gt;
        &lt;tr&gt;
            &lt;td rowspan=&quot;2&quot;&gt;200&lt;&#x2F;td&gt;
            &lt;td rowspan=&quot;1&quot;&gt;196&lt;&#x2F;td&gt;
        &lt;&#x2F;tr&gt;
        &lt;tr&gt;
            &lt;td rowspan=&quot;1&quot;&gt;205&lt;&#x2F;td&gt;
        &lt;&#x2F;tr&gt;
        &lt;tr&gt;
            &lt;td rowspan=&quot;8&quot;&gt;220&lt;&#x2F;td&gt;
            &lt;td rowspan=&quot;4&quot;&gt;220&lt;&#x2F;td&gt;
            &lt;td rowspan=&quot;2&quot;&gt;220&lt;&#x2F;td&gt;
            &lt;td rowspan=&quot;1&quot;&gt;215&lt;&#x2F;td&gt;
        &lt;&#x2F;tr&gt;
        &lt;tr&gt;
            &lt;td rowspan=&quot;1&quot;&gt;226&lt;&#x2F;td&gt;
        &lt;&#x2F;tr&gt;
        &lt;tr&gt;
            &lt;td rowspan=&quot;2&quot;&gt;240&lt;&#x2F;td&gt;
            &lt;td rowspan=&quot;1&quot;&gt;237&lt;&#x2F;td&gt;
        &lt;&#x2F;tr&gt;
        &lt;tr&gt;
            &lt;td rowspan=&quot;1&quot;&gt;249&lt;&#x2F;td&gt;
        &lt;&#x2F;tr&gt;
        &lt;tr&gt;
            &lt;td rowspan=&quot;4&quot;&gt;270&lt;&#x2F;td&gt;
            &lt;td rowspan=&quot;2&quot;&gt;270&lt;&#x2F;td&gt;
            &lt;td rowspan=&quot;1&quot;&gt;261&lt;&#x2F;td&gt;
        &lt;&#x2F;tr&gt;
        &lt;tr&gt;
            &lt;td rowspan=&quot;1&quot;&gt;274&lt;&#x2F;td&gt;
        &lt;&#x2F;tr&gt;
        &lt;tr&gt;
            &lt;td rowspan=&quot;2&quot;&gt;300&lt;&#x2F;td&gt;
            &lt;td rowspan=&quot;1&quot;&gt;287&lt;&#x2F;td&gt;
        &lt;&#x2F;tr&gt;
        &lt;tr&gt;
            &lt;td rowspan=&quot;1&quot;&gt;301&lt;&#x2F;td&gt;
        &lt;&#x2F;tr&gt;
        &lt;tr&gt;
            &lt;td rowspan=&quot;8&quot;&gt;330&lt;&#x2F;td&gt;
            &lt;td rowspan=&quot;4&quot;&gt;330&lt;&#x2F;td&gt;
            &lt;td rowspan=&quot;2&quot;&gt;330&lt;&#x2F;td&gt;
            &lt;td rowspan=&quot;1&quot;&gt;316&lt;&#x2F;td&gt;
        &lt;&#x2F;tr&gt;
        &lt;tr&gt;
            &lt;td rowspan=&quot;1&quot;&gt;332&lt;&#x2F;td&gt;
        &lt;&#x2F;tr&gt;
        &lt;tr&gt;
            &lt;td rowspan=&quot;2&quot;&gt;360&lt;&#x2F;td&gt;
            &lt;td rowspan=&quot;1&quot;&gt;348&lt;&#x2F;td&gt;
        &lt;&#x2F;tr&gt;
        &lt;tr&gt;
            &lt;td rowspan=&quot;1&quot;&gt;365&lt;&#x2F;td&gt;
        &lt;&#x2F;tr&gt;
        &lt;tr&gt;
            &lt;td rowspan=&quot;4&quot;&gt;390&lt;&#x2F;td&gt;
            &lt;td rowspan=&quot;2&quot;&gt;390&lt;&#x2F;td&gt;
            &lt;td rowspan=&quot;1&quot;&gt;383&lt;&#x2F;td&gt;
        &lt;&#x2F;tr&gt;
        &lt;tr&gt;
            &lt;td rowspan=&quot;1&quot;&gt;402&lt;&#x2F;td&gt;
        &lt;&#x2F;tr&gt;
        &lt;tr&gt;
            &lt;td rowspan=&quot;2&quot;&gt;430&lt;&#x2F;td&gt;
            &lt;td rowspan=&quot;1&quot;&gt;422&lt;&#x2F;td&gt;
        &lt;&#x2F;tr&gt;
        &lt;tr&gt;
            &lt;td rowspan=&quot;1&quot;&gt;442&lt;&#x2F;td&gt;
        &lt;&#x2F;tr&gt;
        &lt;tr&gt;
            &lt;td rowspan=&quot;8&quot;&gt;470&lt;&#x2F;td&gt;
            &lt;td rowspan=&quot;4&quot;&gt;470&lt;&#x2F;td&gt;
            &lt;td rowspan=&quot;2&quot;&gt;470&lt;&#x2F;td&gt;
            &lt;td rowspan=&quot;1&quot;&gt;464&lt;&#x2F;td&gt;
        &lt;&#x2F;tr&gt;
        &lt;tr&gt;
            &lt;td rowspan=&quot;1&quot;&gt;487&lt;&#x2F;td&gt;
        &lt;&#x2F;tr&gt;
        &lt;tr&gt;
            &lt;td rowspan=&quot;2&quot;&gt;510&lt;&#x2F;td&gt;
            &lt;td rowspan=&quot;1&quot;&gt;511&lt;&#x2F;td&gt;
        &lt;&#x2F;tr&gt;
        &lt;tr&gt;
            &lt;td rowspan=&quot;1&quot;&gt;536&lt;&#x2F;td&gt;
        &lt;&#x2F;tr&gt;
        &lt;tr&gt;
            &lt;td rowspan=&quot;4&quot;&gt;560&lt;&#x2F;td&gt;
            &lt;td rowspan=&quot;2&quot;&gt;560&lt;&#x2F;td&gt;
            &lt;td rowspan=&quot;1&quot;&gt;562&lt;&#x2F;td&gt;
        &lt;&#x2F;tr&gt;
        &lt;tr&gt;
            &lt;td rowspan=&quot;1&quot;&gt;590&lt;&#x2F;td&gt;
        &lt;&#x2F;tr&gt;
        &lt;tr&gt;
            &lt;td rowspan=&quot;2&quot;&gt;620&lt;&#x2F;td&gt;
            &lt;td rowspan=&quot;1&quot;&gt;619&lt;&#x2F;td&gt;
        &lt;&#x2F;tr&gt;
        &lt;tr&gt;
            &lt;td rowspan=&quot;1&quot;&gt;649&lt;&#x2F;td&gt;
        &lt;&#x2F;tr&gt;
        &lt;tr&gt;
            &lt;td rowspan=&quot;8&quot;&gt;680&lt;&#x2F;td&gt;
            &lt;td rowspan=&quot;4&quot;&gt;680&lt;&#x2F;td&gt;
            &lt;td rowspan=&quot;2&quot;&gt;680&lt;&#x2F;td&gt;
            &lt;td rowspan=&quot;1&quot;&gt;681&lt;&#x2F;td&gt;
        &lt;&#x2F;tr&gt;
        &lt;tr&gt;
            &lt;td rowspan=&quot;1&quot;&gt;715&lt;&#x2F;td&gt;
        &lt;&#x2F;tr&gt;
        &lt;tr&gt;
            &lt;td rowspan=&quot;2&quot;&gt;750&lt;&#x2F;td&gt;
            &lt;td rowspan=&quot;1&quot;&gt;750&lt;&#x2F;td&gt;
        &lt;&#x2F;tr&gt;
        &lt;tr&gt;
            &lt;td rowspan=&quot;1&quot;&gt;787&lt;&#x2F;td&gt;
        &lt;&#x2F;tr&gt;
        &lt;tr&gt;
            &lt;td rowspan=&quot;4&quot;&gt;820&lt;&#x2F;td&gt;
            &lt;td rowspan=&quot;2&quot;&gt;820&lt;&#x2F;td&gt;
            &lt;td rowspan=&quot;1&quot;&gt;825&lt;&#x2F;td&gt;
        &lt;&#x2F;tr&gt;
        &lt;tr&gt;
            &lt;td rowspan=&quot;1&quot;&gt;866&lt;&#x2F;td&gt;
        &lt;&#x2F;tr&gt;
        &lt;tr&gt;
            &lt;td rowspan=&quot;2&quot;&gt;910&lt;&#x2F;td&gt;
            &lt;td rowspan=&quot;1&quot;&gt;909&lt;&#x2F;td&gt;
        &lt;&#x2F;tr&gt;
        &lt;tr&gt;
            &lt;td rowspan=&quot;1&quot;&gt;953&lt;&#x2F;td&gt;
        &lt;&#x2F;tr&gt;
    &lt;&#x2F;tbody&gt;
&lt;&#x2F;table&gt;
&lt;h2 id=&quot;cou-dian-zu-gong-ju&quot;&gt;凑电阻工具&lt;&#x2F;h2&gt;
&lt;h3 id=&quot;shu-ru&quot;&gt;输入&lt;&#x2F;h3&gt;
&lt;p&gt;你手上有的电阻&lt;sup class=&quot;footnote-reference&quot;&gt;&lt;a href=&quot;#2&quot;&gt;2&lt;&#x2F;a&gt;&lt;&#x2F;sup&gt;:&lt;&#x2F;p&gt;
&lt;div id=&quot;current_have_resistors&quot;&gt;&lt;&#x2F;div&gt;
&lt;p&gt;计算公式：&lt;input id=&quot;func&quot; class=&quot;requirements&quot; type=&quot;text&quot; style=&quot;width: 10em&quot;&gt;&lt;&#x2F;input&gt;=&lt;input id=&quot;expected-result&quot; class=&quot;requirements&quot; type=&quot;text&quot; style=&quot;width: 4em&quot;&gt;&lt;&#x2F;input&gt;&lt;&#x2F;p&gt;
&lt;h3 id=&quot;shu-chu&quot;&gt;输出&lt;&#x2F;h3&gt;
&lt;p&gt;选择电阻：&lt;&#x2F;p&gt;
&lt;table id=&quot;solution&quot;&gt;
    &lt;thead&gt;
    &lt;tr id=&quot;solution-header&quot;&gt;
        &lt;th id=&quot;solution-header-avg&quot;&gt;均值&lt;&#x2F;th&gt;
        &lt;th&gt;均值差值&lt;&#x2F;th&gt;
        &lt;th&gt;均值差值百分比&lt;&#x2F;th&gt;
        &lt;th&gt;最小值&lt;&#x2F;th&gt;
        &lt;th&gt;最小值差值&lt;&#x2F;th&gt;
        &lt;th&gt;最小值差值百分比&lt;&#x2F;th&gt;
        &lt;th&gt;最大值&lt;&#x2F;th&gt;
        &lt;th&gt;最大值差值&lt;&#x2F;th&gt;
        &lt;th&gt;最大值差值百分比&lt;&#x2F;th&gt;
    &lt;&#x2F;tr&gt;
    &lt;&#x2F;thead&gt;
    &lt;tbody id=&quot;solution-body&quot;&gt;
    &lt;&#x2F;tbody&gt;
&lt;&#x2F;table&gt;
&lt;script&gt;
let current_have_resistors = [];

function parseInput(input) {
    if (input.endsWith(&#x27;k&#x27;) || input.endsWith(&#x27;K&#x27;)) {
        return parseFloat(input.slice(0, -1)) * 1000;
    } else if (input.endsWith(&#x27;m&#x27;) || input.endsWith(&#x27;M&#x27;)) {
        return parseFloat(input.slice(0, -1)) * 1000000;
    } else {
        return parseFloat(input);
    }
}

function resistorToString(input) {
    if (input &gt;= 1000000) {
        return input &#x2F; 1000000 + &#x27;M&#x27;;
    } else if (input &gt;= 1000) {
        return input &#x2F; 1000 + &#x27;k&#x27;;
    } else {
        return input;
    }
}

function registerHandlingFunction() {
    document.getElementById(&#x27;add&#x27;).onclick = () =&gt; {
        let add_html = document.createElement(&quot;span&quot;);
        add_html.innerHTML = `&lt;input style=&quot;width: 3em&quot; id=&quot;value&quot;&gt;&lt;&#x2F;input&gt;Ω&amp;nbsp;&lt;input style=&quot;width: 3em&quot; id=&quot;precision&quot;&gt;&lt;&#x2F;input&gt;%&lt;button id=&quot;do-add&quot;&gt;ok&lt;&#x2F;button&gt;`;
        document.getElementById(&#x27;current_have_resistors&#x27;).replaceChild(add_html, document.getElementById(&#x27;add&#x27;));

        document.getElementById(&#x27;do-add&#x27;).onclick = () =&gt; {
            let valueStr = document.getElementById(&#x27;value&#x27;).value;
            let precisionStr = document.getElementById(&#x27;precision&#x27;).value;
            let value = parseInput(valueStr);
            let precision = parseInput(precisionStr);
            current_have_resistors.push({
                value: value, 
                precision: precision,
                min: value * (1-precision&#x2F;100),
                max: value * (1+precision&#x2F;100)
            });
            current_have_resistors.sort((a, b) =&gt; a.value - b.value);
            localStorage.setItem(&#x27;current_have_resistors&#x27;, JSON.stringify(current_have_resistors));
            renderCurrentHaveResistors();
        }
    }
    for(let element of document.getElementsByClassName(&#x27;remove-resistor&#x27;)) {
        element.onclick = (e) =&gt; {
            let id = parseInt(e.target.id.slice(7));
            current_have_resistors.splice(id, 1);
            localStorage.setItem(&#x27;current_have_resistors&#x27;, JSON.stringify(current_have_resistors));
            renderCurrentHaveResistors();
        }
    }
    for(let element of document.getElementsByClassName(&#x27;requirements&#x27;)) {
        element.onkeyup = () =&gt; {
            let func = document.getElementById(&#x27;func&#x27;).value;
            let expectedResult = parseInput(document.getElementById(&#x27;expected-result&#x27;).value);
            let problem = parseProblem(func, expectedResult);
            if(problem.params.length !== 0) {
                let result = solve(problem);
                renderSolution(problem, result);
            }
        }
    }
}

function renderCurrentHaveResistors() {
    let html = &#x27;&#x27;;
    for (let i = 0; i &lt; current_have_resistors.length; i++) {
        html += `&lt;div class=&quot;current-have-resistors-row&quot;&gt;&lt;span&gt;${resistorToString(current_have_resistors[i].value)}Ω&lt;&#x2F;span&gt;&lt;span&gt;${current_have_resistors[i].precision}%&lt;&#x2F;span&gt;&lt;button id=&quot;remove-${i}&quot; class=&quot;remove-resistor&quot;&gt;x&lt;&#x2F;button&gt;&lt;&#x2F;div&gt;`;
    }
    html += `&lt;button id=&quot;add&quot;&gt;+&lt;&#x2F;button&gt;`;
    document.getElementById(&#x27;current_have_resistors&#x27;).innerHTML = html;
    registerHandlingFunction();
}

function loadCurrentHave() {
    let current_have_resistors_str = localStorage.getItem(&#x27;current_have_resistors&#x27;);
    if (current_have_resistors_str === null) {
        current_have_resistors = [];
    } else {
        current_have_resistors = JSON.parse(current_have_resistors_str);
        for(let current_have_resistor of current_have_resistors) {
            current_have_resistor.min = current_have_resistor.value * (1-current_have_resistor.precision&#x2F;100);
            current_have_resistor.max = current_have_resistor.value * (1+current_have_resistor.precision&#x2F;100);
        }
    }
    renderCurrentHaveResistors();
}

function renderSolution(problem, solutions) {
    let extraHeaderHTML = &#x27;&#x27;;
    let parentNode = document.getElementById(&#x27;solution-header&#x27;);
    let firstChild = parentNode.firstChild;
    while(firstChild.id !== &#x27;solution-header-avg&#x27;) {
        parentNode.removeChild(firstChild);
        firstChild = parentNode.firstChild;
    }
    let refNode = document.getElementById(&#x27;solution-header-avg&#x27;);
    for(let param of problem.params) {
        let newHeader = document.createElement(&quot;th&quot;);
        newHeader.innerHTML = `${param}`;
        parentNode.insertBefore(newHeader, refNode);
    }

    let html = &#x27;&#x27;;
    for (let solution of solutions) {
        let solutionHTML = &#x27;&#x27;;
        for(let s of solution.selected) {
            solutionHTML += `&lt;td&gt;${resistorToString(current_have_resistors[s].value)}&lt;&#x2F;td&gt;`;
        }
        html += `
        &lt;tr&gt;
            ${solutionHTML}
            &lt;td&gt;${solution.avg.toFixed(6)}&lt;&#x2F;td&gt;
            &lt;td&gt;${Math.abs(solution.avg - problem.value).toFixed(6)}&lt;&#x2F;td&gt;
            &lt;td&gt;${Math.abs((solution.avg - problem.value)&#x2F;problem.value*100).toFixed(4)}%&lt;&#x2F;td&gt;
            &lt;td&gt;${solution.min.toFixed(6)}&lt;&#x2F;td&gt;
            &lt;td&gt;${Math.abs(solution.min - problem.value).toFixed(6)}&lt;&#x2F;td&gt;
            &lt;td&gt;${Math.abs((solution.min - problem.value)&#x2F;problem.value*100).toFixed(4)}%&lt;&#x2F;td&gt;
            &lt;td&gt;${solution.max.toFixed(6)}&lt;&#x2F;td&gt;
            &lt;td&gt;${Math.abs(solution.max - problem.value).toFixed(6)}&lt;&#x2F;td&gt;
            &lt;td&gt;${Math.abs((solution.max - problem.value)&#x2F;problem.value*100).toFixed(4)}%&lt;&#x2F;td&gt;
        &lt;&#x2F;tr&gt;
    `;
    }
    document.getElementById(&#x27;solution-body&#x27;).innerHTML = html;
}

function minMaxIndexes(indexes, minMaxes) {
    let result = [];
    for (let i = 0; i &lt; indexes.length; ++i) {
        let index = indexes[i];
        let minMax = minMaxes[i];
        if(minMax === 0) {
            value = current_have_resistors[index].min;
        } else {
            value = current_have_resistors[index].max;
        }
        result.push(value);
    }
    return result;
}

function arrayIndexes(array, indexes) {
    let result = [];
    for (let i = 0; i &lt; indexes.length; i++) {
        result.push(array[indexes[i]]);
    }
    return result;
}

function parseProblem(func, value) {
    let paramsSet = new Set();
    const paramRegexp = &#x2F;[a-zA-Z]\w*&#x2F;g;
    &#x2F;&#x2F; todo: use matchAll
    let match = paramRegexp.exec(func);
    while (match !== null) {
        let paramName = match[0];
        paramsSet.add(paramName);
        match = paramRegexp.exec(func);
    }
    let params = [...paramsSet];
    let funcF = new Function(...params, `return ${func};`);
    return {params: params, funcF: funcF, value: value};
}

function compareSolution(value) {
    return (a, b) =&gt; {
        let avgDiffA = Math.abs(a.avg-value);
        let avgDiffB = Math.abs(b.avg-value);
        if(avgDiffA - avgDiffB &lt; -0.00001) {
            return -1;
        } else if (avgDiffA - avgDiffB &gt; 0.00001) {
            return 1;
        } else {
            let minMaxDiffA = Math.abs(a.min-value) + Math.abs(a.max-value);
            let minMaxDiffB = Math.abs(b.min-value) + Math.abs(b.max-value);
            if(minMaxDiffA - minMaxDiffB &lt; -0.00001) {
                return -1;
            } else if (minMaxDiffA - minMaxDiffB &gt; 0.00001) {
                return 1;
            } else {
                let useResistorSumA = a.selected.reduce((a,b) =&gt; a+b);
                let useResistorSumB = b.selected.reduce((a,b) =&gt; a+b);
                return useResistorSumB - useResistorSumA;
            }
        }
    }
}
    

function solve(problem) {
    let params = problem.params;
    let funcF = problem.funcF;
    let value = problem.value;
    let compareSolutionF = compareSolution(value);
    let results = [];
    let currentSelectedIndexes = [];
    for (let i = 0; i &lt; params.length; i++) {
        currentSelectedIndexes.push(0);
    }
    let exit = false;
    &#x2F;&#x2F; 0: min, 1: max
    let minMax = [];
    for (let i = 0; i &lt; params.length; i++) {
        minMax.push(0);
    }
    while(!exit) {
        for (let i = 0; i &lt; params.length; i++) {
            minMax[i] = 0;
        }
        &#x2F;&#x2F; eval
        let exitInner = false;
        let currentResultMax = null;
        let currentResultMin = null;
        while(!exitInner) {
            let currentResult = funcF(...minMaxIndexes(currentSelectedIndexes, minMax));
            if(currentResultMax === null || currentResult &gt; currentResultMax) {
                currentResultMax = currentResult;
            }
            if(currentResultMin === null || currentResult &lt; currentResultMin) {
                currentResultMin = currentResult;
            }
            minMax[0]++;
            let carring = 0;
            while(minMax[carring] &gt; 1) {
                minMax[carring] = 0;
                carring++;
                if(carring &gt;= params.length) {
                    exitInner = true;
                    break;
                }
                minMax[carring]++;
            }
        }
        let currentResultAvg = funcF(...arrayIndexes(current_have_resistors, currentSelectedIndexes).map(it =&gt; it.value));
        let currentSolution = {selected: [...currentSelectedIndexes], avg: currentResultAvg, min: currentResultMin, max: currentResultMax};
        if(results.length &lt; 9) {
            results.push(currentSolution);
        } else if (results.length === 9) {
            results.push(currentSolution);
            results.sort(compareSolutionF);
        } else {
            for (let i = 0; i &lt; results.length; i++) {
                if(compareSolutionF(currentSolution, results[i]) &lt; 0) {
                    results.splice(i, 0, currentSolution);
                    results.pop();
                    break;
                }
            }
        }
        currentSelectedIndexes[0]++;
        let carring = 0;
        exit = false;
        while(currentSelectedIndexes[carring] &gt;= current_have_resistors.length) {
            currentSelectedIndexes[carring] = 0;
            carring++;
            if (carring &gt;= currentSelectedIndexes.length) {
                exit = true;
                break;
            }
            currentSelectedIndexes[carring]++;
        }
    }
    return results;
}

loadCurrentHave();
document.getElementById(&#x27;func&#x27;).value = &#x27;&#x27;;
document.getElementById(&#x27;expected-result&#x27;).value = &#x27;&#x27;;
&lt;&#x2F;script&gt;
&lt;style&gt;
.current-have-resistors-row {
    width: 128px;
    justify-content: space-between;
    display: flex;
    border-top: solid #ddd 1px;
}
.current-have-resistors-row &gt; span {
    text-align: center;
    width: 24px;
}
#add {
    width: 128px;
}
&lt;&#x2F;style&gt;
&lt;div class=&quot;footnote-definition&quot; id=&quot;1&quot;&gt;&lt;sup class=&quot;footnote-definition-label&quot;&gt;1&lt;&#x2F;sup&gt;
&lt;p&gt;一般来说要求的电阻也是一个范围，如果你需要更精确的控制，可以用更精确的电阻。这里再加一个同样精度的 1.8 欧电阻用处没那么大，这只是把可能的阻值范围变为 62.82 到 76.78 欧这个范围，并没有比原来好多少，甚至误差范围还变大了。当然，如果是用几个电阻的比值就另当别论了。&lt;&#x2F;p&gt;
&lt;&#x2F;div&gt;
&lt;div class=&quot;footnote-definition&quot; id=&quot;2&quot;&gt;&lt;sup class=&quot;footnote-definition-label&quot;&gt;2&lt;&#x2F;sup&gt;
&lt;p&gt;这些数据持久化在你的浏览器的 local storage 里面，只要不清缓存，下次打开该页面也有效。&lt;&#x2F;p&gt;
&lt;&#x2F;div&gt;
</content>
        
    </entry>
    <entry xml:lang="zh">
        <title>Contention-Aware Lock Scheduling 和 （b）LDSF 算法</title>
        <published>2022-02-08T14:56:30+00:00</published>
        <updated>2022-02-08T14:56:30+00:00</updated>
        <author>
          <name>Unknown</name>
        </author>
        <link rel="alternate" href="https://longfangsong.github.io/contention-aware-lock-scheduling/" type="text/html"/>
        <id>https://longfangsong.github.io/contention-aware-lock-scheduling/</id>
        
        <content type="html">&lt;script src=&quot;&#x2F;&#x2F;d3js.org&#x2F;d3.v5.min.js&quot;&gt;&lt;&#x2F;script&gt;
&lt;script src=&quot;https:&#x2F;&#x2F;unpkg.com&#x2F;@hpcc-js&#x2F;wasm@0.3.11&#x2F;dist&#x2F;index.min.js&quot;&gt;&lt;&#x2F;script&gt;
&lt;script src=&quot;https:&#x2F;&#x2F;unpkg.com&#x2F;d3-graphviz@3.0.5&#x2F;build&#x2F;d3-graphviz.js&quot;&gt;&lt;&#x2F;script&gt;
&lt;h2 id=&quot;ji-ben-mo-xing&quot;&gt;基本模型&lt;&#x2F;h2&gt;
&lt;p&gt;论文里是一个高度形式化&lt;sup class=&quot;footnote-reference&quot;&gt;&lt;a href=&quot;#1&quot;&gt;1&lt;&#x2F;a&gt;&lt;&#x2F;sup&gt;的模型，容易看得头大，然后图形表示里箭头指向的含义也很奇怪……&lt;sup class=&quot;footnote-reference&quot;&gt;&lt;a href=&quot;#2&quot;&gt;2&lt;&#x2F;a&gt;&lt;&#x2F;sup&gt;，其实主体就是一个 trival 的事务的等待关系图，我把这模型稍微改了下应该会比较好理解。&lt;&#x2F;p&gt;
&lt;h3 id=&quot;deng-dai-guan-xi-tu&quot;&gt;等待关系图&lt;&#x2F;h3&gt;
&lt;h4 id=&quot;jie-dian&quot;&gt;节点&lt;&#x2F;h4&gt;
&lt;h5 id=&quot;dui-xiang&quot;&gt;对象&lt;&#x2F;h5&gt;
&lt;p&gt;指可以被事务锁定的资源，用圆圈表示。&lt;&#x2F;p&gt;
&lt;div id=&quot;graph-object&quot;&gt;&lt;&#x2F;div&gt;
&lt;script&gt;
d3.select(&quot;#graph-object&quot;).graphviz()
    .renderDot(&#x27;digraph  {a[label=&quot;&quot;, shape=&quot;circle&quot;]}&#x27;);
&lt;&#x2F;script&gt;
&lt;h5 id=&quot;shi-wu&quot;&gt;事务&lt;&#x2F;h5&gt;
&lt;p&gt;就是通常理解的事务，用圆角矩形表示。&lt;&#x2F;p&gt;
&lt;div id=&quot;graph-txn&quot;&gt;&lt;&#x2F;div&gt;
&lt;script&gt;
d3.select(&quot;#graph-txn&quot;).graphviz()
    .renderDot(&#x27;digraph  {a[label=&quot;&quot;, shape=&quot;Mrecord&quot;]}&#x27;);
&lt;&#x2F;script&gt;
&lt;h4 id=&quot;bian&quot;&gt;边&lt;&#x2F;h4&gt;
&lt;h5 id=&quot;chi-suo&quot;&gt;持锁&lt;&#x2F;h5&gt;
&lt;p&gt;事务指向对象的实线箭头指事务锁定了这个对象。&lt;&#x2F;p&gt;
&lt;div id=&quot;graph-txn-lock-object&quot;&gt;&lt;&#x2F;div&gt;
&lt;script&gt;
d3.select(&quot;#graph-txn-lock-object&quot;).graphviz()
    .renderDot(&#x27;digraph {b[label=&quot;&quot;, shape=&quot;circle&quot;]; a[label=&quot;&quot;, shape=&quot;Mrecord&quot;]; a-&gt;b;}&#x27;);
&lt;&#x2F;script&gt;
&lt;div id=&quot;graph-txn&quot;&gt;&lt;&#x2F;div&gt;
&lt;script&gt;
d3.select(&quot;#graph-txn&quot;).graphviz()
    .renderDot(&#x27;digraph  {a[label=&quot;&quot;, shape=&quot;Mrecord&quot;]}&#x27;);
&lt;&#x2F;script&gt;
&lt;h5 id=&quot;deng-suo&quot;&gt;等锁&lt;&#x2F;h5&gt;
&lt;p&gt;事务指向对象的虚线箭头指事务等待锁定这个对象。&lt;&#x2F;p&gt;
&lt;div id=&quot;graph-txn-wait-object&quot;&gt;&lt;&#x2F;div&gt;
&lt;script&gt;
d3.select(&quot;#graph-txn-wait-object&quot;).graphviz()
    .renderDot(&#x27;digraph {b[label=&quot;&quot;, shape=&quot;circle&quot;]; a[label=&quot;&quot;, shape=&quot;Mrecord&quot;]; a-&gt;b[style=&quot;dashed&quot;];}&#x27;);
&lt;&#x2F;script&gt;
&lt;h5 id=&quot;gong-xiang-suo-he-pai-ta-suo&quot;&gt;共享锁和排他锁&lt;&#x2F;h5&gt;
&lt;p&gt;在对应的边上写 X 或者 S。&lt;&#x2F;p&gt;
&lt;div id=&quot;graph-lock-type&quot;&gt;&lt;&#x2F;div&gt;
&lt;script&gt;
d3.select(&quot;#graph-lock-type&quot;).graphviz()
    .renderDot(&#x27;digraph {b[label=&quot;&quot;, shape=&quot;circle&quot;]; a[label=&quot;&quot;, shape=&quot;Mrecord&quot;]; a-&gt;b[style=&quot;dashed&quot;, label=&quot;X&quot;];d[label=&quot;&quot;, shape=&quot;circle&quot;]; c[label=&quot;&quot;, shape=&quot;Mrecord&quot;]; c-&gt;d[label=&quot;S&quot;];}&#x27;);
&lt;&#x2F;script&gt;
&lt;h3 id=&quot;mu-biao&quot;&gt;目标&lt;&#x2F;h3&gt;
&lt;p&gt;目标就是找到一个算法，让所有事务的总运行时间的期望值最短。&lt;&#x2F;p&gt;
&lt;p&gt;由于共享锁的存在，这样的算法是 NP 难的（具体见原论文的参考文献）。&lt;&#x2F;p&gt;
&lt;p&gt;因此这篇论文提出了一个近似算法。&lt;&#x2F;p&gt;
&lt;h2 id=&quot;ldsf-suan-fa&quot;&gt;LDSF 算法&lt;&#x2F;h2&gt;
&lt;p&gt;基本思想就是让（现在） block 了更多其他事务的事务先拿到锁。&lt;&#x2F;p&gt;
&lt;p&gt;例如下面的等待关系图：&lt;&#x2F;p&gt;
&lt;pre id=&quot;graph-1-content&quot;&gt;
digraph {
    O1[label=&quot;O1&quot;, shape=&quot;circle&quot;];
    t1 -&gt; O1[label=&quot;X&quot;,style=&quot;dashed&quot;];
    t2 -&gt; O1[label=&quot;X&quot;,style=&quot;dashed&quot;];
    subgraph cluster_t1 {
        label = &quot;t1&quot;;
        t1[label=&quot;t1&quot;, shape=&quot;Mrecord&quot;];

        O2[label=&quot;O2&quot;, shape=&quot;circle&quot;];
        O3[label=&quot;O3&quot;, shape=&quot;circle&quot;];
        O4[label=&quot;O4&quot;, shape=&quot;circle&quot;];
        t1 -&gt; O2;
        t1 -&gt; O3;
        t1 -&gt; O4;

        t3[label=&quot;t3&quot;, shape=&quot;Mrecord&quot;];
        t4[label=&quot;t4&quot;, shape=&quot;Mrecord&quot;];
        t5[label=&quot;t5&quot;, shape=&quot;Mrecord&quot;];
        t6[label=&quot;t6&quot;, shape=&quot;Mrecord&quot;];
    
        t3 -&gt; O2[label=&quot;&quot;,style=&quot;dashed&quot;];
        t4 -&gt; O2[label=&quot;&quot;,style=&quot;dashed&quot;];
        t4 -&gt; O3[label=&quot;&quot;,style=&quot;dashed&quot;];
        t5 -&gt; O4[label=&quot;&quot;,style=&quot;dashed&quot;];
        t6 -&gt; O4[label=&quot;&quot;,style=&quot;dashed&quot;];
    }

    subgraph cluster_t2 {
        label = &quot;t2&quot;;
        t2[label=&quot;t2&quot;, shape=&quot;Mrecord&quot;];
        O5[label=&quot;O5&quot;, shape=&quot;circle&quot;];
        O6[label=&quot;O6&quot;, shape=&quot;circle&quot;];
        t2 -&gt; O5;
        t2 -&gt; O6;

        t7[label=&quot;t7&quot;, shape=&quot;Mrecord&quot;];
        t8[label=&quot;t8&quot;, shape=&quot;Mrecord&quot;];
        t9[label=&quot;t9&quot;, shape=&quot;Mrecord&quot;];

        t7 -&gt; O5[label=&quot;&quot;,style=&quot;dashed&quot;];
        t8 -&gt; O6[label=&quot;&quot;,style=&quot;dashed&quot;];
        t9 -&gt; O6[label=&quot;&quot;,style=&quot;dashed&quot;];

        O7[label=&quot;O7&quot;, shape=&quot;circle&quot;];
        O8[label=&quot;O8&quot;, shape=&quot;circle&quot;];
        O9[label=&quot;O9&quot;, shape=&quot;circle&quot;];

        t7 -&gt; O7[label=&quot;&quot;,style=&quot;dashed&quot;];
        t7 -&gt; O8[label=&quot;&quot;,style=&quot;dashed&quot;];
        t8 -&gt; O9[label=&quot;&quot;,style=&quot;dashed&quot;];
        t9 -&gt; O9[label=&quot;&quot;,style=&quot;dashed&quot;];
    }
}
&lt;&#x2F;pre&gt;
&lt;div id=&quot;graph-1&quot;&gt;&lt;&#x2F;div&gt;
&lt;script&gt;
const content = document.getElementById(&quot;graph-1-content&quot;).innerHTML.replaceAll(&quot;&amp;gt;&quot;, &quot;&gt;&quot;);
document.getElementById(&quot;graph-1-content&quot;).innerHTML = &quot;&quot;;
console.log(content);
d3.select(&quot;#graph-1&quot;).graphviz()
    .renderDot(content);
&lt;&#x2F;script&gt;
&lt;p&gt;上一个锁定 O1 的事务已经完成，现在希望锁定 O1 的事务有 t1 和 t2。&lt;&#x2F;p&gt;
&lt;p&gt;观察等待关系图可以发现, t1 已经 block 了 t3-t6 共 4 个事务，而 t2 只 block 了 3 个事务，因此我们的算法会让 t1 先持有这个锁。&lt;&#x2F;p&gt;
&lt;p&gt;我们定义某个事务的“依赖集合”为其所有的直接或间接阻塞的事务（包含其本身）。&lt;&#x2F;p&gt;
&lt;h3 id=&quot;you-xian-ji-de-ji-suan&quot;&gt;优先级的计算&lt;&#x2F;h3&gt;
&lt;h4 id=&quot;yao-jia-pai-ta-suo-de-shi-wu&quot;&gt;要加排他锁的事务&lt;&#x2F;h4&gt;
&lt;p&gt;LDSF 算法中，要加排他锁的事务的优先级是其依赖集合的大小。&lt;&#x2F;p&gt;
&lt;h4 id=&quot;yao-jia-gong-xiang-suo-de-shi-wu&quot;&gt;要加共享锁的事务&lt;&#x2F;h4&gt;
&lt;p&gt;由于共享锁是“共享”的，出于方便考虑 LDSF 算法会一次性让所有要加共享锁的事务拿到锁。因此，要加共享锁的事务整体的优先级就是所有要加共享锁的事务的依赖集合的并集的大小。&lt;&#x2F;p&gt;
&lt;p&gt;LDSF 会让优先级最高（大）的事务（或者事务集合，如果是共享锁的话）成功加上锁。&lt;&#x2F;p&gt;
&lt;h2 id=&quot;gai-jin-bldsf-suan-fa&quot;&gt;改进：bLDSF 算法&lt;&#x2F;h2&gt;
&lt;p&gt;LDSF 算法一次性让所有要加共享锁的事务拿到锁，如果有其中某个事务长期持有某个资源上的共享锁，而其他事务在等着锁定这个资源，系统整体的效率会变得很烂。&lt;&#x2F;p&gt;
&lt;p&gt;例如：&lt;&#x2F;p&gt;
&lt;pre id=&quot;graph-2-content&quot;&gt;
digraph {
    O[label=&quot;O&quot;, shape=&quot;circle&quot;];
    t1 -&gt; O[label=&quot;S&quot;,style=&quot;dashed&quot;];
    t2 -&gt; O[label=&quot;S&quot;,style=&quot;dashed&quot;];
    t3 -&gt; O[label=&quot;S&quot;,style=&quot;dashed&quot;];
    t4 -&gt; O[label=&quot;X&quot;,style=&quot;dashed&quot;];
    subgraph cluster_t1 {
        label = &quot;t1, size=6&quot;;
        t1[label=&quot;t1&quot;, shape=&quot;Mrecord&quot;];
    }
    subgraph cluster_t2 {
        label = &quot;t2, size=1&quot;;
        t2[label=&quot;t2&quot;, shape=&quot;Mrecord&quot;];
    }
    subgraph cluster_t3 {
        label = &quot;t3, size=1&quot;;
        t3[label=&quot;t3&quot;, shape=&quot;Mrecord&quot;];
    }
    subgraph cluster_t4 {
        label = &quot;t4, size=5&quot;;
        t4[label=&quot;t4&quot;, shape=&quot;Mrecord&quot;];
    }
}
&lt;&#x2F;pre&gt;
&lt;div id=&quot;graph-2&quot;&gt;&lt;&#x2F;div&gt;
&lt;script&gt;
const content2 = document.getElementById(&quot;graph-2-content&quot;).innerHTML.replaceAll(&quot;&amp;gt;&quot;, &quot;&gt;&quot;);
document.getElementById(&quot;graph-2-content&quot;).innerHTML = &quot;&quot;;
console.log(content2);
d3.select(&quot;#graph-2&quot;).graphviz()
    .renderDot(content2);
&lt;&#x2F;script&gt;
&lt;p&gt;按照 LDSF 算法，此时应该让 t1、t2 和 t3 获取到共享锁，但此时较优的方案是先给 t1 共享锁，然后给 t4 排他锁，最后同时给 t2 和 t3 共享锁。&lt;&#x2F;p&gt;
&lt;p&gt;为了解决此类问题，文章提出了 bLDSF 算法。&lt;&#x2F;p&gt;
&lt;h3 id=&quot;delay-yin-zi&quot;&gt;delay 因子&lt;&#x2F;h3&gt;
&lt;p&gt;可以看出，一组共享锁加锁成功后，这个资源下一次可用的时间取决于获得到锁的事务集合中其中最慢的事务的剩余运行时间。&lt;&#x2F;p&gt;
&lt;p&gt;我们将这个时间的期望值称为 R_max(m)，其中 m 为集合大小，而每个事务本身的剩余运行时间期望值称为 R。&lt;&#x2F;p&gt;
&lt;p&gt;我们定义 delay 因子为 f(m) = R_max(m)&#x2F;R，显然随着获得到锁的事务集合的增大，f(m) 也会随之增大。&lt;&#x2F;p&gt;
&lt;p&gt;在不同的负载下，R_max 的计算方法 和对应的 f 的值也会不同，但文章表明，实践中只需使用递增的亚线性函数即可达到比较好的效果。&lt;&#x2F;p&gt;
&lt;h3 id=&quot;you-xian-ji-ji-suan-de-gai-jin&quot;&gt;优先级计算的改进&lt;&#x2F;h3&gt;
&lt;p&gt;对于排他锁，优先级计算方式不变。&lt;&#x2F;p&gt;
&lt;p&gt;对于共享锁，在 bLDSF 算法中，备选的加锁集合是所有是 所有要加共享锁的事务组成的集合 的所有非空子集。&lt;&#x2F;p&gt;
&lt;p&gt;对于这些子集，其优先级计算方法为：这个子集的所有元素的依赖集合的并集的大小 &#x2F; 这个集合的 delay 因子。&lt;&#x2F;p&gt;
&lt;h2 id=&quot;gong-cheng-shi-xian-zhong-de-gai-jin&quot;&gt;工程实现中的改进&lt;&#x2F;h2&gt;
&lt;h3 id=&quot;gu-suan-yi-lai-ji-he-de-da-xiao&quot;&gt;估算依赖集合的大小&lt;&#x2F;h3&gt;
&lt;p&gt;实践上无论是直接搜索整个等待关系图还是在构建等待关系图时维护，计算依赖集合的大小都是比较消耗资源的（因为实际上依赖图是 DAG），文章中针对这个问题提出的改进是别管什么 DAG 了，就按树来算（即 依赖集合的大小 = 所有被直接 block 的事务的依赖集合的大小之和 + 1）。&lt;&#x2F;p&gt;
&lt;h3 id=&quot;bldsf-zhong-bian-li-suo-you-fei-kong-zi-ji&quot;&gt;bLDSF 中遍历所有非空子集&lt;&#x2F;h3&gt;
&lt;p&gt;实践中为了节约资源，可以直接遍历任意一组长度递增的非空子集，而不是遍历所有非空子集。&lt;&#x2F;p&gt;
&lt;p&gt;比如 {t1, t2, t3} 我们只考虑 {t1}, {t1, t2}, {t1, t2, t3} 就行了。&lt;&#x2F;p&gt;
&lt;h3 id=&quot;fang-zhi-ji-e&quot;&gt;防止饥饿&lt;&#x2F;h3&gt;
&lt;p&gt;文章中的意思应该是隔一段时间放置一个 barrier，barrier 之后到达的事务一定要在 barrier 之前的事务都完成之后才能获得锁。&lt;&#x2F;p&gt;
&lt;h2 id=&quot;si-huo-tikvli-neng-yong-dao-na-xie&quot;&gt;私货：TiKV里能用到哪些？&lt;&#x2F;h2&gt;
&lt;p&gt;TiKV 里全都是排他锁，因此 LDSF 就很够了。&lt;&#x2F;p&gt;
&lt;p&gt;不过现在这个等锁之后隔段时间就全部返回到 TiDB 再重试的行为&lt;sup class=&quot;footnote-reference&quot;&gt;&lt;a href=&quot;#3&quot;&gt;3&lt;&#x2F;a&gt;&lt;&#x2F;sup&gt;和 LDSF 好像不是特别兼容……&lt;&#x2F;p&gt;
&lt;div class=&quot;footnote-definition&quot; id=&quot;1&quot;&gt;&lt;sup class=&quot;footnote-definition-label&quot;&gt;1&lt;&#x2F;sup&gt;
&lt;p&gt;希腊字母，我让你希腊字母；花体字，我让你花体字。要是我说了算，用键盘上没有的符号的文章一概拒稿。&lt;&#x2F;p&gt;
&lt;&#x2F;div&gt;
&lt;div class=&quot;footnote-definition&quot; id=&quot;2&quot;&gt;&lt;sup class=&quot;footnote-definition-label&quot;&gt;2&lt;&#x2F;sup&gt;
&lt;p&gt;对象指向事务的虚线箭头的意义是：事务持锁定了这个对象。事务指向对象的实线箭头的意义是：事务希望锁定这个对象……我觉得搞这种表示形式的人一定不是普通人类。&lt;&#x2F;p&gt;
&lt;&#x2F;div&gt;
&lt;div class=&quot;footnote-definition&quot; id=&quot;3&quot;&gt;&lt;sup class=&quot;footnote-definition-label&quot;&gt;3&lt;&#x2F;sup&gt;
&lt;p&gt;而且这个东西本身我觉得就非常怪异……&lt;&#x2F;p&gt;
&lt;&#x2F;div&gt;
</content>
        
    </entry>
    <entry xml:lang="zh">
        <title>Mitchell Merritt 分布式死锁检测算法</title>
        <published>2022-01-26T03:35:48.219+00:00</published>
        <updated>2022-01-26T03:35:48.219+00:00</updated>
        <author>
          <name>Unknown</name>
        </author>
        <link rel="alternate" href="https://longfangsong.github.io/mitchell-merritt-algorithm/" type="text/html"/>
        <id>https://longfangsong.github.io/mitchell-merritt-algorithm/</id>
        
        <content type="html">&lt;h2 id=&quot;ji-ben-suan-fa&quot;&gt;基本算法&lt;&#x2F;h2&gt;
&lt;h3 id=&quot;mo-xing&quot;&gt;模型&lt;&#x2F;h3&gt;
&lt;p&gt;采用最基本的 wait-for 图模型，即每个节点是一个 process，每条边代表起点对应的 process 需要的被终点 process 持有。&lt;&#x2F;p&gt;
&lt;p&gt;对每个节点，有两个 label，一个 public，一个 private。&lt;&#x2F;p&gt;
&lt;h3 id=&quot;suan-fa-liu-cheng&quot;&gt;算法流程&lt;&#x2F;h3&gt;
&lt;ul&gt;
&lt;li&gt;所有进程开始时会被分配一个唯一的 label，此时 &lt;code&gt;public_label == private_label == 这个 label&lt;&#x2F;code&gt;&lt;&#x2F;li&gt;
&lt;li&gt;当一个进程（&lt;code&gt;process_waiting&lt;&#x2F;code&gt;）开始等待其他进程（&lt;code&gt;process_waited&lt;&#x2F;code&gt;）时，添加等待边：&lt;pre style=&quot;background-color:#2b303b;color:#c0c5ce;&quot;&gt;&lt;code&gt;&lt;span&gt;new_label = max(process_waiting.process_waiting, process_waited.public_label) + 1
&lt;&#x2F;span&gt;&lt;span&gt;process_waiting.public_label = new_label
&lt;&#x2F;span&gt;&lt;span&gt;process_waiting.private_label = new_label
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;当一个进程结束等待（可能成功获取了需要的资源，也可能运行超时）后，只需断开等待边即可&lt;&#x2F;li&gt;
&lt;li&gt;等待中的进程（&lt;code&gt;process_waiting&lt;&#x2F;code&gt;）需要时不时地检查它正等待的那个进程（&lt;code&gt;process_waited&lt;&#x2F;code&gt;）的 &lt;code&gt;public_label&lt;&#x2F;code&gt; 是否大于自己的，如果大于，则 &lt;code&gt;process_waiting.public_label = process_waited.public_label&lt;&#x2F;code&gt;&lt;&#x2F;li&gt;
&lt;li&gt;进程发现自己的 &lt;code&gt;public_label&lt;&#x2F;code&gt; 再次等于自己的 &lt;code&gt;private_label&lt;&#x2F;code&gt;，则说明发生了死锁，此时可以终结自己断开死锁环&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;h2 id=&quot;gai-jin&quot;&gt;改进&lt;&#x2F;h2&gt;
&lt;p&gt;对于有优先级的系统，我们再给每个进程添加 &lt;code&gt;public_priority&lt;&#x2F;code&gt; 和 &lt;code&gt;private_priority&lt;&#x2F;code&gt; 属性。&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;在“时不时检查”这一步，如果 &lt;code&gt;process_waited.public_label &amp;gt; process_waiting.public_label || (process_waited.public_label == process_waiting.public_label &amp;amp;&amp;amp; process_waiting.public_priority &amp;gt; process_waited.public_priority)&lt;&#x2F;code&gt;，则：&lt;pre style=&quot;background-color:#2b303b;color:#c0c5ce;&quot;&gt;&lt;code&gt;&lt;span&gt;process_waiting.public_label = process_waited.public_label
&lt;&#x2F;span&gt;&lt;span&gt;process_waiting.public_priority = min(process_waited.public_priority, process_waiting.private_priority)
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;进程发现自己的 &lt;code&gt;process_waited.public_label == process_waiting.public_label &amp;amp;&amp;amp; process_waited.public_priority == process_waiting.public_priority &amp;amp;&amp;amp; process_waiting.public_priority == process_waiting.private_priority&lt;&#x2F;code&gt;，则说明发生了死锁，且自己是死锁环中优先级最低的，此时可以终结自己断开死锁环&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;h2 id=&quot;ping-jie&quot;&gt;评价&lt;&#x2F;h2&gt;
&lt;p&gt;实践上可能效率还不如直接中心化死锁检测……&lt;&#x2F;p&gt;
</content>
        
    </entry>
    <entry xml:lang="zh">
        <title>自动机理论 • 有限状态机</title>
        <published>2021-07-22T10:55:33.427+00:00</published>
        <updated>2021-07-22T10:55:33.427+00:00</updated>
        <author>
          <name>Unknown</name>
        </author>
        <link rel="alternate" href="https://longfangsong.github.io/automata-2/" type="text/html"/>
        <id>https://longfangsong.github.io/automata-2/</id>
        
        <content type="html">&lt;h2 id=&quot;que-ding-xing-you-xian-zhuang-tai-ji-deterministic-finite-automata-dfa&quot;&gt;确定性有限状态机（Deterministic Finite Automata, DFA）&lt;&#x2F;h2&gt;
&lt;p&gt;DFA包含以下要素：&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;一个有限大小的状态集合，常记为 $Q$。&lt;&#x2F;li&gt;
&lt;li&gt;一个有限大小的输入符号集合，常记为 $\Sigma$。&lt;&#x2F;li&gt;
&lt;li&gt;一个状态转换函数，其参数为一个状态（设为 $B$）和一个输入符号（设为 $a$），返回一个状态（设为 $C$），表现了状态机在状态 $B$ 时，若接收到输入 $a$，则应该转到状态 $C$，常记为 $\delta$，如 $C = \delta(B, a)$。&lt;&#x2F;li&gt;
&lt;li&gt;一个开始状态，常记为 $q_0$，$q_0 \in Q$&lt;&#x2F;li&gt;
&lt;li&gt;一个终止或者接受状态的集合，常记为 $F$，$F \subseteq Q$。&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;DFA 常常用如上五种要素的元组表示，记为 $A = (Q, \Sigma, \delta, q_0, F)$&lt;&#x2F;p&gt;
</content>
        
    </entry>
    <entry xml:lang="zh">
        <title>自动机理论 • 基本概念</title>
        <published>2021-07-22T08:13:38.757+00:00</published>
        <updated>2021-07-22T08:13:38.757+00:00</updated>
        <author>
          <name>Unknown</name>
        </author>
        <link rel="alternate" href="https://longfangsong.github.io/automata-1/" type="text/html"/>
        <id>https://longfangsong.github.io/automata-1/</id>
        
        <content type="html">&lt;h2 id=&quot;zi-mu-biao-alphabet&quot;&gt;字母表（Alphabet）&lt;&#x2F;h2&gt;
&lt;p&gt;字母表是一个&lt;strong&gt;有限&lt;&#x2F;strong&gt;、&lt;strong&gt;非空&lt;&#x2F;strong&gt;的符号集合，常用 $\Sigma$ 表示。&lt;&#x2F;p&gt;
&lt;h3 id=&quot;zi-mu-biao-de-mi-power&quot;&gt;字母表的幂（Power）&lt;&#x2F;h3&gt;
&lt;p&gt;某个字母表 $\Sigma$ 的 $k$ 次幂就是由该字母表中的字母组成的，长度为 $k$ 的所有串组成的集合，记作 $\Sigma^k$。&lt;&#x2F;p&gt;
&lt;h2 id=&quot;zi-mu-biao-de-kleene-bi-bao-ke-lai-ni-xing-hao-kleene-star&quot;&gt;字母表的 Kleene 闭包（克莱尼星号， Kleene star）&lt;&#x2F;h2&gt;
&lt;blockquote&gt;
&lt;p&gt;Kleene 星号，或称 Kleene 闭包，德语称 Kleensche Hülle，在数学上是一种适用于字符串或符号及字元的集合的一元运算。 —— Wikipedia&lt;&#x2F;p&gt;
&lt;&#x2F;blockquote&gt;
&lt;p&gt;某个字母表 $\Sigma$ 在进行 Kleene 星号运算后的结果就是这个字母表可以表示的所有字符串（包含空串）组成的集合，记作 $\Sigma^*$。&lt;&#x2F;p&gt;
&lt;p&gt;将其中的空串去掉之后的集合记作 $\Sigma^+$。&lt;&#x2F;p&gt;
&lt;p&gt;我们有：&lt;&#x2F;p&gt;
&lt;p&gt;$$
\Sigma^+ = \bigcup^{+\infty}_1 \Sigma^k
$$&lt;&#x2F;p&gt;
&lt;p&gt;$$
\Sigma^* = \bigcup^{+\infty}_0 \Sigma^k = \Sigma^+ \cup \{\epsilon\}
$$&lt;&#x2F;p&gt;
&lt;h2 id=&quot;chuan-string&quot;&gt;串（String）&lt;&#x2F;h2&gt;
&lt;p&gt;串是一个由从某个字母表中选取的符号组成的序列。&lt;&#x2F;p&gt;
&lt;p&gt;空串是一个没有符号的串，常常用 $\epsilon$ 表示。&lt;&#x2F;p&gt;
&lt;h3 id=&quot;chuan-de-chang-du&quot;&gt;串的长度&lt;&#x2F;h3&gt;
&lt;p&gt;串的长度是指串中符号&lt;strong&gt;位置&lt;&#x2F;strong&gt;&lt;sup class=&quot;footnote-reference&quot;&gt;&lt;a href=&quot;#1&quot;&gt;1&lt;&#x2F;a&gt;&lt;&#x2F;sup&gt;的数量。&lt;&#x2F;p&gt;
&lt;h3 id=&quot;chuan-de-pin-jie-concatenation&quot;&gt;串的拼接（Concatenation）&lt;&#x2F;h3&gt;
&lt;p&gt;设有两个串 $x = a_1a_2\cdots a_n$ 和 $y = b_1b_2\cdots b_m$，则
$$
xy = a_1a_2\cdots a_nb_1b_2\cdots b_m
$$&lt;&#x2F;p&gt;
&lt;h2 id=&quot;yu-yan-language&quot;&gt;语言（Language）&lt;&#x2F;h2&gt;
&lt;p&gt;对于某个字母表 $\Sigma$，一个语言指其 Kleene 闭包的一个子集。&lt;&#x2F;p&gt;
&lt;h2 id=&quot;wen-ti-problem&quot;&gt;问题 （Problem）&lt;&#x2F;h2&gt;
&lt;p&gt;在自动机理论中，一个&lt;em&gt;问题&lt;&#x2F;em&gt;是一个判定一个给定的串是否属于某个语言的问题（question）。&lt;&#x2F;p&gt;
&lt;div class=&quot;footnote-definition&quot; id=&quot;1&quot;&gt;&lt;sup class=&quot;footnote-definition-label&quot;&gt;1&lt;&#x2F;sup&gt;
&lt;p&gt;符号位置数量不等于符号数量，比如串 &amp;quot;101010&amp;quot; 中的符号位置数量为 6，但符号数量（只有 0 和 1 ）为 2。&lt;&#x2F;p&gt;
&lt;&#x2F;div&gt;
</content>
        
    </entry>
    <entry xml:lang="zh">
        <title>重新开始学数学 • 数理逻辑（3）</title>
        <published>2021-07-06T06:02:46.315+00:00</published>
        <updated>2022-07-13T00:19:25+00:00</updated>
        <author>
          <name>Unknown</name>
        </author>
        <link rel="alternate" href="https://longfangsong.github.io/restart-math-logic-3/" type="text/html"/>
        <id>https://longfangsong.github.io/restart-math-logic-3/</id>
        
        <content type="html">&lt;h2 id=&quot;model-structure-jie-gou-mo-xing&quot;&gt;Model（Structure、结构、模型）&lt;&#x2F;h2&gt;
&lt;h3 id=&quot;yong-tu&quot;&gt;用途&lt;&#x2F;h3&gt;
&lt;p&gt;Model 的主要作用是可以在给定一个 Model 的情况下，给一个谓词逻辑表达式求值。&lt;&#x2F;p&gt;
&lt;h3 id=&quot;qian-zhi-ding-yi&quot;&gt;前置定义&lt;&#x2F;h3&gt;
&lt;h4 id=&quot;han-shu-fu-hao-function-symbol&quot;&gt;函数符号（function symbol）&lt;&#x2F;h4&gt;
&lt;blockquote&gt;
&lt;p&gt;A logical symbol that may be applied to an object term to produce another object term.&lt;&#x2F;p&gt;
&lt;&#x2F;blockquote&gt;
&lt;p&gt;按我理解来说就是一个可以应用在某个 term&lt;sup class=&quot;footnote-reference&quot;&gt;&lt;a href=&quot;#1&quot;&gt;1&lt;&#x2F;a&gt;&lt;&#x2F;sup&gt; 上生成另一个 term 的一个逻辑符号。&lt;&#x2F;p&gt;
&lt;p&gt;函数符号是一个&lt;strong&gt;符号&lt;&#x2F;strong&gt;，他可以代表，但并不等同于某一个具体函数。&lt;&#x2F;p&gt;
&lt;h4 id=&quot;wei-ci-fu-hao-predicate-symbol&quot;&gt;谓词符号（predicate symbol）&lt;&#x2F;h4&gt;
&lt;blockquote&gt;
&lt;p&gt;A notation for some concrete predicate or relation.&lt;&#x2F;p&gt;
&lt;&#x2F;blockquote&gt;
&lt;p&gt;就是代表 predicate 的&lt;strong&gt;符号&lt;&#x2F;strong&gt;。&lt;&#x2F;p&gt;
&lt;h3 id=&quot;ding-yi&quot;&gt;定义&lt;&#x2F;h3&gt;
&lt;p&gt;设有函数符号集合 $F$ 和谓词符号集合 $P$，一个 Model $M$ 包含：&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;一个包含了所有具体值的集合，称为 $A$&lt;&#x2F;li&gt;
&lt;li&gt;对 $F$ 中每个函数符号，一个（每个参数的）定义域和值域均是 $A$ 的具体函数&lt;sup class=&quot;footnote-reference&quot;&gt;&lt;a href=&quot;#2&quot;&gt;2&lt;&#x2F;a&gt;&lt;&#x2F;sup&gt;&lt;&#x2F;li&gt;
&lt;li&gt;对 $P$ 中每个谓词符号，$A$ 上的一个具体谓词（或者说由这个谓词定义的关系）&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;h3 id=&quot;li&quot;&gt;例&lt;&#x2F;h3&gt;
&lt;p&gt;这里有一个函数符号集合 $F_symbols = \{ i: () \rightarrow Value \}$，&lt;&#x2F;p&gt;
&lt;p&gt;一个谓词符号集合 $P = \{ R: (Value, Value) \rightarrow bool, F: (Value) \rightarrow bool\}$&lt;&#x2F;p&gt;
&lt;p&gt;可以利用以上两个集合，加上一个状态集合 $A$，来建立状态机的 model，比如：&lt;&#x2F;p&gt;
&lt;div class=&quot;mermaid&quot;&gt;
stateDiagram-v2
    [*] --&amp;gt; a
    a --&amp;gt; a
    a --&amp;gt; b
    b --&amp;gt; c
    a --&amp;gt; c
    c --&amp;gt; c
    b --&amp;gt; [*]
    c --&amp;gt; [*]
&lt;&#x2F;div&gt;
&lt;p&gt;对以上这一个状态机，对应的模型 M 就是：&lt;&#x2F;p&gt;
&lt;p&gt;$$
\displaylines {
M.A = \{a, b, c\} \\
M.i = a \\
M.R = \{(a, a), (a, b), (b, c), (a, c), (c, c)\} \\
M.F = \{b, c\} \\
}
$$ &lt;&#x2F;p&gt;
&lt;p&gt;我们来给以下表达式求值：&lt;&#x2F;p&gt;
&lt;p&gt;$$
\forall x \exists y R(x, y)
$$&lt;&#x2F;p&gt;
&lt;p&gt;这个表达式意思是从某个状态出去一定能到达其他状态，显然是对的。&lt;&#x2F;p&gt;
&lt;div class=&quot;footnote-definition&quot; id=&quot;1&quot;&gt;&lt;sup class=&quot;footnote-definition-label&quot;&gt;1&lt;&#x2F;sup&gt;
&lt;p&gt;表示论域内元素的正规表达式。&lt;&#x2F;p&gt;
&lt;&#x2F;div&gt;
&lt;div class=&quot;footnote-definition&quot; id=&quot;2&quot;&gt;&lt;sup class=&quot;footnote-definition-label&quot;&gt;2&lt;&#x2F;sup&gt;
&lt;p&gt;这帮子数学家老喜欢把无参函数和值等价起来，所以书里面这条对有参和无参函数是分开的……我不觉得这么搞很好，函数就是函数，所以就揉在一起了。当然也可以完全分开，即有常量符号但没有无参函数。&lt;&#x2F;p&gt;
&lt;&#x2F;div&gt;
</content>
        
    </entry>
    <entry xml:lang="zh">
        <title>自动逻辑综合原理 • 组合逻辑与 LUT 的最简单的综合</title>
        <published>2021-04-25T16:09:46.815+00:00</published>
        <updated>2021-04-25T16:09:46.815+00:00</updated>
        <author>
          <name>Unknown</name>
        </author>
        <link rel="alternate" href="https://longfangsong.github.io/fpga-sys-1/" type="text/html"/>
        <id>https://longfangsong.github.io/fpga-sys-1/</id>
        
        <content type="html">&lt;h2 id=&quot;lut&quot;&gt;LUT&lt;&#x2F;h2&gt;
&lt;blockquote&gt;
&lt;p&gt;一切皆查表。 ——我自己说的&lt;&#x2F;p&gt;
&lt;&#x2F;blockquote&gt;
&lt;p&gt;由于 FPGA 的基本结构是基于 Look Up Table 的，因此 FPGA 里实现组合逻辑的方式非常简单粗暴，就是把真值表非常暴力的存下来然后匹配。&lt;&#x2F;p&gt;
&lt;p&gt;比如说最简单的与逻辑：&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;verilog&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-verilog &quot;&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;assign &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;C &lt;&#x2F;span&gt;&lt;span&gt;= &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;A &lt;&#x2F;span&gt;&lt;span&gt;&amp;amp; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;B&lt;&#x2F;span&gt;&lt;span&gt;;
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;其真值表：&lt;&#x2F;p&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;&lt;&#x2F;th&gt;&lt;th&gt;0&lt;&#x2F;th&gt;&lt;th&gt;1&lt;&#x2F;th&gt;&lt;&#x2F;tr&gt;&lt;&#x2F;thead&gt;&lt;tbody&gt;
&lt;tr&gt;&lt;td&gt;0&lt;&#x2F;td&gt;&lt;td&gt;0&lt;&#x2F;td&gt;&lt;td&gt;0&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;1&lt;&#x2F;td&gt;&lt;td&gt;0&lt;&#x2F;td&gt;&lt;td&gt;1&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;&#x2F;tbody&gt;&lt;&#x2F;table&gt;
&lt;p&gt;那么我们就可以用一小块存储器存下这张表：&lt;&#x2F;p&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;地址&lt;&#x2F;th&gt;&lt;th&gt;值&lt;&#x2F;th&gt;&lt;&#x2F;tr&gt;&lt;&#x2F;thead&gt;&lt;tbody&gt;
&lt;tr&gt;&lt;td&gt;00&lt;&#x2F;td&gt;&lt;td&gt;0&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;01&lt;&#x2F;td&gt;&lt;td&gt;0&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;10&lt;&#x2F;td&gt;&lt;td&gt;0&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;11&lt;&#x2F;td&gt;&lt;td&gt;1&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;&#x2F;tbody&gt;&lt;&#x2F;table&gt;
&lt;p&gt;这个存储器此时就是一个 LUT，输入 A 和 B 就能输出对应逻辑函数的值。&lt;&#x2F;p&gt;
&lt;p&gt;更多变量和更复杂的式子也是同理。&lt;&#x2F;p&gt;
&lt;h2 id=&quot;shi-jian&quot;&gt;实践&lt;&#x2F;h2&gt;
&lt;p&gt;我们来用最简单粗暴的方式实现一个支持简单组合逻辑电路综合的简单综合器。&lt;&#x2F;p&gt;
&lt;p&gt;为了方便快草猛的实现出一个能动的程序，我们将要综合的逻辑函数限制在 4 个以下的输入和单个输出，这样就能使用单个 LUT4 综合出可以动的成果。&lt;&#x2F;p&gt;
&lt;p&gt;注意实际的综合器实现方式肯定不是这样暴力解出真值表然后就硬带，肯定是有更先进的方案的。&lt;&#x2F;p&gt;
&lt;h3 id=&quot;mu-biao-wen-jian-ge-shi&quot;&gt;目标文件格式&lt;&#x2F;h3&gt;
&lt;p&gt;为了方便上硬件，我们综合到的目标是 &lt;code&gt;nextpnr-ecp5&lt;&#x2F;code&gt; 中使用的 json 文件。&lt;&#x2F;p&gt;
&lt;p&gt;经过仔细阅读 &lt;code&gt;yosys&lt;&#x2F;code&gt; 综合出来的 json 文件以及反复实验，我们可以确定这个 json 最小需要写出如下内容：&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;json&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-json &quot;&gt;&lt;code class=&quot;language-json&quot; data-lang=&quot;json&quot;&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;    &amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;creator&lt;&#x2F;span&gt;&lt;span&gt;&amp;quot;: &amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;&amp;lt;综合器名称和版本，其实目测可以不写&amp;gt;&lt;&#x2F;span&gt;&lt;span&gt;&amp;quot;,
&lt;&#x2F;span&gt;&lt;span&gt;    &amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;modules&lt;&#x2F;span&gt;&lt;span&gt;&amp;quot;: {
&lt;&#x2F;span&gt;&lt;span&gt;        &amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;Module1&lt;&#x2F;span&gt;&lt;span&gt;&amp;quot;: {&lt;&#x2F;span&gt;&lt;span style=&quot;background-color:#bf616a;color:#2b303b;&quot;&gt;&amp;lt;内容&amp;gt;&lt;&#x2F;span&gt;&lt;span&gt;},
&lt;&#x2F;span&gt;&lt;span&gt;        &amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;Module2&lt;&#x2F;span&gt;&lt;span&gt;&amp;quot;: {&lt;&#x2F;span&gt;&lt;span style=&quot;background-color:#bf616a;color:#2b303b;&quot;&gt;&amp;lt;内容&amp;gt;&lt;&#x2F;span&gt;&lt;span&gt;},
&lt;&#x2F;span&gt;&lt;span&gt;    }
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;其中 module 的内容：&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;json&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-json &quot;&gt;&lt;code class=&quot;language-json&quot; data-lang=&quot;json&quot;&gt;&lt;span&gt;&amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;ports&lt;&#x2F;span&gt;&lt;span&gt;&amp;quot;: {
&lt;&#x2F;span&gt;&lt;span&gt;    &amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;&amp;lt;对外端口名称&amp;gt;&lt;&#x2F;span&gt;&lt;span&gt;&amp;quot;: {
&lt;&#x2F;span&gt;&lt;span&gt;        &amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;direction&lt;&#x2F;span&gt;&lt;span&gt;&amp;quot;: &amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;&amp;lt;input&#x2F;output&amp;gt;&lt;&#x2F;span&gt;&lt;span&gt;&amp;quot;,
&lt;&#x2F;span&gt;&lt;span&gt;        &amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;bits&lt;&#x2F;span&gt;&lt;span&gt;&amp;quot;: [&lt;&#x2F;span&gt;&lt;span style=&quot;background-color:#bf616a;color:#2b303b;&quot;&gt;&amp;lt;对应的线网的第&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;1&lt;&#x2F;span&gt;&lt;span style=&quot;background-color:#bf616a;color:#2b303b;&quot;&gt;个bit的id&amp;gt;&lt;&#x2F;span&gt;&lt;span&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;background-color:#bf616a;color:#2b303b;&quot;&gt;&amp;lt;对应的线网的第&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;2&lt;&#x2F;span&gt;&lt;span style=&quot;background-color:#bf616a;color:#2b303b;&quot;&gt;个bit的id&amp;gt;&lt;&#x2F;span&gt;&lt;span&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;background-color:#bf616a;color:#2b303b;&quot;&gt;...&lt;&#x2F;span&gt;&lt;span&gt;]
&lt;&#x2F;span&gt;&lt;span&gt;    },
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;background-color:#bf616a;color:#2b303b;&quot;&gt;...&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;},
&lt;&#x2F;span&gt;&lt;span&gt;&amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;cells&lt;&#x2F;span&gt;&lt;span&gt;&amp;quot;: {
&lt;&#x2F;span&gt;&lt;span&gt;    &amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;&amp;lt;子组件名称&amp;gt;&lt;&#x2F;span&gt;&lt;span&gt;&amp;quot;: {
&lt;&#x2F;span&gt;&lt;span&gt;        &amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;type&lt;&#x2F;span&gt;&lt;span&gt;&amp;quot;: &amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;&amp;lt;子组件类型&amp;gt;&lt;&#x2F;span&gt;&lt;span&gt;&amp;quot;,
&lt;&#x2F;span&gt;&lt;span&gt;        &amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;parameters&lt;&#x2F;span&gt;&lt;span&gt;&amp;quot;: {
&lt;&#x2F;span&gt;&lt;span&gt;            &amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;&amp;lt;子组件参数名1&amp;gt;&lt;&#x2F;span&gt;&lt;span&gt;&amp;quot;: &amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;&amp;lt;子组件参数值1&amp;gt;&lt;&#x2F;span&gt;&lt;span&gt;&amp;quot;,
&lt;&#x2F;span&gt;&lt;span&gt;            &lt;&#x2F;span&gt;&lt;span style=&quot;background-color:#bf616a;color:#2b303b;&quot;&gt;...&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;        },
&lt;&#x2F;span&gt;&lt;span&gt;        &amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;port_directions&lt;&#x2F;span&gt;&lt;span&gt;&amp;quot;: {
&lt;&#x2F;span&gt;&lt;span&gt;            &amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;&amp;lt;子组件端口名1&amp;gt;&lt;&#x2F;span&gt;&lt;span&gt;&amp;quot;: &amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;input&#x2F;output&lt;&#x2F;span&gt;&lt;span&gt;&amp;quot;,
&lt;&#x2F;span&gt;&lt;span&gt;            &lt;&#x2F;span&gt;&lt;span style=&quot;background-color:#bf616a;color:#2b303b;&quot;&gt;...&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;        },
&lt;&#x2F;span&gt;&lt;span&gt;        &amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;connections&lt;&#x2F;span&gt;&lt;span&gt;&amp;quot;: {
&lt;&#x2F;span&gt;&lt;span&gt;            &amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;&amp;lt;子组件端口名1&amp;gt;&lt;&#x2F;span&gt;&lt;span&gt;&amp;quot;: [&lt;&#x2F;span&gt;&lt;span style=&quot;background-color:#bf616a;color:#2b303b;&quot;&gt;&amp;lt;子组件端口&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;1&lt;&#x2F;span&gt;&lt;span style=&quot;background-color:#bf616a;color:#2b303b;&quot;&gt;连接到的线网的第&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;1&lt;&#x2F;span&gt;&lt;span style=&quot;background-color:#bf616a;color:#2b303b;&quot;&gt;个bit的id&amp;gt;&lt;&#x2F;span&gt;&lt;span&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;background-color:#bf616a;color:#2b303b;&quot;&gt;&amp;lt;子组件端口&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;1&lt;&#x2F;span&gt;&lt;span style=&quot;background-color:#bf616a;color:#2b303b;&quot;&gt;连接到的线网的第&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;2&lt;&#x2F;span&gt;&lt;span style=&quot;background-color:#bf616a;color:#2b303b;&quot;&gt;个bit的id&amp;gt;&lt;&#x2F;span&gt;&lt;span&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;background-color:#bf616a;color:#2b303b;&quot;&gt;...&lt;&#x2F;span&gt;&lt;span&gt;],
&lt;&#x2F;span&gt;&lt;span&gt;            &lt;&#x2F;span&gt;&lt;span style=&quot;background-color:#bf616a;color:#2b303b;&quot;&gt;...&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;        }
&lt;&#x2F;span&gt;&lt;span&gt;    }
&lt;&#x2F;span&gt;&lt;span&gt;},
&lt;&#x2F;span&gt;&lt;span&gt;&amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;netnames&lt;&#x2F;span&gt;&lt;span&gt;&amp;quot;: {
&lt;&#x2F;span&gt;&lt;span&gt;    &amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;&amp;lt;线网名称&amp;gt;&lt;&#x2F;span&gt;&lt;span&gt;&amp;quot;: {
&lt;&#x2F;span&gt;&lt;span&gt;        &amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;bits&lt;&#x2F;span&gt;&lt;span&gt;&amp;quot;: [&lt;&#x2F;span&gt;&lt;span style=&quot;background-color:#bf616a;color:#2b303b;&quot;&gt;&amp;lt;对应的线网的第&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;1&lt;&#x2F;span&gt;&lt;span style=&quot;background-color:#bf616a;color:#2b303b;&quot;&gt;个bit的id&amp;gt;&lt;&#x2F;span&gt;&lt;span&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;background-color:#bf616a;color:#2b303b;&quot;&gt;&amp;lt;对应的线网的第&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;2&lt;&#x2F;span&gt;&lt;span style=&quot;background-color:#bf616a;color:#2b303b;&quot;&gt;个bit的id&amp;gt;&lt;&#x2F;span&gt;&lt;span&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;background-color:#bf616a;color:#2b303b;&quot;&gt;...&lt;&#x2F;span&gt;&lt;span&gt;]
&lt;&#x2F;span&gt;&lt;span&gt;    },
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;h3 id=&quot;parser&quot;&gt;parser&lt;&#x2F;h3&gt;
&lt;p&gt;略，见我以前有关 parser combinator 的文章。&lt;&#x2F;p&gt;
&lt;p&gt;总之把这样子的输入：&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span&gt;module Top(a: bit, b: bit) -&amp;gt; bit {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;return&lt;&#x2F;span&gt;&lt;span&gt; a &amp;amp; b;
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;parse 成这样的结构：&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;&#x2F;&#x2F; Bracket、逻辑函数的实现同普通编程语言，略
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;pub enum &lt;&#x2F;span&gt;&lt;span&gt;Expression {
&lt;&#x2F;span&gt;&lt;span&gt;    Name(String),
&lt;&#x2F;span&gt;&lt;span&gt;    Bracket(Bracket),
&lt;&#x2F;span&gt;&lt;span&gt;    Not(Not),
&lt;&#x2F;span&gt;&lt;span&gt;    Or(Or),
&lt;&#x2F;span&gt;&lt;span&gt;    And(And),
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;pub struct &lt;&#x2F;span&gt;&lt;span&gt;Return(pub Expression);
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;pub struct &lt;&#x2F;span&gt;&lt;span&gt;Port {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;pub &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;name&lt;&#x2F;span&gt;&lt;span&gt;: String,
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;pub struct &lt;&#x2F;span&gt;&lt;span&gt;Module {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;pub &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;name&lt;&#x2F;span&gt;&lt;span&gt;: String,
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;pub &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;input&lt;&#x2F;span&gt;&lt;span&gt;: Vec&amp;lt;Port&amp;gt;,
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;&#x2F;&#x2F; todo: output type
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;pub &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;output&lt;&#x2F;span&gt;&lt;span&gt;: Vec&amp;lt;()&amp;gt;,
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;&#x2F;&#x2F; todo: `Statement` instead of `Return`
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;pub &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;statements&lt;&#x2F;span&gt;&lt;span&gt;: Vec&amp;lt;Return&amp;gt;,
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;然后将表达式编译成如下的 LUT4:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;pub struct &lt;&#x2F;span&gt;&lt;span&gt;LUT4 {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;pub &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;name&lt;&#x2F;span&gt;&lt;span&gt;: String,
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;pub &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;initial_value&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;u16&lt;&#x2F;span&gt;&lt;span&gt;,
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;pub &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;input_connections&lt;&#x2F;span&gt;&lt;span&gt;: [&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;usize&lt;&#x2F;span&gt;&lt;span&gt;; 4],
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;pub &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;output_connections&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;usize&lt;&#x2F;span&gt;&lt;span&gt;,
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;编译过程如下，代码太丑不好意思拿出来看我就放伪代码了：&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;pub fn &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;compile_expression&lt;&#x2F;span&gt;&lt;span&gt;(
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;expression&lt;&#x2F;span&gt;&lt;span&gt;: frontend::Expression,
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;context&lt;&#x2F;span&gt;&lt;span&gt;: &amp;amp;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;mut&lt;&#x2F;span&gt;&lt;span&gt; Context,
&lt;&#x2F;span&gt;&lt;span&gt;) -&amp;gt; Result&amp;lt;LUT4, ()&amp;gt; {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;&#x2F;&#x2F; generate initial_value
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;let mut&lt;&#x2F;span&gt;&lt;span&gt; initial_value = &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;0&lt;&#x2F;span&gt;&lt;span&gt;;
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;let mut&lt;&#x2F;span&gt;&lt;span&gt; variables = expression.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;variables&lt;&#x2F;span&gt;&lt;span&gt;();
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;while&lt;&#x2F;span&gt;&lt;span&gt; variables.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;len&lt;&#x2F;span&gt;&lt;span&gt;() &amp;lt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;4 &lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;        variables.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;push&lt;&#x2F;span&gt;&lt;span&gt;(format!(&amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;dummy_&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;{}&lt;&#x2F;span&gt;&lt;span&gt;&amp;quot;, variables.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;len&lt;&#x2F;span&gt;&lt;span&gt;()));
&lt;&#x2F;span&gt;&lt;span&gt;    }
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;for&lt;&#x2F;span&gt;&lt;span&gt; i, (a, b, c, d) in &lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;tagged_cartesian_product&lt;&#x2F;span&gt;&lt;span&gt;(a: (&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;0&lt;&#x2F;span&gt;&lt;span&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;1&lt;&#x2F;span&gt;&lt;span&gt;), b: (&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;0&lt;&#x2F;span&gt;&lt;span&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;1&lt;&#x2F;span&gt;&lt;span&gt;), c: (&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;0&lt;&#x2F;span&gt;&lt;span&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;1&lt;&#x2F;span&gt;&lt;span&gt;), d: (&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;0&lt;&#x2F;span&gt;&lt;span&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;1&lt;&#x2F;span&gt;&lt;span&gt;)).&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;enumerate&lt;&#x2F;span&gt;&lt;span&gt;() {
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; result = expression.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;evaluate&lt;&#x2F;span&gt;&lt;span&gt;(a, b, c, d);
&lt;&#x2F;span&gt;&lt;span&gt;        initial_value |= result &amp;lt;&amp;lt; i;
&lt;&#x2F;span&gt;&lt;span&gt;    }
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;&#x2F;&#x2F; generate input connections
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;let mut&lt;&#x2F;span&gt;&lt;span&gt; connections = [&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;0&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;usize&lt;&#x2F;span&gt;&lt;span&gt;; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;4&lt;&#x2F;span&gt;&lt;span&gt;];
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;for &lt;&#x2F;span&gt;&lt;span&gt;(index, variable) in variables.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;enumerate&lt;&#x2F;span&gt;&lt;span&gt;() {
&lt;&#x2F;span&gt;&lt;span&gt;        connections[index] = *context.wires.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;get&lt;&#x2F;span&gt;&lt;span&gt;(*variable).&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;unwrap&lt;&#x2F;span&gt;&lt;span&gt;();
&lt;&#x2F;span&gt;&lt;span&gt;    }
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; id = context.next_id++;
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; name = format!(&amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;port&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;{}&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;_LUT4&lt;&#x2F;span&gt;&lt;span&gt;&amp;quot;, id);
&lt;&#x2F;span&gt;&lt;span&gt;    context.wires.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;insert&lt;&#x2F;span&gt;&lt;span&gt;(format!(&amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;port&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;{}&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;_LUT4_Z&lt;&#x2F;span&gt;&lt;span&gt;&amp;quot;, id), id);
&lt;&#x2F;span&gt;&lt;span&gt;    Ok(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;LUT4 &lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;        name,
&lt;&#x2F;span&gt;&lt;span&gt;        initial_value,
&lt;&#x2F;span&gt;&lt;span&gt;        input_connections: connections,
&lt;&#x2F;span&gt;&lt;span&gt;        output_connections: id,
&lt;&#x2F;span&gt;&lt;span&gt;    })
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;总之就是暴力把所有可能带入 expression 求出真值表，进而算出 LUT4 的初始值，再次提醒这不是生产环境下的做法。&lt;&#x2F;p&gt;
&lt;p&gt;然后就是生成 JSON，这里只展示从 LUT4 生成 &lt;code&gt;Cell&lt;&#x2F;code&gt; 的代码：&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;pub struct &lt;&#x2F;span&gt;&lt;span&gt;Cell {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;name&lt;&#x2F;span&gt;&lt;span&gt;: String,
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;component_type&lt;&#x2F;span&gt;&lt;span&gt;: String,
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;parameters&lt;&#x2F;span&gt;&lt;span&gt;: HashMap&amp;lt;String, String&amp;gt;,
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;port_directions&lt;&#x2F;span&gt;&lt;span&gt;: HashMap&amp;lt;String, PortDirection&amp;gt;,
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;connections&lt;&#x2F;span&gt;&lt;span&gt;: HashMap&amp;lt;String, Vec&amp;lt;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;usize&lt;&#x2F;span&gt;&lt;span&gt;&amp;gt;&amp;gt;,
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;impl &lt;&#x2F;span&gt;&lt;span&gt;From&amp;lt;LUT4&amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;for &lt;&#x2F;span&gt;&lt;span&gt;Cell {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;from&lt;&#x2F;span&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;lut&lt;&#x2F;span&gt;&lt;span&gt;: LUT4) -&amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;Self &lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; port_directions = {
&lt;&#x2F;span&gt;&lt;span&gt;            &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;let mut&lt;&#x2F;span&gt;&lt;span&gt; m = HashMap::new();
&lt;&#x2F;span&gt;&lt;span&gt;            m.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;insert&lt;&#x2F;span&gt;&lt;span&gt;(&amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;A&lt;&#x2F;span&gt;&lt;span&gt;&amp;quot;.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;to_string&lt;&#x2F;span&gt;&lt;span&gt;(), PortDirection::Input);
&lt;&#x2F;span&gt;&lt;span&gt;            m.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;insert&lt;&#x2F;span&gt;&lt;span&gt;(&amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;B&lt;&#x2F;span&gt;&lt;span&gt;&amp;quot;.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;to_string&lt;&#x2F;span&gt;&lt;span&gt;(), PortDirection::Input);
&lt;&#x2F;span&gt;&lt;span&gt;            m.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;insert&lt;&#x2F;span&gt;&lt;span&gt;(&amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;C&lt;&#x2F;span&gt;&lt;span&gt;&amp;quot;.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;to_string&lt;&#x2F;span&gt;&lt;span&gt;(), PortDirection::Input);
&lt;&#x2F;span&gt;&lt;span&gt;            m.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;insert&lt;&#x2F;span&gt;&lt;span&gt;(&amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;D&lt;&#x2F;span&gt;&lt;span&gt;&amp;quot;.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;to_string&lt;&#x2F;span&gt;&lt;span&gt;(), PortDirection::Input);
&lt;&#x2F;span&gt;&lt;span&gt;            m.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;insert&lt;&#x2F;span&gt;&lt;span&gt;(&amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;Z&lt;&#x2F;span&gt;&lt;span&gt;&amp;quot;.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;to_string&lt;&#x2F;span&gt;&lt;span&gt;(), PortDirection::Output);
&lt;&#x2F;span&gt;&lt;span&gt;            m
&lt;&#x2F;span&gt;&lt;span&gt;        };
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; parameters = {
&lt;&#x2F;span&gt;&lt;span&gt;            &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;let mut&lt;&#x2F;span&gt;&lt;span&gt; m = HashMap::new();
&lt;&#x2F;span&gt;&lt;span&gt;            m.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;insert&lt;&#x2F;span&gt;&lt;span&gt;(&amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;INIT&lt;&#x2F;span&gt;&lt;span&gt;&amp;quot;.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;to_string&lt;&#x2F;span&gt;&lt;span&gt;(), format!(&amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;{:16b}&lt;&#x2F;span&gt;&lt;span&gt;&amp;quot;, lut.initial_value));
&lt;&#x2F;span&gt;&lt;span&gt;            m
&lt;&#x2F;span&gt;&lt;span&gt;        };
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; c = [&amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;A&lt;&#x2F;span&gt;&lt;span&gt;&amp;quot;, &amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;B&lt;&#x2F;span&gt;&lt;span&gt;&amp;quot;, &amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;C&lt;&#x2F;span&gt;&lt;span&gt;&amp;quot;, &amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;D&lt;&#x2F;span&gt;&lt;span&gt;&amp;quot;]
&lt;&#x2F;span&gt;&lt;span&gt;            .&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;iter&lt;&#x2F;span&gt;&lt;span&gt;()
&lt;&#x2F;span&gt;&lt;span&gt;            .&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;zip&lt;&#x2F;span&gt;&lt;span&gt;(lut.input_connections.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;iter&lt;&#x2F;span&gt;&lt;span&gt;())
&lt;&#x2F;span&gt;&lt;span&gt;            .&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;chain&lt;&#x2F;span&gt;&lt;span&gt;([&amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;Z&lt;&#x2F;span&gt;&lt;span&gt;&amp;quot;].&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;iter&lt;&#x2F;span&gt;&lt;span&gt;().&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;zip&lt;&#x2F;span&gt;&lt;span&gt;(iter::once(&amp;amp;lut.output_connections)));
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;let mut&lt;&#x2F;span&gt;&lt;span&gt; connections = HashMap::new();
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;for &lt;&#x2F;span&gt;&lt;span&gt;(name, &amp;amp;id) in c {
&lt;&#x2F;span&gt;&lt;span&gt;            connections.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;insert&lt;&#x2F;span&gt;&lt;span&gt;(name.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;to_string&lt;&#x2F;span&gt;&lt;span&gt;(), vec![id]);
&lt;&#x2F;span&gt;&lt;span&gt;        }
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;Self &lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;            name: lut.name,
&lt;&#x2F;span&gt;&lt;span&gt;            component_type: &amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;LUT4&lt;&#x2F;span&gt;&lt;span&gt;&amp;quot;.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;to_string&lt;&#x2F;span&gt;&lt;span&gt;(),
&lt;&#x2F;span&gt;&lt;span&gt;            parameters,
&lt;&#x2F;span&gt;&lt;span&gt;            port_directions,
&lt;&#x2F;span&gt;&lt;span&gt;            connections,
&lt;&#x2F;span&gt;&lt;span&gt;        }
&lt;&#x2F;span&gt;&lt;span&gt;    }
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;其他部分的实现略，唯一要注意的点就是这里 Serde 的实现有些怪异，需要自己搞，具体见代码（等我写的好一点就开源），重点就是要活用 &lt;code&gt;collect_map&lt;&#x2F;code&gt; 和 &lt;code&gt;serialize_map&lt;&#x2F;code&gt; 就是了。&lt;&#x2F;p&gt;
&lt;h3 id=&quot;run-yi-xia-shi-shi&quot;&gt;Run 一下试试！&lt;&#x2F;h3&gt;
&lt;p&gt;我们用我们的程序综合上面提到的代码，可以得到：&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;json&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-json &quot;&gt;&lt;code class=&quot;language-json&quot; data-lang=&quot;json&quot;&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;    &amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;creator&lt;&#x2F;span&gt;&lt;span&gt;&amp;quot;: &amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;Rosys 0.1&lt;&#x2F;span&gt;&lt;span&gt;&amp;quot;,
&lt;&#x2F;span&gt;&lt;span&gt;    &amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;modules&lt;&#x2F;span&gt;&lt;span&gt;&amp;quot;: {
&lt;&#x2F;span&gt;&lt;span&gt;        &amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;Top&lt;&#x2F;span&gt;&lt;span&gt;&amp;quot;: {
&lt;&#x2F;span&gt;&lt;span&gt;            &amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;ports&lt;&#x2F;span&gt;&lt;span&gt;&amp;quot;: {
&lt;&#x2F;span&gt;&lt;span&gt;                &amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;a&lt;&#x2F;span&gt;&lt;span&gt;&amp;quot;: {
&lt;&#x2F;span&gt;&lt;span&gt;                    &amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;direction&lt;&#x2F;span&gt;&lt;span&gt;&amp;quot;: &amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;input&lt;&#x2F;span&gt;&lt;span&gt;&amp;quot;,
&lt;&#x2F;span&gt;&lt;span&gt;                    &amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;bits&lt;&#x2F;span&gt;&lt;span&gt;&amp;quot;: [&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;2&lt;&#x2F;span&gt;&lt;span&gt;]
&lt;&#x2F;span&gt;&lt;span&gt;                },
&lt;&#x2F;span&gt;&lt;span&gt;                &amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;b&lt;&#x2F;span&gt;&lt;span&gt;&amp;quot;: {
&lt;&#x2F;span&gt;&lt;span&gt;                    &amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;direction&lt;&#x2F;span&gt;&lt;span&gt;&amp;quot;: &amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;input&lt;&#x2F;span&gt;&lt;span&gt;&amp;quot;,
&lt;&#x2F;span&gt;&lt;span&gt;                    &amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;bits&lt;&#x2F;span&gt;&lt;span&gt;&amp;quot;: [&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;3&lt;&#x2F;span&gt;&lt;span&gt;]
&lt;&#x2F;span&gt;&lt;span&gt;                },
&lt;&#x2F;span&gt;&lt;span&gt;                &amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;port4_LUT4_Z&lt;&#x2F;span&gt;&lt;span&gt;&amp;quot;: {
&lt;&#x2F;span&gt;&lt;span&gt;                    &amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;direction&lt;&#x2F;span&gt;&lt;span&gt;&amp;quot;: &amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;output&lt;&#x2F;span&gt;&lt;span&gt;&amp;quot;,
&lt;&#x2F;span&gt;&lt;span&gt;                    &amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;bits&lt;&#x2F;span&gt;&lt;span&gt;&amp;quot;: [&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;4&lt;&#x2F;span&gt;&lt;span&gt;]
&lt;&#x2F;span&gt;&lt;span&gt;                }
&lt;&#x2F;span&gt;&lt;span&gt;            },
&lt;&#x2F;span&gt;&lt;span&gt;            &amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;cells&lt;&#x2F;span&gt;&lt;span&gt;&amp;quot;: {
&lt;&#x2F;span&gt;&lt;span&gt;                &amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;port4_LUT4&lt;&#x2F;span&gt;&lt;span&gt;&amp;quot;: {
&lt;&#x2F;span&gt;&lt;span&gt;                    &amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;type&lt;&#x2F;span&gt;&lt;span&gt;&amp;quot;: &amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;LUT4&lt;&#x2F;span&gt;&lt;span&gt;&amp;quot;,
&lt;&#x2F;span&gt;&lt;span&gt;                    &amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;parameters&lt;&#x2F;span&gt;&lt;span&gt;&amp;quot;: {
&lt;&#x2F;span&gt;&lt;span&gt;                        &amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;INIT&lt;&#x2F;span&gt;&lt;span&gt;&amp;quot;: &amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;1000100010001000&lt;&#x2F;span&gt;&lt;span&gt;&amp;quot;
&lt;&#x2F;span&gt;&lt;span&gt;                    },
&lt;&#x2F;span&gt;&lt;span&gt;                    &amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;port_directions&lt;&#x2F;span&gt;&lt;span&gt;&amp;quot;: {
&lt;&#x2F;span&gt;&lt;span&gt;                        &amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;A&lt;&#x2F;span&gt;&lt;span&gt;&amp;quot;: &amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;input&lt;&#x2F;span&gt;&lt;span&gt;&amp;quot;,
&lt;&#x2F;span&gt;&lt;span&gt;                        &amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;Z&lt;&#x2F;span&gt;&lt;span&gt;&amp;quot;: &amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;output&lt;&#x2F;span&gt;&lt;span&gt;&amp;quot;,
&lt;&#x2F;span&gt;&lt;span&gt;                        &amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;C&lt;&#x2F;span&gt;&lt;span&gt;&amp;quot;: &amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;input&lt;&#x2F;span&gt;&lt;span&gt;&amp;quot;,
&lt;&#x2F;span&gt;&lt;span&gt;                        &amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;B&lt;&#x2F;span&gt;&lt;span&gt;&amp;quot;: &amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;input&lt;&#x2F;span&gt;&lt;span&gt;&amp;quot;,
&lt;&#x2F;span&gt;&lt;span&gt;                        &amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;D&lt;&#x2F;span&gt;&lt;span&gt;&amp;quot;: &amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;input&lt;&#x2F;span&gt;&lt;span&gt;&amp;quot;
&lt;&#x2F;span&gt;&lt;span&gt;                    },
&lt;&#x2F;span&gt;&lt;span&gt;                    &amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;connections&lt;&#x2F;span&gt;&lt;span&gt;&amp;quot;: {
&lt;&#x2F;span&gt;&lt;span&gt;                        &amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;Z&lt;&#x2F;span&gt;&lt;span&gt;&amp;quot;: [&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;4&lt;&#x2F;span&gt;&lt;span&gt;],
&lt;&#x2F;span&gt;&lt;span&gt;                        &amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;A&lt;&#x2F;span&gt;&lt;span&gt;&amp;quot;: [&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;2&lt;&#x2F;span&gt;&lt;span&gt;],
&lt;&#x2F;span&gt;&lt;span&gt;                        &amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;D&lt;&#x2F;span&gt;&lt;span&gt;&amp;quot;: [&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;0&lt;&#x2F;span&gt;&lt;span&gt;],
&lt;&#x2F;span&gt;&lt;span&gt;                        &amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;B&lt;&#x2F;span&gt;&lt;span&gt;&amp;quot;: [&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;3&lt;&#x2F;span&gt;&lt;span&gt;],
&lt;&#x2F;span&gt;&lt;span&gt;                        &amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;C&lt;&#x2F;span&gt;&lt;span&gt;&amp;quot;: [&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;0&lt;&#x2F;span&gt;&lt;span&gt;]
&lt;&#x2F;span&gt;&lt;span&gt;                    }
&lt;&#x2F;span&gt;&lt;span&gt;                }
&lt;&#x2F;span&gt;&lt;span&gt;            },
&lt;&#x2F;span&gt;&lt;span&gt;            &amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;netnames&lt;&#x2F;span&gt;&lt;span&gt;&amp;quot;: {
&lt;&#x2F;span&gt;&lt;span&gt;                &amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;a&lt;&#x2F;span&gt;&lt;span&gt;&amp;quot;: {
&lt;&#x2F;span&gt;&lt;span&gt;                    &amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;bits&lt;&#x2F;span&gt;&lt;span&gt;&amp;quot;: [&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;2&lt;&#x2F;span&gt;&lt;span&gt;]
&lt;&#x2F;span&gt;&lt;span&gt;                },
&lt;&#x2F;span&gt;&lt;span&gt;                &amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;b&lt;&#x2F;span&gt;&lt;span&gt;&amp;quot;: {
&lt;&#x2F;span&gt;&lt;span&gt;                    &amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;bits&lt;&#x2F;span&gt;&lt;span&gt;&amp;quot;: [&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;3&lt;&#x2F;span&gt;&lt;span&gt;]
&lt;&#x2F;span&gt;&lt;span&gt;                },
&lt;&#x2F;span&gt;&lt;span&gt;                &amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;port4_LUT4_Z&lt;&#x2F;span&gt;&lt;span&gt;&amp;quot;: {
&lt;&#x2F;span&gt;&lt;span&gt;                    &amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;bits&lt;&#x2F;span&gt;&lt;span&gt;&amp;quot;: [&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;4&lt;&#x2F;span&gt;&lt;span&gt;]
&lt;&#x2F;span&gt;&lt;span&gt;                }
&lt;&#x2F;span&gt;&lt;span&gt;            }
&lt;&#x2F;span&gt;&lt;span&gt;        }
&lt;&#x2F;span&gt;&lt;span&gt;    }
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;然后居然就可以用 &lt;code&gt;nextpnr-ecp5&lt;&#x2F;code&gt; 搓出 &lt;code&gt;config&lt;&#x2F;code&gt; 文件，然后用 &lt;code&gt;ecppack&lt;&#x2F;code&gt; 做出 bit，然后把它烧录进 FPGA 里居然就可以用了。&lt;&#x2F;p&gt;
&lt;p&gt;我们居然这么容易就写出了一个能动的综合器。
接下来将会介绍更多逻辑综合的相关内容，预定会写更复杂逻辑函数的综合和时序逻辑电路的综合。&lt;&#x2F;p&gt;
</content>
        
    </entry>
    <entry xml:lang="zh">
        <title>macOS 用户也要玩 FPGA！</title>
        <published>2021-04-24T16:53:12.045+00:00</published>
        <updated>2021-04-24T16:53:12.045+00:00</updated>
        <author>
          <name>Unknown</name>
        </author>
        <link rel="alternate" href="https://longfangsong.github.io/macos-fpga/" type="text/html"/>
        <id>https://longfangsong.github.io/macos-fpga/</id>
        
        <content type="html">&lt;p&gt;冲着能用开源工具链入了一块 iCESugar-Pro，本来想着如果 macOS 环境搞不定就下官方的虚拟机，结果居然给我配成了。&lt;&#x2F;p&gt;
&lt;h2 id=&quot;ise-vivado-quartus-de-que-dian&quot;&gt;ISE&#x2F;Vivado&#x2F;Quartus 的缺点&lt;&#x2F;h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;收费&lt;&#x2F;p&gt;
&lt;p&gt;我没钱。&lt;del&gt;我用盗版，我让国外资本主义巨头亏麻了，我骄傲。&lt;&#x2F;del&gt;&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;限定系统&lt;&#x2F;p&gt;
&lt;p&gt;首先，没有一个有 macOS 支持，其次 Linux 支持也不甚完整（Ubuntu 装 ISE 能强行装上，但基本跑不起来，官方支持列表里好像只有红帽，也许 centos 可以但我真的不是很喜欢这个发行版），基本上只有 Windows 能用……&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;命令行支持烂（IDE 还丑）&lt;&#x2F;p&gt;
&lt;p&gt;我就是想用 Vim&#x2F;VSCode 写 Verilog&#x2F;Chisel 然后用 Makefile 编译和下载啊！！！
谁想用那些个难看的不得了又卡交互逻辑又奇怪的 IDE 啊！！！
虽说技术上这几个设计工具都有命令行接口，但是资料和例子就基本没有了，好不容易看到一个官方的文档然后打开一看拿几千个选项甩你一脸……&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;对学习自动综合原理等没有帮助&lt;&#x2F;p&gt;
&lt;p&gt;看不了代码，学习，学个屁。
不过说实话我是希望有书能讲讲这个的……光看代码还是太痛苦了。&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;h2 id=&quot;kai-yuan-gong-ju-lian&quot;&gt;开源工具链&lt;&#x2F;h2&gt;
&lt;h3 id=&quot;claire-wolf-de-chuan-qi&quot;&gt;&lt;a href=&quot;http:&#x2F;&#x2F;www.clifford.at&#x2F;&quot;&gt;Claire Wolf&lt;&#x2F;a&gt; 的传奇&lt;&#x2F;h3&gt;
&lt;p&gt;这个人就是开源硬件世界里的 Richard Stallman&lt;sup class=&quot;footnote-reference&quot;&gt;&lt;a href=&quot;#1&quot;&gt;1&lt;&#x2F;a&gt;&lt;&#x2F;sup&gt;。&lt;&#x2F;p&gt;
&lt;p&gt;这个人 2012 年几乎单枪匹马做出了开源 Verilog 逻辑综合工具 &lt;a href=&quot;http:&#x2F;&#x2F;www.clifford.at&#x2F;yosys&#x2F;&quot;&gt;Yosys&lt;&#x2F;a&gt;。&lt;&#x2F;p&gt;
&lt;p&gt;2015 年（也是几乎单枪匹马）做出了开源 RISC-V 核 &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;cliffordwolf&#x2F;picorv32&quot;&gt;picorv32&lt;&#x2F;a&gt;。&lt;&#x2F;p&gt;
&lt;p&gt;同年开始 &lt;a href=&quot;http:&#x2F;&#x2F;www.clifford.at&#x2F;icestorm&#x2F;&quot;&gt;icestorm&lt;&#x2F;a&gt; 项目，开始针对 Lattice FPGA 整合整条开源工具链。&lt;&#x2F;p&gt;
&lt;p&gt;2018 年，开始 FPGA 布局布线工具项目 &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;YosysHQ&#x2F;nextpnr&quot;&gt;nextpnr&lt;&#x2F;a&gt;。&lt;&#x2F;p&gt;
&lt;p&gt;总之一句话，开源 FPGA 界的基础软件基本上是这个人一个人打的基础。&lt;&#x2F;p&gt;
&lt;p&gt;看完这个人的经历之后我只想用一个表情包表达我的心情：&lt;&#x2F;p&gt;
&lt;p&gt;我也能，像他一样吗.jpg （不会 PS 所以表情包请自行脑补 😄）&lt;&#x2F;p&gt;
&lt;p&gt;说了那么多我们还是看看这些工具怎么用吧，毕竟我现在也就只能用用这些工具了，离去开发这些东西还太远😭。&lt;&#x2F;p&gt;
&lt;h3 id=&quot;yosys-zong-he-gong-ju&quot;&gt;Yosys 综合工具&lt;&#x2F;h3&gt;
&lt;p&gt;虽然说 &lt;code&gt;brew&lt;&#x2F;code&gt; 可以装上，但是那个版本太老了，和其他工具（比如 &lt;code&gt;nextpnr&lt;&#x2F;code&gt;）配合使用会出问题。&lt;&#x2F;p&gt;
&lt;h4 id=&quot;clone-dai-ma&quot;&gt;clone 代码&lt;&#x2F;h4&gt;
&lt;pre data-lang=&quot;sh&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-sh &quot;&gt;&lt;code class=&quot;language-sh&quot; data-lang=&quot;sh&quot;&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;git&lt;&#x2F;span&gt;&lt;span&gt; clone https:&#x2F;&#x2F;github.com&#x2F;YosysHQ&#x2F;yosys.git
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;h4 id=&quot;zhuang-yi-lai&quot;&gt;装依赖&lt;&#x2F;h4&gt;
&lt;p&gt;&lt;code&gt;yosys&lt;&#x2F;code&gt; 提供了 &lt;code&gt;Brewfile&lt;&#x2F;code&gt;，像官方说的：&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;sh&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-sh &quot;&gt;&lt;code class=&quot;language-sh&quot; data-lang=&quot;sh&quot;&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;brew&lt;&#x2F;span&gt;&lt;span&gt; tap Homebrew&#x2F;bundle &amp;amp;&amp;amp; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;brew&lt;&#x2F;span&gt;&lt;span&gt; bundle
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;就好了&lt;sup class=&quot;footnote-reference&quot;&gt;&lt;a href=&quot;#2&quot;&gt;2&lt;&#x2F;a&gt;&lt;&#x2F;sup&gt;。&lt;&#x2F;p&gt;
&lt;h4 id=&quot;make&quot;&gt;make&lt;&#x2F;h4&gt;
&lt;pre data-lang=&quot;sh&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-sh &quot;&gt;&lt;code class=&quot;language-sh&quot; data-lang=&quot;sh&quot;&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;make -j&lt;&#x2F;span&gt;&lt;span&gt;$&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;(nproc)
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;make&lt;&#x2F;span&gt;&lt;span&gt; install
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;h4 id=&quot;shi-yong&quot;&gt;使用&lt;&#x2F;h4&gt;
&lt;p&gt;&lt;code&gt;yosys&lt;&#x2F;code&gt; 可以通过 &lt;code&gt;-p&lt;&#x2F;code&gt; 参数接受一个 “综合脚本”，或者通过 &lt;code&gt;-s&lt;&#x2F;code&gt; 接受综合脚本文件，或者不加任何参数的话可以直接 &lt;code&gt;yosys&lt;&#x2F;code&gt; 一个命令直接 REPL 执行，目前我已知的脚本命令有：&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;read_verilog&lt;&#x2F;code&gt;&lt;&#x2F;p&gt;
&lt;p&gt;用于读取 verilog 文件。&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;synth_ecp5&lt;&#x2F;code&gt;&lt;&#x2F;p&gt;
&lt;p&gt;用于实际综合，传入 &lt;code&gt;-json&lt;&#x2F;code&gt; 来获取 json 格式的输出。&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;例如：&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;sh&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-sh &quot;&gt;&lt;code class=&quot;language-sh&quot; data-lang=&quot;sh&quot;&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;yosys -p &lt;&#x2F;span&gt;&lt;span&gt;&amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;read_verilog blink.v; read_verilog rst_gen.v; synth_ecp5 -json main.json&lt;&#x2F;span&gt;&lt;span&gt;&amp;quot;
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;或者也可以写成：&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;sh&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-sh &quot;&gt;&lt;code class=&quot;language-sh&quot; data-lang=&quot;sh&quot;&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;yosys -p &lt;&#x2F;span&gt;&lt;span&gt;&amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;synth_ecp5 -json main.json&lt;&#x2F;span&gt;&lt;span&gt;&amp;quot; blink.v rst_gen.v
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;h3 id=&quot;nextpnr-bu-ju-bu-xian-gong-ju&quot;&gt;nextpnr 布局布线工具&lt;&#x2F;h3&gt;
&lt;h4 id=&quot;clone-dai-ma-1&quot;&gt;clone 代码&lt;&#x2F;h4&gt;
&lt;pre data-lang=&quot;sh&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-sh &quot;&gt;&lt;code class=&quot;language-sh&quot; data-lang=&quot;sh&quot;&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;git&lt;&#x2F;span&gt;&lt;span&gt; clone https:&#x2F;&#x2F;github.com&#x2F;YosysHQ&#x2F;nextpnr.git
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;h4 id=&quot;an-zhuang-trellis-zu-jian-yu-gong-ju-ku&quot;&gt;安装 Trellis 组件与工具库&lt;&#x2F;h4&gt;
&lt;p&gt;Trellis 组件库与工具库为 nextpnr 提供了 Lattice ECP5 的组件库以及用于生成 bitstream 的 &lt;code&gt;ecppack&lt;&#x2F;code&gt; 工具。&lt;&#x2F;p&gt;
&lt;h5 id=&quot;clone-dai-ma-2&quot;&gt;clone 代码&lt;&#x2F;h5&gt;
&lt;pre data-lang=&quot;sh&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-sh &quot;&gt;&lt;code class=&quot;language-sh&quot; data-lang=&quot;sh&quot;&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;git&lt;&#x2F;span&gt;&lt;span&gt; clone&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt; --recursive&lt;&#x2F;span&gt;&lt;span&gt; https:&#x2F;&#x2F;github.com&#x2F;YosysHQ&#x2F;prjtrellis
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;h5 id=&quot;make-1&quot;&gt;make&lt;&#x2F;h5&gt;
&lt;pre data-lang=&quot;sh&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-sh &quot;&gt;&lt;code class=&quot;language-sh&quot; data-lang=&quot;sh&quot;&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;cd&lt;&#x2F;span&gt;&lt;span&gt; libtrellis
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;# 就算 sudo 了也不能装在 &#x2F;usr 里，直接跟着 brew 装 &#x2F;usr&#x2F;local 里就行
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;cmake -DCMAKE_INSTALL_PREFIX&lt;&#x2F;span&gt;&lt;span&gt;=&#x2F;usr&#x2F;local .
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;make -j&lt;&#x2F;span&gt;&lt;span&gt;$&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;(nproc)
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;sudo&lt;&#x2F;span&gt;&lt;span&gt; make install
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;h4 id=&quot;make-2&quot;&gt;make&lt;&#x2F;h4&gt;
&lt;p&gt;在克隆下来的 &lt;code&gt;nextpnr&lt;&#x2F;code&gt; 仓库下：&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;sh&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-sh &quot;&gt;&lt;code class=&quot;language-sh&quot; data-lang=&quot;sh&quot;&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;cmake&lt;&#x2F;span&gt;&lt;span&gt; .&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt; -DARCH&lt;&#x2F;span&gt;&lt;span&gt;=ecp5&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt; -DTRELLIS_INSTALL_PREFIX&lt;&#x2F;span&gt;&lt;span&gt;=&#x2F;usr&#x2F;local
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;make -j&lt;&#x2F;span&gt;&lt;span&gt;$&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;(nproc)
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;sudo&lt;&#x2F;span&gt;&lt;span&gt; make install
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;h4 id=&quot;shi-yong-1&quot;&gt;使用&lt;&#x2F;h4&gt;
&lt;pre data-lang=&quot;sh&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-sh &quot;&gt;&lt;code class=&quot;language-sh&quot; data-lang=&quot;sh&quot;&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;nextpnr-ecp5&lt;&#x2F;span&gt;&lt;span&gt; --&amp;lt;型号&amp;gt; --package &amp;lt;封装&amp;gt; --json &amp;lt;刚刚综合出来的 JSON&amp;gt; --lpf &amp;lt;引脚分配文件&amp;gt; --textcfg &amp;lt;输出到 config 文件&amp;gt;
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;iCESugar-Pro 上的 FPGA 型号是 &lt;code&gt;25k&lt;&#x2F;code&gt;，封装方式是 &lt;code&gt;CABGA256&lt;&#x2F;code&gt;。&lt;&#x2F;p&gt;
&lt;h5 id=&quot;lpf-wen-jian&quot;&gt;LPF 文件&lt;&#x2F;h5&gt;
&lt;p&gt;主要使用下面几个命令：&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;LOCATE&lt;&#x2F;code&gt;&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;lpf&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-lpf &quot;&gt;&lt;code class=&quot;language-lpf&quot; data-lang=&quot;lpf&quot;&gt;&lt;span&gt;LOCATE COMP &amp;quot;&amp;lt;代码内名称&amp;gt;&amp;quot; SITE &amp;quot;&amp;lt;硬件手册上的编号&amp;gt;&amp;quot;;
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;例如：&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;lpf&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-lpf &quot;&gt;&lt;code class=&quot;language-lpf&quot; data-lang=&quot;lpf&quot;&gt;&lt;span&gt;LOCATE COMP &amp;quot;clk&amp;quot; SITE &amp;quot;A1&amp;quot;;
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;h3 id=&quot;ecppack-bitstream-sheng-cheng-qi&quot;&gt;ecppack bitstream 生成器&lt;&#x2F;h3&gt;
&lt;p&gt;&lt;code&gt;ecppack&lt;&#x2F;code&gt; 是 Trellis 组件与工具库的一部分，前面已经安装好了。&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;sh&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-sh &quot;&gt;&lt;code class=&quot;language-sh&quot; data-lang=&quot;sh&quot;&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;ecppack &lt;&#x2F;span&gt;&lt;span&gt;&amp;lt;config 文件&amp;gt; --bit &amp;lt;目标 .bit 文件&amp;gt;
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;h3 id=&quot;xia-zai&quot;&gt;下载&lt;&#x2F;h3&gt;
&lt;p&gt;iCESugar-Pro 连到电脑上就一U盘，可以直接拖！拽！下！载！作者太 tmd 良心了！！！&lt;&#x2F;p&gt;
&lt;div class=&quot;footnote-definition&quot; id=&quot;1&quot;&gt;&lt;sup class=&quot;footnote-definition-label&quot;&gt;1&lt;&#x2F;sup&gt;
&lt;p&gt;比 RMS nb 的是，Claire Wolf 是一位 MTF，政治正确的一匹。&lt;&#x2F;p&gt;
&lt;&#x2F;div&gt;
&lt;div class=&quot;footnote-definition&quot; id=&quot;2&quot;&gt;&lt;sup class=&quot;footnote-definition-label&quot;&gt;2&lt;&#x2F;sup&gt;
&lt;p&gt;在 GFW 内约耗时一个世纪。&lt;&#x2F;p&gt;
&lt;&#x2F;div&gt;
</content>
        
    </entry>
    <entry xml:lang="zh">
        <title>RoCC RISC-V 扩展方案</title>
        <published>2021-04-19T15:45:33.706+00:00</published>
        <updated>2021-04-19T15:45:33.706+00:00</updated>
        <author>
          <name>Unknown</name>
        </author>
        <link rel="alternate" href="https://longfangsong.github.io/riscv-rocc/" type="text/html"/>
        <id>https://longfangsong.github.io/riscv-rocc/</id>
        
        <content type="html">&lt;p&gt;RoCC 是通过向 RISC-V 处理器添加扩展的半官方&lt;sup class=&quot;footnote-reference&quot;&gt;&lt;a href=&quot;#1&quot;&gt;1&lt;&#x2F;a&gt;&lt;&#x2F;sup&gt;方案，最早用于 BSD 的 Rocket-core。&lt;&#x2F;p&gt;
&lt;h2 id=&quot;rocc-gui-ding-de-kuo-zhan-zhi-ling&quot;&gt;RoCC 规定的扩展指令&lt;&#x2F;h2&gt;
&lt;p&gt;RoCC 使用了 RISCV 标准中预留的所有四个扩展槽位，并规定了如下指令格式：&lt;&#x2F;p&gt;
&lt;p&gt;&lt;img src=&quot;https:&#x2F;&#x2F;longfangsong.github.io&#x2F;riscv-rocc&#x2F;.&#x2F;rocc-inst.png&quot; alt=&quot;RoCC inst&quot; &#x2F;&gt;&lt;&#x2F;p&gt;
&lt;p&gt;其中 &lt;code&gt;xd&lt;&#x2F;code&gt;、&lt;code&gt;xs1&lt;&#x2F;code&gt;、&lt;code&gt;xs2&lt;&#x2F;code&gt; 分别表示对应的寄存器是否被使用到了。&lt;&#x2F;p&gt;
&lt;h2 id=&quot;rocc-he-cpu-zhi-jian-de-jiao-hu&quot;&gt;RoCC 和 CPU 之间的交互&lt;&#x2F;h2&gt;
&lt;p&gt;RoCC 主要通过如下接口和 CPU 进行交互：&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;CPU 通过 &lt;code&gt;Cmd&lt;&#x2F;code&gt; 接口将指令和相关寄存器的值发送给 RoCC 加速器&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;RoCC 加速器通过 &lt;code&gt;Resp&lt;&#x2F;code&gt; 接口将计算结果（要写入的寄存器号和值）返回到 CPU&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;RoCC 通过 &lt;code&gt;busy&lt;&#x2F;code&gt; 标记加速器是否处于忙状态&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;RoCC 自身也可以访问内存、引发中断等&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;div class=&quot;footnote-definition&quot; id=&quot;1&quot;&gt;&lt;sup class=&quot;footnote-definition-label&quot;&gt;1&lt;&#x2F;sup&gt;
&lt;p&gt;指由 RISC-V 亲爹 BSD 研发。&lt;&#x2F;p&gt;
&lt;&#x2F;div&gt;
</content>
        
    </entry>
    <entry xml:lang="zh">
        <title>内联汇编 cheatsheet</title>
        <published>2021-04-18T07:34:52.996+00:00</published>
        <updated>2021-04-18T07:34:52.996+00:00</updated>
        <author>
          <name>Unknown</name>
        </author>
        <link rel="alternate" href="https://longfangsong.github.io/inline-asm-cheatsheet/" type="text/html"/>
        <id>https://longfangsong.github.io/inline-asm-cheatsheet/</id>
        
        <content type="html">&lt;h2 id=&quot;ji-ben-yu-fa-mo-ban&quot;&gt;基本语法模版&lt;&#x2F;h2&gt;
&lt;pre data-lang=&quot;c&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-c &quot;&gt;&lt;code class=&quot;language-c&quot; data-lang=&quot;c&quot;&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;asm&lt;&#x2F;span&gt;&lt;span&gt;(
&lt;&#x2F;span&gt;&lt;span&gt;    &amp;lt;代码&amp;gt;:
&lt;&#x2F;span&gt;&lt;span&gt;    &amp;lt;输出到哪些变量&amp;gt;:
&lt;&#x2F;span&gt;&lt;span&gt;    &amp;lt;从哪些变量输入&amp;gt;:
&lt;&#x2F;span&gt;&lt;span&gt;    &amp;lt;副作用会影响什么&amp;gt;
&lt;&#x2F;span&gt;&lt;span&gt;)
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;其中每个值如果有多个的话都是用逗号分隔。&lt;&#x2F;p&gt;
&lt;h3 id=&quot;shu-ru-shu-chu-bian-liang&quot;&gt;输入输出变量&lt;&#x2F;h3&gt;
&lt;p&gt;输入输出变量的常用格式为：&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;c&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-c &quot;&gt;&lt;code class=&quot;language-c&quot; data-lang=&quot;c&quot;&gt;&lt;span&gt;&amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;&amp;lt;修饰符&amp;gt;&amp;lt;约束&amp;gt;&lt;&#x2F;span&gt;&lt;span&gt;&amp;quot;(&amp;lt;变量&amp;gt;)
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;h4 id=&quot;yue-shu&quot;&gt;约束&lt;&#x2F;h4&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;r&lt;&#x2F;code&gt;
指代某个通用寄存器&lt;&#x2F;li&gt;
&lt;li&gt;&lt;code&gt;m&lt;&#x2F;code&gt;
指代某个变量的内存地址, 后面的括号填入的是变量本身而非变量地址&lt;&#x2F;li&gt;
&lt;li&gt;&lt;code&gt;i&lt;&#x2F;code&gt;
指代某个立即数&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;h4 id=&quot;xiu-shi-fu&quot;&gt;修饰符&lt;&#x2F;h4&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;=&lt;&#x2F;code&gt;
指这个变量&#x2F;寄存器被写入了，一般所有输出变量都会带上这个。&lt;&#x2F;li&gt;
&lt;li&gt;&lt;code&gt;+&lt;&#x2F;code&gt;
指这个变量&#x2F;寄存器被读取和写入了&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;h3 id=&quot;fu-zuo-yong-hui-ying-xiang-shi-yao&quot;&gt;副作用会影响什么&lt;&#x2F;h3&gt;
&lt;p&gt;这里一般就填一些标记寄存器和 &lt;code&gt;memory&lt;&#x2F;code&gt;。&lt;&#x2F;p&gt;
</content>
        
    </entry>
    <entry xml:lang="zh">
        <title>Hack RISC-V 指令集</title>
        <published>2021-04-17T07:34:52.996+00:00</published>
        <updated>2021-04-17T07:34:52.996+00:00</updated>
        <author>
          <name>Unknown</name>
        </author>
        <link rel="alternate" href="https://longfangsong.github.io/hack-riscv-isa/" type="text/html"/>
        <id>https://longfangsong.github.io/hack-riscv-isa/</id>
        
        <content type="html">&lt;h2 id=&quot;huan-jing&quot;&gt;环境&lt;&#x2F;h2&gt;
&lt;p&gt;本文假设用户使用基于 debian 的 Linux 系统，有 &lt;code&gt;su&lt;&#x2F;code&gt; 或者 &lt;code&gt;sudo&lt;&#x2F;code&gt; 的能力&lt;sup class=&quot;footnote-reference&quot;&gt;&lt;a href=&quot;#1&quot;&gt;1&lt;&#x2F;a&gt;&lt;&#x2F;sup&gt;，并且用的文件系统是区分大小写&lt;sup class=&quot;footnote-reference&quot;&gt;&lt;a href=&quot;#2&quot;&gt;2&lt;&#x2F;a&gt;&lt;&#x2F;sup&gt;的。&lt;&#x2F;p&gt;
&lt;p&gt;然后请事先安装 &lt;code&gt;git&lt;&#x2F;code&gt; 以及任意文本编辑器。&lt;&#x2F;p&gt;
&lt;h2 id=&quot;gnu-bian-yi-gong-ju-lian&quot;&gt;GNU 编译工具链&lt;&#x2F;h2&gt;
&lt;h3 id=&quot;clone-dai-ma&quot;&gt;clone 代码&lt;&#x2F;h3&gt;
&lt;pre data-lang=&quot;sh&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-sh &quot;&gt;&lt;code class=&quot;language-sh&quot; data-lang=&quot;sh&quot;&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;git&lt;&#x2F;span&gt;&lt;span&gt; clone https:&#x2F;&#x2F;github.com&#x2F;riscv&#x2F;riscv-gnu-toolchain
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;然后进入 clone 到的文件夹中。&lt;&#x2F;p&gt;
&lt;h3 id=&quot;zhuang-yi-lai&quot;&gt;装依赖&lt;&#x2F;h3&gt;
&lt;pre data-lang=&quot;sh&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-sh &quot;&gt;&lt;code class=&quot;language-sh&quot; data-lang=&quot;sh&quot;&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;apt-get&lt;&#x2F;span&gt;&lt;span&gt; install autoconf automake autotools-dev curl python3 libmpc-dev libmpfr-dev libgmp-dev gawk build-essential bison flex texinfo gperf libtool patchutils bc zlib1g-dev libexpat-dev
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;h3 id=&quot;zhun-bei-yao-an-zhuang-dao-de-wei-zhi&quot;&gt;准备要安装到的位置&lt;&#x2F;h3&gt;
&lt;p&gt;比如要把工具链装到 &lt;code&gt;&#x2F;opt&#x2F;riscv&lt;&#x2F;code&gt; 下的话：&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;sh&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-sh &quot;&gt;&lt;code class=&quot;language-sh&quot; data-lang=&quot;sh&quot;&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;mkdir&lt;&#x2F;span&gt;&lt;span&gt; &#x2F;opt&#x2F;riscv
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;chmod&lt;&#x2F;span&gt;&lt;span&gt; 777 &#x2F;opt&#x2F;riscv &lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;# just use 777, who cares about bad guys?
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;h3 id=&quot;configure&quot;&gt;&lt;code&gt;configure&lt;&#x2F;code&gt;&lt;&#x2F;h3&gt;
&lt;pre data-lang=&quot;sh&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-sh &quot;&gt;&lt;code class=&quot;language-sh&quot; data-lang=&quot;sh&quot;&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;.&#x2F;configure --prefix&lt;&#x2F;span&gt;&lt;span&gt;=&#x2F;opt&#x2F;riscv&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt; --enable-multilib
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;h3 id=&quot;make&quot;&gt;&lt;code&gt;make&lt;&#x2F;code&gt;&lt;&#x2F;h3&gt;
&lt;pre data-lang=&quot;sh&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-sh &quot;&gt;&lt;code class=&quot;language-sh&quot; data-lang=&quot;sh&quot;&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;make
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;One eternity later ...&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;sh&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-sh &quot;&gt;&lt;code class=&quot;language-sh&quot; data-lang=&quot;sh&quot;&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;make&lt;&#x2F;span&gt;&lt;span&gt; linux
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Two eternities later ...&lt;&#x2F;p&gt;
&lt;p&gt;注意每次 &lt;code&gt;make&lt;&#x2F;code&gt; 的时候都会下载对应的 &lt;code&gt;submodule&lt;&#x2F;code&gt;，请保证有正常的网络环境。&lt;&#x2F;p&gt;
&lt;p&gt;然后 &lt;code&gt;&#x2F;opt&#x2F;riscv&lt;&#x2F;code&gt; 里就有编译器、lib 等等了。&lt;&#x2F;p&gt;
&lt;h3 id=&quot;tian-jia-zi-ding-yi-zhi-ling&quot;&gt;添加自定义指令&lt;&#x2F;h3&gt;
&lt;p&gt;编辑 &lt;code&gt;riscv-binutils&#x2F;opcodes&#x2F;riscv-opc.c&lt;&#x2F;code&gt;，在 &lt;code&gt;riscv_opcodes&lt;&#x2F;code&gt; 中加入新的指令:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;c&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-c &quot;&gt;&lt;code class=&quot;language-c&quot; data-lang=&quot;c&quot;&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;    &amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;&amp;lt;指令名称&amp;gt;&lt;&#x2F;span&gt;&lt;span&gt;&amp;quot;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;0&lt;&#x2F;span&gt;&lt;span&gt;, &amp;lt;指令类型&amp;gt;, &amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;&amp;lt;操作数&amp;gt;&lt;&#x2F;span&gt;&lt;span&gt;&amp;quot;, 
&lt;&#x2F;span&gt;&lt;span&gt;    &amp;lt;匹配&amp;gt;, &amp;lt;掩码&amp;gt;, match_opcode, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;0
&lt;&#x2F;span&gt;&lt;span&gt;},
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;代表使用时形如：&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;asm&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-asm &quot;&gt;&lt;code class=&quot;language-asm&quot; data-lang=&quot;asm&quot;&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;&amp;lt;指令名称&amp;gt; &amp;lt;操作数&amp;gt;
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;的一条汇编指令。&lt;&#x2F;p&gt;
&lt;h4 id=&quot;zhi-ling-lei-xing&quot;&gt;指令类型&lt;&#x2F;h4&gt;
&lt;p&gt;建议无脑给 &lt;code&gt;INSN_CLASS_I&lt;&#x2F;code&gt;, 因为 &lt;code&gt;I&lt;&#x2F;code&gt; 在所有情况下都是支持的，无需在编译时手动开启各个指令集。&lt;&#x2F;p&gt;
&lt;p&gt;暂时不清楚是否支持在 &lt;code&gt;include&#x2F;opcode&#x2F;riscv.h&lt;&#x2F;code&gt; 中的 &lt;code&gt;riscv_insn_class&lt;&#x2F;code&gt; 中添加自己的指令集名称，然后在这里使用。&lt;&#x2F;p&gt;
&lt;h4 id=&quot;cao-zuo-shu&quot;&gt;操作数&lt;&#x2F;h4&gt;
&lt;p&gt;这我一直没找到一个说明的文档，只有根据已经写好的部分和代码（代码在 &lt;code&gt;riscv-binutils&#x2F;gas&#x2F;config&#x2F;tc-riscv.c&lt;&#x2F;code&gt;）推了&lt;sup class=&quot;footnote-reference&quot;&gt;&lt;a href=&quot;#3&quot;&gt;3&lt;&#x2F;a&gt;&lt;&#x2F;sup&gt;：&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;d&lt;&#x2F;code&gt;
代表目标寄存器&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;s&lt;&#x2F;code&gt;
代表第一个寄存器操作数&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;t&lt;&#x2F;code&gt;
代表第二个寄存器操作数&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;j&lt;&#x2F;code&gt;
代表一个立即数&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;o(s)&lt;&#x2F;code&gt;
代表用于读取出来的一个地址，格式为寄存器 + 偏移量&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;q(s)&lt;&#x2F;code&gt;
代表用于写入进去的一个地址，格式为寄存器 + 偏移量&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;&amp;lt;&lt;&#x2F;code&gt; 和 &lt;code&gt;&amp;gt;&lt;&#x2F;code&gt;
代表移位的位数&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;h5 id=&quot;ke-zhi-ji-cun-qi&quot;&gt;客制寄存器&lt;&#x2F;h5&gt;
&lt;p&gt;这里假设你希望在内联汇编里手写寄存器而不是让 gcc 为你分配你的客制寄存器，比如你希望添加一个读取矩阵的指令：&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;c&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-c &quot;&gt;&lt;code class=&quot;language-c&quot; data-lang=&quot;c&quot;&gt;&lt;span&gt;{&amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;matload&lt;&#x2F;span&gt;&lt;span&gt;&amp;quot;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;0&lt;&#x2F;span&gt;&lt;span&gt;, INSN_CLASS_I, &amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;Md,o(s)&lt;&#x2F;span&gt;&lt;span&gt;&amp;quot;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;0x100b&lt;&#x2F;span&gt;&lt;span&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;0x707f&lt;&#x2F;span&gt;&lt;span&gt;, match_opcode, INSN_DREF},
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;这里的 &lt;code&gt;Md&lt;&#x2F;code&gt; 代表一个矩阵寄存器。&lt;&#x2F;p&gt;
&lt;p&gt;那么你需要在 gnu 工具链中进行如下修改：&lt;&#x2F;p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;在 &lt;code&gt;riscv-binutils&#x2F;opcodes&#x2F;riscv-opc.c&lt;&#x2F;code&gt; 中的 &lt;code&gt;riscv_fpr_names_abi&lt;&#x2F;code&gt; 下面，添加一个新的数组，保存你的各个寄存器的名字，并在 &lt;code&gt;riscv-binutils&#x2F;include&#x2F;opcode&#x2F;riscv.h&lt;&#x2F;code&gt; 添加相应的声明，例如：&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;c&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-c &quot;&gt;&lt;code class=&quot;language-c&quot; data-lang=&quot;c&quot;&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;&#x2F;&#x2F; riscv.h
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;extern const char &lt;&#x2F;span&gt;&lt;span&gt;*&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;const&lt;&#x2F;span&gt;&lt;span&gt; riscv_mat_names_numeric[&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;8&lt;&#x2F;span&gt;&lt;span&gt;];
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;pre data-lang=&quot;c&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-c &quot;&gt;&lt;code class=&quot;language-c&quot; data-lang=&quot;c&quot;&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;&#x2F;&#x2F; riscv-opc.c
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;const char &lt;&#x2F;span&gt;&lt;span&gt;* &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;const&lt;&#x2F;span&gt;&lt;span&gt; riscv_mat_names_numeric[&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;8&lt;&#x2F;span&gt;&lt;span&gt;] ={&amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;mat0&lt;&#x2F;span&gt;&lt;span&gt;&amp;quot;, &amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;mat1&lt;&#x2F;span&gt;&lt;span&gt;&amp;quot;, &amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;mat2&lt;&#x2F;span&gt;&lt;span&gt;&amp;quot;, &amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;mat3&lt;&#x2F;span&gt;&lt;span&gt;&amp;quot;, &amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;mat4&lt;&#x2F;span&gt;&lt;span&gt;&amp;quot;, &amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;mat5&lt;&#x2F;span&gt;&lt;span&gt;&amp;quot;, &amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;mat6&lt;&#x2F;span&gt;&lt;span&gt;&amp;quot;, &amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;mat7&lt;&#x2F;span&gt;&lt;span&gt;&amp;quot;};
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;在 &lt;code&gt;reg_class&lt;&#x2F;code&gt; （在 &lt;code&gt;riscv-binutils&#x2F;gas&#x2F;config&#x2F;tc-riscv.c&lt;&#x2F;code&gt;）中添加这个客制寄存器集的“名称”：&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;diff&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-diff &quot;&gt;&lt;code class=&quot;language-diff&quot; data-lang=&quot;diff&quot;&gt;&lt;span&gt;enum reg_class
&lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;  RCLASS_GPR,
&lt;&#x2F;span&gt;&lt;span&gt;  RCLASS_FPR,
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;+ RCLASS_MPR,
&lt;&#x2F;span&gt;&lt;span&gt;  RCLASS_MAX,
&lt;&#x2F;span&gt;&lt;span&gt;  RCLASS_CSR
&lt;&#x2F;span&gt;&lt;span&gt;};
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;在同一文件下负责汇编器初始化的 &lt;code&gt;md_begin&lt;&#x2F;code&gt; 函数中注册这个客制寄存器集：&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;c&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-c &quot;&gt;&lt;code class=&quot;language-c&quot; data-lang=&quot;c&quot;&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;hash_reg_names&lt;&#x2F;span&gt;&lt;span&gt;(RCLASS_MPR, riscv_mat_names_numeric, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;8&lt;&#x2F;span&gt;&lt;span&gt;);
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;在同一文件下检查 RISC-V 指令格式的 &lt;code&gt;validate_riscv_insn&lt;&#x2F;code&gt; 函数中个的最大的那个 &lt;code&gt;switch&lt;&#x2F;code&gt; 中添加对这个寄存器参数的检查。&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;在同一文件下负责进行实际汇编到二进制代码的 &lt;code&gt;riscv_ip&lt;&#x2F;code&gt; 函数中添加生成二进制代码的代码。&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
&lt;p&gt;到此你的编译器已经能正常生成二进制代码了，但是如果你还想要用 &lt;code&gt;objdump&lt;&#x2F;code&gt; 之类的反编译工具：&lt;&#x2F;p&gt;
&lt;ol start=&quot;6&quot;&gt;
&lt;li&gt;在 &lt;code&gt;riscv-binutils&#x2F;opcodes&#x2F;riscv-dis.c&lt;&#x2F;code&gt; 中的 &lt;code&gt;print_insn_args&lt;&#x2F;code&gt; 中也添加相关解析代码。&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
&lt;h4 id=&quot;pi-pei-he-yan-ma&quot;&gt;匹配和掩码&lt;&#x2F;h4&gt;
&lt;p&gt;设有一条二进制指令 &lt;code&gt;instruction&lt;&#x2F;code&gt;, 若：&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;c&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-c &quot;&gt;&lt;code class=&quot;language-c&quot; data-lang=&quot;c&quot;&gt;&lt;span&gt;instruction &amp;amp; 掩码 == 匹配
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;则认为 &lt;code&gt;instruction&lt;&#x2F;code&gt; 是这一类的指令。&lt;&#x2F;p&gt;
&lt;h4 id=&quot;zhong-xin-bian-yi&quot;&gt;重新编译&lt;&#x2F;h4&gt;
&lt;p&gt;重新编译工具链需要 &lt;code&gt;make clean&lt;&#x2F;code&gt;，删空安装位置（如 &lt;code&gt;&#x2F;opt&#x2F;riscv&lt;&#x2F;code&gt;），然后重新 &lt;code&gt;make&lt;&#x2F;code&gt;&lt;sup class=&quot;footnote-reference&quot;&gt;&lt;a href=&quot;#4&quot;&gt;4&lt;&#x2F;a&gt;&lt;&#x2F;sup&gt;。&lt;&#x2F;p&gt;
&lt;h3 id=&quot;shi-yong&quot;&gt;使用&lt;&#x2F;h3&gt;
&lt;p&gt;然后就能在汇编里拿 &lt;code&gt;asm&lt;&#x2F;code&gt; 用你刚刚加的指令了。&lt;&#x2F;p&gt;
&lt;p&gt;如果你不是很懂内联汇编&lt;sup class=&quot;footnote-reference&quot;&gt;&lt;a href=&quot;#5&quot;&gt;5&lt;&#x2F;a&gt;&lt;&#x2F;sup&gt;，可以看看我的&lt;a href=&quot;https:&#x2F;&#x2F;longfangsong.github.io&#x2F;inline-asm-cheatsheet&#x2F;&quot;&gt;另一篇文章&lt;&#x2F;a&gt;。&lt;&#x2F;p&gt;
&lt;h2 id=&quot;risc-v-tools&quot;&gt;RISC-V tools&lt;&#x2F;h2&gt;
&lt;p&gt;我们主要使用 RISC-V tools 中的 RISC-V 行为级模拟器 —— spike。&lt;&#x2F;p&gt;
&lt;h3 id=&quot;clone-dai-ma-1&quot;&gt;clone 代码&lt;&#x2F;h3&gt;
&lt;pre data-lang=&quot;sh&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-sh &quot;&gt;&lt;code class=&quot;language-sh&quot; data-lang=&quot;sh&quot;&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;git&lt;&#x2F;span&gt;&lt;span&gt; clone https:&#x2F;&#x2F;github.com&#x2F;riscv&#x2F;riscv-tools.git
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;然后进入 clone 到的文件夹中。&lt;&#x2F;p&gt;
&lt;p&gt;与 GNU 工具链在 &lt;code&gt;make&lt;&#x2F;code&gt; 的时候会自动拿 submodule 不同，tools 这边要手动：&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;sh&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-sh &quot;&gt;&lt;code class=&quot;language-sh&quot; data-lang=&quot;sh&quot;&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;git&lt;&#x2F;span&gt;&lt;span&gt; submodule update&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt; --init --recursive
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;此外建议把我们重点要修改的 &lt;code&gt;riscv-isa-sim&lt;&#x2F;code&gt; 手动更新到 origin master 版本：&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;sh&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-sh &quot;&gt;&lt;code class=&quot;language-sh&quot; data-lang=&quot;sh&quot;&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;cd&lt;&#x2F;span&gt;&lt;span&gt; riscv-isa-sim
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;git&lt;&#x2F;span&gt;&lt;span&gt; pull origin master
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;h3 id=&quot;zhi-ding-an-zhuang-di-zhi&quot;&gt;指定安装地址&lt;&#x2F;h3&gt;
&lt;pre data-lang=&quot;sh&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-sh &quot;&gt;&lt;code class=&quot;language-sh&quot; data-lang=&quot;sh&quot;&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;export &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;RISCV&lt;&#x2F;span&gt;&lt;span&gt;=&amp;lt;安装地址&amp;gt;
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;h3 id=&quot;build&quot;&gt;build&lt;&#x2F;h3&gt;
&lt;p&gt;如果你按照官方说明直接在 clone 到的文件夹中：&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;sh&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-sh &quot;&gt;&lt;code class=&quot;language-sh&quot; data-lang=&quot;sh&quot;&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;.&#x2F;build.sh
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;那你大概率会碰到 riscv-test submodule 里的关于 &lt;code&gt;tohost&lt;&#x2F;code&gt; 和 &lt;code&gt;fromhost&lt;&#x2F;code&gt; 重复定义的错误，可以采用&lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;riscv&#x2F;riscv-tests&#x2F;issues&#x2F;286#issuecomment-801002149&quot;&gt;这里提到&lt;&#x2F;a&gt;的方法修复&lt;sup class=&quot;footnote-reference&quot;&gt;&lt;a href=&quot;#6&quot;&gt;6&lt;&#x2F;a&gt;&lt;&#x2F;sup&gt;：&lt;&#x2F;p&gt;
&lt;p&gt;修改 &lt;code&gt;.&#x2F;riscv-tests&#x2F;isa&#x2F;Makefile&lt;&#x2F;code&gt; 中的编译选项：&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;diff&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-diff &quot;&gt;&lt;code class=&quot;language-diff&quot; data-lang=&quot;diff&quot;&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;-RISCV_GCC_OPTS ?= -static -mcmodel=medany -fvisibility=hidden -nostdlib -nostartfiles
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;+RISCV_GCC_OPTS ?= -static -mcmodel=medany -fvisibility=hidden -nostdlib -nostartfiles -fcommon
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;h3 id=&quot;tian-jia-zi-ding-yi-zhi-ling-ji&quot;&gt;添加自定义指令集&lt;&#x2F;h3&gt;
&lt;p&gt;在 Spike 模拟器中添加客制指令集非常方便，只需要在 &lt;code&gt;.&#x2F;riscv-isa-sim&#x2F;customext&#x2F;&lt;&#x2F;code&gt; 中添加一个实现扩展指令集行为的文件，
其中有一个类实现了 &lt;code&gt;extension_t&lt;&#x2F;code&gt;，然后用 &lt;code&gt;REGISTER_EXTENSION&lt;&#x2F;code&gt; 宏将其注册到模拟器即可。&lt;&#x2F;p&gt;
&lt;p&gt;&lt;code&gt;extension_t&lt;&#x2F;code&gt; 要求一个 &lt;code&gt;name&lt;&#x2F;code&gt;，一个拿所有指令的 &lt;code&gt;get_instructions&lt;&#x2F;code&gt;，一个拿所有反汇编指令的 &lt;code&gt;get_disasms&lt;&#x2F;code&gt;。&lt;&#x2F;p&gt;
&lt;h2 id=&quot;gem5-mo-ni-qi&quot;&gt;gem5 模拟器&lt;&#x2F;h2&gt;
&lt;h3 id=&quot;clone-dai-ma-2&quot;&gt;clone 代码&lt;&#x2F;h3&gt;
&lt;pre data-lang=&quot;sh&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-sh &quot;&gt;&lt;code class=&quot;language-sh&quot; data-lang=&quot;sh&quot;&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;git&lt;&#x2F;span&gt;&lt;span&gt; clone https:&#x2F;&#x2F;gem5.googlesource.com&#x2F;public&#x2F;gem5
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;h3 id=&quot;zhuang-yi-lai-1&quot;&gt;装依赖&lt;&#x2F;h3&gt;
&lt;pre data-lang=&quot;sh&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-sh &quot;&gt;&lt;code class=&quot;language-sh&quot; data-lang=&quot;sh&quot;&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;sudo&lt;&#x2F;span&gt;&lt;span&gt; apt install build-essential git m4 scons zlib1g zlib1g-dev \
&lt;&#x2F;span&gt;&lt;span&gt;    libprotobuf-dev protobuf-compiler libprotoc-dev libgoogle-perftools-dev \
&lt;&#x2F;span&gt;&lt;span&gt;    python3-dev python3-six python libboost-all-dev pkg-config
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;h3 id=&quot;build-1&quot;&gt;build&lt;&#x2F;h3&gt;
&lt;p&gt;在 clone 到的文件夹中：&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;sh&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-sh &quot;&gt;&lt;code class=&quot;language-sh&quot; data-lang=&quot;sh&quot;&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;&#x2F;usr&#x2F;bin&#x2F;env&lt;&#x2F;span&gt;&lt;span&gt; python3 $(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;which&lt;&#x2F;span&gt;&lt;span&gt; scons) build&#x2F;RISCV&#x2F;gem5.opt&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt; -j &lt;&#x2F;span&gt;&lt;span&gt;&amp;lt;CPU核数&amp;gt;
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;如果你想要在你的程序中加 &lt;code&gt;checkpoint&lt;&#x2F;code&gt;、重置统计数据等，需要构建 &lt;code&gt;libm5&lt;&#x2F;code&gt;：&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;sh&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-sh &quot;&gt;&lt;code class=&quot;language-sh&quot; data-lang=&quot;sh&quot;&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;&#x2F;usr&#x2F;bin&#x2F;env&lt;&#x2F;span&gt;&lt;span&gt; python3 $(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;which&lt;&#x2F;span&gt;&lt;span&gt; scons)&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt; -C&lt;&#x2F;span&gt;&lt;span&gt; util&#x2F;m5 build&#x2F;riscv&#x2F;out&#x2F;m5
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;h3 id=&quot;shi-yong-1&quot;&gt;使用&lt;&#x2F;h3&gt;
&lt;p&gt;如果你编写的程序中使用了 &lt;code&gt;libm5&lt;&#x2F;code&gt; 中的功能，需要包含 &lt;code&gt;gem5&#x2F;m5ops.h&lt;&#x2F;code&gt; 并在链接时链接 &lt;code&gt;libm5.a&lt;&#x2F;code&gt;：&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;sh&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-sh &quot;&gt;&lt;code class=&quot;language-sh&quot; data-lang=&quot;sh&quot;&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;riscv64-linux-gnu-gcc -static -I&lt;&#x2F;span&gt;&lt;span&gt;&#x2F;home&#x2F;longfangsong&#x2F;workspace&#x2F;gem5&#x2F;include&#x2F;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt; -I &lt;&#x2F;span&gt;&lt;span&gt;&amp;lt;gem5 位置&amp;gt;&#x2F;gem5&#x2F;include&#x2F;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt; -static &lt;&#x2F;span&gt;&lt;span&gt;&amp;lt;其他源文件&amp;gt; &amp;lt;gem5 位置&amp;gt;&#x2F;gem5&#x2F;util&#x2F;m5&#x2F;build&#x2F;riscv&#x2F;out&#x2F;libm5.a
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;h4 id=&quot;trick-on-profiling-unspported-isa-set&quot;&gt;Trick on profiling unspported ISA set&lt;&#x2F;h4&gt;
&lt;p&gt;&lt;code&gt;gem5&lt;&#x2F;code&gt; 只支持使用 &lt;code&gt;riscv64-linux-gnu-gcc&lt;&#x2F;code&gt; 生成的二进制文件，而且假定了用户有硬浮点支持，这在想要比较不同指令集时会带来一些不便。&lt;&#x2F;p&gt;
&lt;p&gt;解决方案非常呆但很有效，就是先用 &lt;code&gt;riscv64-unknown-elf-gcc&lt;&#x2F;code&gt; 拿到某个指令集和 abi（如果要用和最终编译到二进制文件时不同的 abi 的话建议通过全局变量传参数和返回值） 下的汇编，然后用 &lt;code&gt;riscv64-linux-gnu-gcc&lt;&#x2F;code&gt; 编译汇编来生成最终的二进制文件以供 &lt;code&gt;gem5&lt;&#x2F;code&gt; 执行。&lt;&#x2F;p&gt;
&lt;p&gt;可能会用到软乘法、软浮点等等的libgcc 中的 polyfill 代码，把这些也拉过来编译就是了&lt;sup class=&quot;footnote-reference&quot;&gt;&lt;a href=&quot;#7&quot;&gt;7&lt;&#x2F;a&gt;&lt;&#x2F;sup&gt;, 目前已知的几份 polyfill 代码的位置都位于 &lt;code&gt;riscv-gnu-toolchain&#x2F;libgcc&lt;&#x2F;code&gt; 下，&lt;code&gt;softfp&lt;&#x2F;code&gt; 就是软浮点，&lt;code&gt;config&#x2F;riscv&lt;&#x2F;code&gt; 就是其他一些东西的 polyfill，比如乘除法，原子操作等等。&lt;&#x2F;p&gt;
&lt;div class=&quot;footnote-definition&quot; id=&quot;1&quot;&gt;&lt;sup class=&quot;footnote-definition-label&quot;&gt;1&lt;&#x2F;sup&gt;
&lt;p&gt;因为 debian 可以在 &lt;code&gt;su&lt;&#x2F;code&gt; 下面做所有的事，&lt;code&gt;sudo&lt;&#x2F;code&gt; 反而要自己装，docker 一打开就是 &lt;code&gt;su&lt;&#x2F;code&gt;，为了复制粘贴方便下面都不会写明要 &lt;code&gt;sudo&lt;&#x2F;code&gt; 的地方，如果有必要的话自己加……&lt;&#x2F;p&gt;
&lt;&#x2F;div&gt;
&lt;div class=&quot;footnote-definition&quot; id=&quot;2&quot;&gt;&lt;sup class=&quot;footnote-definition-label&quot;&gt;2&lt;&#x2F;sup&gt;
&lt;p&gt;这是真的坑。还好正常的 Linux 系统安装器默认的文件系统都是区分大小写的。但用 Docker 挂其他系统的 Volume 就不一定了……&lt;&#x2F;p&gt;
&lt;&#x2F;div&gt;
&lt;div class=&quot;footnote-definition&quot; id=&quot;3&quot;&gt;&lt;sup class=&quot;footnote-definition-label&quot;&gt;3&lt;&#x2F;sup&gt;
&lt;p&gt;没文档就 nm 离谱，有些字母用的也挺离谱。&lt;&#x2F;p&gt;
&lt;&#x2F;div&gt;
&lt;div class=&quot;footnote-definition&quot; id=&quot;4&quot;&gt;&lt;sup class=&quot;footnote-definition-label&quot;&gt;4&lt;&#x2F;sup&gt;
&lt;p&gt;这群开发者写的什么鬼 Makefile 啦。&lt;&#x2F;p&gt;
&lt;&#x2F;div&gt;
&lt;div class=&quot;footnote-definition&quot; id=&quot;5&quot;&gt;&lt;sup class=&quot;footnote-definition-label&quot;&gt;5&lt;&#x2F;sup&gt;
&lt;p&gt;讲道理我也不懂 😭&lt;&#x2F;p&gt;
&lt;&#x2F;div&gt;
&lt;div class=&quot;footnote-definition&quot; id=&quot;6&quot;&gt;&lt;sup class=&quot;footnote-definition-label&quot;&gt;6&lt;&#x2F;sup&gt;
&lt;p&gt;官方维护在干什么东西啊.jpg&lt;&#x2F;p&gt;
&lt;&#x2F;div&gt;
&lt;div class=&quot;footnote-definition&quot; id=&quot;7&quot;&gt;&lt;sup class=&quot;footnote-definition-label&quot;&gt;7&lt;&#x2F;sup&gt;
&lt;p&gt;现在我懂为啥 C++ 大型项目为啥要把依赖也搞到项目的 &lt;code&gt;.&#x2F;third_parties&lt;&#x2F;code&gt; 里面一起编译了，否则这个链接、 abi 什么的是真的麻烦。&lt;&#x2F;p&gt;
&lt;&#x2F;div&gt;
</content>
        
    </entry>
    <entry xml:lang="zh">
        <title>Haskell与函数式编程</title>
        <published>2021-04-17T07:34:52.996+00:00</published>
        <updated>2023-08-18T17:31:19.739+00:00</updated>
        <author>
          <name>Unknown</name>
        </author>
        <link rel="alternate" href="https://longfangsong.github.io/haskell-intro/" type="text/html"/>
        <id>https://longfangsong.github.io/haskell-intro/</id>
        
        <content type="html">&lt;p&gt;你也许不应该在工作中用一门纯函数式编程语言（那样对大脑太不友好），但你应当学习这样一门语言，因为这将会改变你的思维。
即使你平常使用的是一些常见的语言，如 C++&#x2F;Java(8+)&#x2F;Python&#x2F;JS，你还是能从这些语言中找到函数式编程的影子。
另外，函数式编程思想在整体架构的设计上也有很大的作用。&lt;&#x2F;p&gt;
&lt;h2 id=&quot;what-s-the-difference&quot;&gt;What’s the difference?&lt;&#x2F;h2&gt;
&lt;p&gt;（像Haskell这样的）纯函数式编程语言和我们平常使用比较多的命令式编程语言有极大的不同。&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;没有变量，一切量都是不变的
&lt;ul&gt;
&lt;li&gt;因此也没有循环了&lt;&#x2F;li&gt;
&lt;li&gt;也没有传统意义上的逻辑判断&lt;&#x2F;li&gt;
&lt;li&gt;因此函数都是“纯函数”，因为没有变量，所以除非使用特殊结构，否则不可能有副作用&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;函数是”一等公民”，每个函数都是一个变量，有其类型，能作为其他函数的参数&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;看到这里你就意识到了，你需要把你在命令式编程语言界学到的大部分知识全部忘掉。&lt;&#x2F;p&gt;
&lt;p&gt;确实是这样，因为这完全是两种不同的思维体系。&lt;&#x2F;p&gt;
&lt;p&gt;你也许会以为没有变量是没有办法编程的，但这是一种常见的误解，你将在下面看到，变量不仅没那么重要，而且有时“可变”只会带来麻烦。&lt;&#x2F;p&gt;
&lt;h2 id=&quot;why-haskell&quot;&gt;Why Haskell?&lt;&#x2F;h2&gt;
&lt;p&gt;Haskell除了是一门纯函数式编程语言外，还有如下特点：&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;惰性求值，所有的值不被用到就不会被计算。&lt;&#x2F;li&gt;
&lt;li&gt;静态强类型，并有着我所见过的，在“能用的”语言中最好的类型系统。&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;h2 id=&quot;haskell-li-de-ji-ben-cao-zuo&quot;&gt;Haskell 里的基本操作&lt;&#x2F;h2&gt;
&lt;h3 id=&quot;ji-ben-shu-ju-lei-xing&quot;&gt;基本数据类型&lt;&#x2F;h3&gt;
&lt;p&gt;从表面上看，Haskell中的数据类型和C中的大致相同，整数字符浮点数应有尽有。&lt;&#x2F;p&gt;
&lt;p&gt;此外，Haskell中比较厉害的一个类型是列表类型，下面会说。&lt;&#x2F;p&gt;
&lt;h3 id=&quot;diao-yong-han-shu&quot;&gt;调用函数&lt;&#x2F;h3&gt;
&lt;p&gt;Haskell调用函数的方式和C语言不太一样：&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;haskell&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-haskell &quot;&gt;&lt;code class=&quot;language-haskell&quot; data-lang=&quot;haskell&quot;&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;-- 假设有函数 f, g
&lt;&#x2F;span&gt;&lt;span&gt;f x   &lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;-- 这就是计算f(x)了
&lt;&#x2F;span&gt;&lt;span&gt;g x y &lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;-- g(x,y)
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Haskell省去了括号和逗号，这虽然让用惯了 C 系语言的人不太适应，但也部分避免了像 Lisp 那样一屏幕的括号的尴尬。&lt;&#x2F;p&gt;
&lt;h3 id=&quot;ji-ben-yun-suan&quot;&gt;基本运算&lt;&#x2F;h3&gt;
&lt;p&gt;&lt;code&gt;+&lt;&#x2F;code&gt;、&lt;code&gt;-&lt;&#x2F;code&gt;、&lt;code&gt;*&lt;&#x2F;code&gt;、&lt;code&gt;&#x2F;&lt;&#x2F;code&gt;、&lt;code&gt;&amp;amp;&amp;amp;&lt;&#x2F;code&gt;、&lt;code&gt;||&lt;&#x2F;code&gt;、&lt;code&gt;==&lt;&#x2F;code&gt; 这些运算符的作用都和C语言一样。&lt;&#x2F;p&gt;
&lt;p&gt;特别的，取反要用 &lt;code&gt;not&lt;&#x2F;code&gt;（实际上这是个函数，在Haskell中这些运算符本质都是函数），C 中的不等于符号 &lt;code&gt;!=&lt;&#x2F;code&gt;，在这里是 &lt;code&gt;&#x2F;=&lt;&#x2F;code&gt;。&lt;&#x2F;p&gt;
&lt;p&gt;求余要用mod函数：&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;haskell&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-haskell &quot;&gt;&lt;code class=&quot;language-haskell&quot; data-lang=&quot;haskell&quot;&gt;&lt;span&gt;mod &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;3 2
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;如果你想要像 C 语言中的 % 那样中缀调用 &lt;code&gt;mod&lt;&#x2F;code&gt; 的话，你可以使用 ``` 将函数包裹：&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;haskell&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-haskell &quot;&gt;&lt;code class=&quot;language-haskell&quot; data-lang=&quot;haskell&quot;&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;3 &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;`&lt;&#x2F;span&gt;&lt;span&gt;mod&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;` &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;2
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;h3 id=&quot;lie-biao&quot;&gt;列表&lt;&#x2F;h3&gt;
&lt;p&gt;首先要提一句，Haskell 中所谓的字符串还是字符列表的一个语法糖。&lt;&#x2F;p&gt;
&lt;p&gt;Haskell 的列表是一个非常强大的玩意，我们可以用和 Python 中制作列表相似的方法做一个 Haskell 列表：&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;haskell&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-haskell &quot;&gt;&lt;code class=&quot;language-haskell&quot; data-lang=&quot;haskell&quot;&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;-- 直接使用字面量
&lt;&#x2F;span&gt;&lt;span&gt;[&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;1&lt;&#x2F;span&gt;&lt;span&gt;,&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;2&lt;&#x2F;span&gt;&lt;span&gt;,&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;3&lt;&#x2F;span&gt;&lt;span&gt;,&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;4&lt;&#x2F;span&gt;&lt;span&gt;,&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;5&lt;&#x2F;span&gt;&lt;span&gt;,&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;6&lt;&#x2F;span&gt;&lt;span&gt;]
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;-- 使用区间
&lt;&#x2F;span&gt;&lt;span&gt;[&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;1&lt;&#x2F;span&gt;&lt;span&gt;..&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;5&lt;&#x2F;span&gt;&lt;span&gt;]
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;-- [1,2,3,4,5]
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;-- 一般的等差数列都能推出来
&lt;&#x2F;span&gt;&lt;span&gt;[&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;1&lt;&#x2F;span&gt;&lt;span&gt;,&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;3&lt;&#x2F;span&gt;&lt;span&gt;..&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;42&lt;&#x2F;span&gt;&lt;span&gt;]
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;-- [1,3,5,7,9,11,13,15,17,19,21,23,25,27,29,31,33,35,37,39,41]
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;-- 使用列表推导式
&lt;&#x2F;span&gt;&lt;span&gt;[x*&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;2 &lt;&#x2F;span&gt;&lt;span&gt;| x &amp;lt;- [&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;1&lt;&#x2F;span&gt;&lt;span&gt;..&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;10&lt;&#x2F;span&gt;&lt;span&gt;], x*&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;2 &lt;&#x2F;span&gt;&lt;span&gt;&amp;gt;= &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;12&lt;&#x2F;span&gt;&lt;span&gt;]
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;-- 意为：对于在 [1..10] 之中的x，若有 x*2 &amp;gt;= 12，则将x*2放入列表
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Haskell列表可以被拼接：&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;haskell&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-haskell &quot;&gt;&lt;code class=&quot;language-haskell&quot; data-lang=&quot;haskell&quot;&gt;&lt;span&gt;[&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;1&lt;&#x2F;span&gt;&lt;span&gt;,&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;2&lt;&#x2F;span&gt;&lt;span&gt;]++[&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;3&lt;&#x2F;span&gt;&lt;span&gt;,&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;4&lt;&#x2F;span&gt;&lt;span&gt;]++[&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;5&lt;&#x2F;span&gt;&lt;span&gt;,&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;6&lt;&#x2F;span&gt;&lt;span&gt;]
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;-- [1,2,3,4,5,6]
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;也可以拼一个元素上去：&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;haskell&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-haskell &quot;&gt;&lt;code class=&quot;language-haskell&quot; data-lang=&quot;haskell&quot;&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;1&lt;&#x2F;span&gt;&lt;span&gt;:[&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;1&lt;&#x2F;span&gt;&lt;span&gt;,&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;2&lt;&#x2F;span&gt;&lt;span&gt;,&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;3&lt;&#x2F;span&gt;&lt;span&gt;]
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;-- [1,1,2,3]
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;-- 注意只能拼在前面
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;-- [1,2,3]:1 会报错的
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;可以各种取元素：&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;haskell&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-haskell &quot;&gt;&lt;code class=&quot;language-haskell&quot; data-lang=&quot;haskell&quot;&gt;&lt;span&gt;take &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;3&lt;&#x2F;span&gt;&lt;span&gt; [&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;1&lt;&#x2F;span&gt;&lt;span&gt;,&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;2&lt;&#x2F;span&gt;&lt;span&gt;,&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;3&lt;&#x2F;span&gt;&lt;span&gt;,&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;4&lt;&#x2F;span&gt;&lt;span&gt;,&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;5&lt;&#x2F;span&gt;&lt;span&gt;,&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;6&lt;&#x2F;span&gt;&lt;span&gt;,&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;7&lt;&#x2F;span&gt;&lt;span&gt;]
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;-- 取前三个，[1,2,3]
&lt;&#x2F;span&gt;&lt;span&gt;drop &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;3&lt;&#x2F;span&gt;&lt;span&gt; [&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;1&lt;&#x2F;span&gt;&lt;span&gt;,&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;2&lt;&#x2F;span&gt;&lt;span&gt;,&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;3&lt;&#x2F;span&gt;&lt;span&gt;,&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;4&lt;&#x2F;span&gt;&lt;span&gt;,&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;5&lt;&#x2F;span&gt;&lt;span&gt;,&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;6&lt;&#x2F;span&gt;&lt;span&gt;,&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;7&lt;&#x2F;span&gt;&lt;span&gt;]
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;-- 取前三个之外的元素，[4,5,6,7]
&lt;&#x2F;span&gt;&lt;span&gt;head [&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;1&lt;&#x2F;span&gt;&lt;span&gt;,&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;2&lt;&#x2F;span&gt;&lt;span&gt;,&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;3&lt;&#x2F;span&gt;&lt;span&gt;,&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;4&lt;&#x2F;span&gt;&lt;span&gt;,&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;5&lt;&#x2F;span&gt;&lt;span&gt;,&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;6&lt;&#x2F;span&gt;&lt;span&gt;,&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;7&lt;&#x2F;span&gt;&lt;span&gt;]
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;-- 取第一个，1
&lt;&#x2F;span&gt;&lt;span&gt;tail [&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;1&lt;&#x2F;span&gt;&lt;span&gt;,&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;2&lt;&#x2F;span&gt;&lt;span&gt;,&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;3&lt;&#x2F;span&gt;&lt;span&gt;,&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;4&lt;&#x2F;span&gt;&lt;span&gt;,&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;5&lt;&#x2F;span&gt;&lt;span&gt;,&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;6&lt;&#x2F;span&gt;&lt;span&gt;,&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;7&lt;&#x2F;span&gt;&lt;span&gt;]
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;-- 取除第一个之外的元素，[2,3,4,5,6,7]
&lt;&#x2F;span&gt;&lt;span&gt;init [&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;1&lt;&#x2F;span&gt;&lt;span&gt;,&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;2&lt;&#x2F;span&gt;&lt;span&gt;,&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;3&lt;&#x2F;span&gt;&lt;span&gt;,&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;4&lt;&#x2F;span&gt;&lt;span&gt;,&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;5&lt;&#x2F;span&gt;&lt;span&gt;,&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;6&lt;&#x2F;span&gt;&lt;span&gt;,&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;7&lt;&#x2F;span&gt;&lt;span&gt;]
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;-- 取最后一个之外的元素，[1,2,3,4,5,6]
&lt;&#x2F;span&gt;&lt;span&gt;last [&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;1&lt;&#x2F;span&gt;&lt;span&gt;,&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;2&lt;&#x2F;span&gt;&lt;span&gt;,&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;3&lt;&#x2F;span&gt;&lt;span&gt;,&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;4&lt;&#x2F;span&gt;&lt;span&gt;,&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;5&lt;&#x2F;span&gt;&lt;span&gt;,&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;6&lt;&#x2F;span&gt;&lt;span&gt;,&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;7&lt;&#x2F;span&gt;&lt;span&gt;]
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;-- 最后一个，7
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;1 &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;`&lt;&#x2F;span&gt;&lt;span&gt;elem&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;`&lt;&#x2F;span&gt;&lt;span&gt; [&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;1&lt;&#x2F;span&gt;&lt;span&gt;,&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;2&lt;&#x2F;span&gt;&lt;span&gt;,&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;3&lt;&#x2F;span&gt;&lt;span&gt;]
&lt;&#x2F;span&gt;&lt;span&gt;elem &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;1&lt;&#x2F;span&gt;&lt;span&gt; [&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;1&lt;&#x2F;span&gt;&lt;span&gt;,&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;2&lt;&#x2F;span&gt;&lt;span&gt;,&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;3&lt;&#x2F;span&gt;&lt;span&gt;]
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;-- 判断元素是否在列表中，两句等价，都为True
&lt;&#x2F;span&gt;&lt;span&gt;[&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;1&lt;&#x2F;span&gt;&lt;span&gt;,&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;2&lt;&#x2F;span&gt;&lt;span&gt;,&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;3&lt;&#x2F;span&gt;&lt;span&gt;,&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;4&lt;&#x2F;span&gt;&lt;span&gt;] !! &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;2
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;-- 取列表的第二个元素，3
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;-- 用!!有点奇怪不是吗😓
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;由于Haskell的惰性求值特性，你可以构造一个无穷的列表：&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;haskell&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-haskell &quot;&gt;&lt;code class=&quot;language-haskell&quot; data-lang=&quot;haskell&quot;&gt;&lt;span&gt;[&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;1&lt;&#x2F;span&gt;&lt;span&gt;..]
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;-- 从1开始，到无穷大为止
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;运用这个特点我们能做一些很酷的事情，比如求前10个7的倍数或末尾含7的数：&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;haskell&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-haskell &quot;&gt;&lt;code class=&quot;language-haskell&quot; data-lang=&quot;haskell&quot;&gt;&lt;span&gt;take &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;10&lt;&#x2F;span&gt;&lt;span&gt; [x | x &amp;lt;- [&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;1&lt;&#x2F;span&gt;&lt;span&gt;..], x &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;`&lt;&#x2F;span&gt;&lt;span&gt;mod&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;` &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;7 &lt;&#x2F;span&gt;&lt;span&gt;== &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;0 &lt;&#x2F;span&gt;&lt;span&gt;|| x &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;`&lt;&#x2F;span&gt;&lt;span&gt;mod&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;` &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;10 &lt;&#x2F;span&gt;&lt;span&gt;== &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;7&lt;&#x2F;span&gt;&lt;span&gt;]
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;就只有一行代码，简单方便，可读性好。&lt;&#x2F;p&gt;
&lt;p&gt;你拿命令式语言写，估计得絮絮叨叨写一大坨了吧。&lt;&#x2F;p&gt;
&lt;h3 id=&quot;zi-ji-xie-han-shu&quot;&gt;自己写函数&lt;&#x2F;h3&gt;
&lt;p&gt;Haskell的函数语法非常直白，很像数学中的函数：&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;haskell&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-haskell &quot;&gt;&lt;code class=&quot;language-haskell&quot; data-lang=&quot;haskell&quot;&gt;&lt;span&gt;triple x = &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;3&lt;&#x2F;span&gt;&lt;span&gt; * x
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;就定义好了一个函数triple，它的作用就是返回输入参数的三倍。&lt;&#x2F;p&gt;
&lt;p&gt;很像数学里的函数的写法：&lt;&#x2F;p&gt;
&lt;p&gt;$$
triple(x) = 3*x
$$&lt;&#x2F;p&gt;
&lt;p&gt;多个参数：&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;haskell&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-haskell &quot;&gt;&lt;code class=&quot;language-haskell&quot; data-lang=&quot;haskell&quot;&gt;&lt;span&gt;length x y = sqrt (x *x + y* y)
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;也很像数学中的函数：&lt;&#x2F;p&gt;
&lt;p&gt;$$
length(x, y) = \sqrt{x * x + y * y}
$$&lt;&#x2F;p&gt;
&lt;p&gt;如果函数要分类讨论，可以使用“模式匹配”等技巧，它们在函数式编程中替代了逻辑判断：&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;haskell&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-haskell &quot;&gt;&lt;code class=&quot;language-haskell&quot; data-lang=&quot;haskell&quot;&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;-- 当参数恰好匹配的时候会返回对应的值
&lt;&#x2F;span&gt;&lt;span&gt;sillyFunction &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;0 &lt;&#x2F;span&gt;&lt;span&gt;= &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;0
&lt;&#x2F;span&gt;&lt;span&gt;sillyFunction -&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;1 &lt;&#x2F;span&gt;&lt;span&gt;= &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;2
&lt;&#x2F;span&gt;&lt;span&gt;sillyFunction &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;2 &lt;&#x2F;span&gt;&lt;span&gt;= &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;3
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;-- 都没有匹配到，会进入这个默认的匹配
&lt;&#x2F;span&gt;&lt;span&gt;sillyFunction x = x&#x2F;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;2&lt;&#x2F;span&gt;&lt;span&gt;+&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;1
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;就像是：&lt;&#x2F;p&gt;
&lt;p&gt;$$
sillyFunction(x) =
\begin{equation}
\begin{cases}
0 &amp;amp; x=0 \\
-1 &amp;amp; x=2 \\
2 &amp;amp; x=3 \\
x&#x2F;2+1 &amp;amp; otherwise
\end{cases}
\end{equation}
$$&lt;&#x2F;p&gt;
&lt;p&gt;记得匹配的顺序是从上到下，因此如果参数为x的匹配放到第一个那么就会GG。&lt;&#x2F;p&gt;
&lt;p&gt;这个行为和很多现代 web 框架匹配 URL 的方式很像。&lt;&#x2F;p&gt;
&lt;p&gt;如果要匹配的是一个范围，那么应当使用“哨卫”语法：&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;haskell&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-haskell &quot;&gt;&lt;code class=&quot;language-haskell&quot; data-lang=&quot;haskell&quot;&gt;&lt;span&gt;f x
&lt;&#x2F;span&gt;&lt;span&gt; | x &amp;lt;= &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;10 &lt;&#x2F;span&gt;&lt;span&gt;= x
&lt;&#x2F;span&gt;&lt;span&gt; | x &amp;lt;= &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;20 &lt;&#x2F;span&gt;&lt;span&gt;= x&#x2F;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;2
&lt;&#x2F;span&gt;&lt;span&gt; | x &amp;lt;= &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;30 &lt;&#x2F;span&gt;&lt;span&gt;= x*x
&lt;&#x2F;span&gt;&lt;span&gt; | otherwise = x*x*x
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;就像是：&lt;&#x2F;p&gt;
&lt;p&gt;$$
f(x) =
\begin{equation}
\begin{cases}
x &amp;amp; x &amp;lt; 10 \\
x&#x2F;2 &amp;amp; 10 \le x &amp;lt; 20 \\
x \times x &amp;amp; 20 \le x &amp;lt; 30 \\
x \times x \times x &amp;amp; otherwise
\end{cases}
\end{equation}
$$&lt;&#x2F;p&gt;
&lt;p&gt;如果在列表上进行模式匹配，可以这样写：&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;haskell&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-haskell &quot;&gt;&lt;code class=&quot;language-haskell&quot; data-lang=&quot;haskell&quot;&gt;&lt;span&gt;listFunction &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;[] &lt;&#x2F;span&gt;&lt;span&gt;= &amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;Empty!&lt;&#x2F;span&gt;&lt;span&gt;&amp;quot;
&lt;&#x2F;span&gt;&lt;span&gt;listFunction (x:&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;[]&lt;&#x2F;span&gt;&lt;span&gt;) = &amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;Only One!&lt;&#x2F;span&gt;&lt;span&gt;&amp;quot;
&lt;&#x2F;span&gt;&lt;span&gt;listFunction (x:y:&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;[]&lt;&#x2F;span&gt;&lt;span&gt;) = &amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;There are two!&lt;&#x2F;span&gt;&lt;span&gt;&amp;quot;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;-- 这里要提一下，show 函数返回输入值的字符串表示
&lt;&#x2F;span&gt;&lt;span&gt;listFunction (x:y:_) = &amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;More than 2! First two are &lt;&#x2F;span&gt;&lt;span&gt;&amp;quot; ++ show x ++ &amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt; and &lt;&#x2F;span&gt;&lt;span&gt;&amp;quot; ++ show y
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;h3 id=&quot;di-gui&quot;&gt;递归&lt;&#x2F;h3&gt;
&lt;blockquote&gt;
&lt;p&gt;想要理解递归，你要先理解递归。&lt;&#x2F;p&gt;
&lt;&#x2F;blockquote&gt;
&lt;p&gt;有了上面那一堆东西，大部分命令式语言能实现的东西就能被实现了，但是我们还没讲到一样重要的东西：递归。&lt;&#x2F;p&gt;
&lt;p&gt;我们来考察“最大值”函数，它应该接受一个列表，返回列表中的最大值。&lt;&#x2F;p&gt;
&lt;p&gt;在命令式编程中，我们会使用一个循环来实现这一点。&lt;&#x2F;p&gt;
&lt;p&gt;然而我们没有循环了，该怎么办？&lt;&#x2F;p&gt;
&lt;p&gt;用递归啊。&lt;&#x2F;p&gt;
&lt;p&gt;我们可以这样想，如果一个列表里只有一个元素，那么这个元素就是最大的：&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;haskell&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-haskell &quot;&gt;&lt;code class=&quot;language-haskell&quot; data-lang=&quot;haskell&quot;&gt;&lt;span&gt;maxInList [x] = x
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;否则，就应该是这个列表第一个值和其余部分中的最大值中比较大的那个&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;haskell&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-haskell &quot;&gt;&lt;code class=&quot;language-haskell&quot; data-lang=&quot;haskell&quot;&gt;&lt;span&gt;maxInList (x:xs) = max x (maxInList xs)
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;于是就这么愉快地写好了，这个函数只有两行，如果使用命令式语言，恐怕很难用两行完成（当然你要是硬是不换行把代码都挤在一行上我也没话说）。&lt;&#x2F;p&gt;
&lt;p&gt;为了进一步展示函数式编程的美，我们来看看函数式的快速排序：&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;haskell&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-haskell &quot;&gt;&lt;code class=&quot;language-haskell&quot; data-lang=&quot;haskell&quot;&gt;&lt;span&gt;quicksort &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;[] &lt;&#x2F;span&gt;&lt;span&gt;= &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;[]
&lt;&#x2F;span&gt;&lt;span&gt;quicksort (x:xs) = (quicksort [y | y &amp;lt;- xs, y &amp;lt; x]) ++ [x] ++ (quicksort [y | y &amp;lt;- xs, y &amp;gt;= x])
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;还是只有两行，爽！&lt;&#x2F;p&gt;
&lt;h2 id=&quot;jin-jie&quot;&gt;进阶&lt;&#x2F;h2&gt;
&lt;h3 id=&quot;curry-hua-han-shu-yu-hindley-milner-lei-xing-qian-ming&quot;&gt;curry 化函数与 Hindley-Milner 类型签名&lt;&#x2F;h3&gt;
&lt;p&gt;我们前面说过Haskell中的函数可以带多个参数：&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;haskell&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-haskell &quot;&gt;&lt;code class=&quot;language-haskell&quot; data-lang=&quot;haskell&quot;&gt;&lt;span&gt;length x y = sqrt (x * x + y * y)
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;但是我实际上，我要说，所有的Haskell函数都只接受一个参数，返回一个值。&lt;&#x2F;p&gt;
&lt;p&gt;那上面那个玩意是怎么弄出来的呢？&lt;&#x2F;p&gt;
&lt;p&gt;我们先看看这个函数的类型（在GHCI中使用 &lt;code&gt;:t length&lt;&#x2F;code&gt;）：&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;haskell&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-haskell &quot;&gt;&lt;code class=&quot;language-haskell&quot; data-lang=&quot;haskell&quot;&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;length &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;:: Floating &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;a &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;=&amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;a &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;-&amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;a &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;-&amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;a
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;WTF？这是啥神仙玩意？&lt;&#x2F;p&gt;
&lt;p&gt;实际上这是一个叫 Hindley-Milner 类型签名的东西，Haskell 主要使用这种东西来标记一个函数的类型。&lt;&#x2F;p&gt;
&lt;p&gt;这个东西这样读：&lt;&#x2F;p&gt;
&lt;p&gt;Length is a fuction which takes an argument of type “a” and returns a function which (&lt;&#x2F;p&gt;
&lt;p&gt;takes an argument of type “a” and returns a value of type “a”&lt;&#x2F;p&gt;
&lt;p&gt;) where “a” is a type of typeclass Floating&lt;&#x2F;p&gt;
&lt;p&gt;用中文：&lt;&#x2F;p&gt;
&lt;p&gt;Length函数接受一个”a”类型的值作为参数，返回一个（接受一个”a”类型值作为参数，返回一个”a”类型值的函数），其中”a”是 Floating 类型类下的类型。&lt;&#x2F;p&gt;
&lt;p&gt;如果你还是觉得有点晕的话，我们给上面的类型打上括号：&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;haskell&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-haskell &quot;&gt;&lt;code class=&quot;language-haskell&quot; data-lang=&quot;haskell&quot;&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;length &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;:: Floating &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;a &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;=&amp;gt;&lt;&#x2F;span&gt;&lt;span&gt; (&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;a &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;-&amp;gt;&lt;&#x2F;span&gt;&lt;span&gt; (&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;a &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;-&amp;gt;&lt;&#x2F;span&gt;&lt;span&gt; (&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;a&lt;&#x2F;span&gt;&lt;span&gt;)))
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;可以理解为，这里一共有两个函数，一个是 `length`` 本身，它接受一个”a”类型参数，返回一个类型为&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;haskell&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-haskell &quot;&gt;&lt;code class=&quot;language-haskell&quot; data-lang=&quot;haskell&quot;&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;Floating&lt;&#x2F;span&gt;&lt;span&gt; a =&amp;gt; a -&amp;gt; a
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;的函数。&lt;&#x2F;p&gt;
&lt;p&gt;这个新的函数接受一个”a”类型参数，返回一个”a”类型的值。&lt;&#x2F;p&gt;
&lt;p&gt;所以一个 Haskell 函数只接受一个参数，然后要么返回一个函数，负责“吃掉”剩下的参数，要么返回一个值，就是函数运行的结果。&lt;&#x2F;p&gt;
&lt;p&gt;那么这样有什么好处呢？&lt;&#x2F;p&gt;
&lt;p&gt;一个好处是容易创建偏函数：&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;haskell&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-haskell &quot;&gt;&lt;code class=&quot;language-haskell&quot; data-lang=&quot;haskell&quot;&gt;&lt;span&gt;length x y = sqrt (x *x + y* y)
&lt;&#x2F;span&gt;&lt;span&gt;f = length &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;2
&lt;&#x2F;span&gt;&lt;span&gt;f &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;3 &lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;-- 即length 2 3
&lt;&#x2F;span&gt;&lt;span&gt;f &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;4 &lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;-- 即length 2 4
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;很多语言中要依赖框架才能做出来的依赖注入功能，Haskell 里很多时候直接用偏函数就解决了。&lt;&#x2F;p&gt;
&lt;h3 id=&quot;typeclass&quot;&gt;typeclass&lt;&#x2F;h3&gt;
&lt;p&gt;看到 &lt;code&gt;typeclass&lt;&#x2F;code&gt; 不要想到某些面向对象语言中的 &lt;code&gt;class&lt;&#x2F;code&gt;，相比之下，&lt;code&gt;typeclass&lt;&#x2F;code&gt; 更像 &lt;code&gt;interface&lt;&#x2F;code&gt; 或 &lt;code&gt;trait&lt;&#x2F;code&gt;，也就是表达“一种类型的能力”（ &lt;code&gt;interface&lt;&#x2F;code&gt; 大概是这个意思）而非“一个对象的能力”（ &lt;code&gt;class&lt;&#x2F;code&gt; 大概是这个意思）。&lt;&#x2F;p&gt;
&lt;p&gt;有以下一些常见的 &lt;code&gt;typeclass&lt;&#x2F;code&gt;：&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Eq 类型类&lt;&#x2F;p&gt;
&lt;p&gt;可判断相等性的类型，要求类型实现了 == 和 &#x2F;= 两个函数。&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;Ord 类型类&lt;&#x2F;p&gt;
&lt;p&gt;可比较大小的类型，要求类型实现了 compare。&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;Show 类型类&lt;&#x2F;p&gt;
&lt;p&gt;可以转成字符串，也就可以被显示出来的类型，实现show。&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;Read 类型类&lt;&#x2F;p&gt;
&lt;p&gt;可以从字符转出来的类型，实现 read。&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;Enum 类型类&lt;&#x2F;p&gt;
&lt;p&gt;可以求其前驱和后继的类型，实现 pred 和 succ。&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;Bounded 类型类&lt;&#x2F;p&gt;
&lt;p&gt;有界的类型，实现 minBound 和 maxBound。&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;Num 类型类&lt;&#x2F;p&gt;
&lt;p&gt;表示数值的类型类，基本上就是 Int、Integer、Float、Double。&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;Floating 类型类&lt;&#x2F;p&gt;
&lt;p&gt;表示浮点数的类型类，基本上就是 Float 和 Double。&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;Integeral 类型类&lt;&#x2F;p&gt;
&lt;p&gt;表示整数的类型类，基本上就是 Int（会溢出的整数）和 Integer（大整数）。&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;这些就是一些基本的类型类。&lt;&#x2F;p&gt;
&lt;p&gt;当然你可以自己做一些类型，并让它们实现某个类型类。&lt;&#x2F;p&gt;
&lt;p&gt;不过在此还是留下例子：&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;haskell&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-haskell &quot;&gt;&lt;code class=&quot;language-haskell&quot; data-lang=&quot;haskell&quot;&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;data &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;TrafficLight &lt;&#x2F;span&gt;&lt;span&gt;= &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;Red &lt;&#x2F;span&gt;&lt;span&gt;| &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;Yellow &lt;&#x2F;span&gt;&lt;span&gt;| &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;Green
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;instance Eq TrafficLight where
&lt;&#x2F;span&gt;&lt;span&gt;　　 &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;Red &lt;&#x2F;span&gt;&lt;span&gt;== &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;Red &lt;&#x2F;span&gt;&lt;span&gt;= &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;True
&lt;&#x2F;span&gt;&lt;span&gt;　　 &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;Green &lt;&#x2F;span&gt;&lt;span&gt;== &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;Green &lt;&#x2F;span&gt;&lt;span&gt;= &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;True
&lt;&#x2F;span&gt;&lt;span&gt;　　 &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;Yellow &lt;&#x2F;span&gt;&lt;span&gt;== &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;Yellow &lt;&#x2F;span&gt;&lt;span&gt;= &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;True
&lt;&#x2F;span&gt;&lt;span&gt;　　 _==_ = &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;False
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;如果你学过 Rust, 这就和 &lt;code&gt;impl Eq for TrafficLight&lt;&#x2F;code&gt; 基本上是一个意思。&lt;&#x2F;p&gt;
&lt;h2 id=&quot;shu-xue-jia-de-yi-yu&quot;&gt;数学家的呓语&lt;&#x2F;h2&gt;
&lt;p&gt;在 Haskell 中有几个 &lt;del&gt;臭名昭著&lt;&#x2F;del&gt; 特殊的 typeclass。&lt;&#x2F;p&gt;
&lt;h3 id=&quot;han-zi&quot;&gt;函子&lt;&#x2F;h3&gt;
&lt;p&gt;设 $C$ 和 $D$ 为范畴，从 $C$ 至 $D$ 的函子为一映射F:&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;将每个对象 $X \in C$ 映射至一对象 $F(X) \in D$ 上，&lt;&#x2F;li&gt;
&lt;li&gt;将每个态射 $f:X\rightarrow Y \in C$ 映射至一态射 $F(f):F(X) \rightarrow F(Y) \in D$ 上，使之满足下列条件：
&lt;ul&gt;
&lt;li&gt;对任何对象 $X \in C$ ，恒有 ${\displaystyle F(\mathbf {id} _{X})=\mathbf {id} _{F(X)}}$ 。&lt;&#x2F;li&gt;
&lt;li&gt;对任何态射 $f: X \to Y; g: Y \to Z$，恒有 $F(g \circ f) = F(g) \circ F(f)$。换言之，函子会保持单位态射与态射的复合。&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;上面这坨都是啥神仙玩意。&lt;&#x2F;p&gt;
&lt;p&gt;&lt;del&gt;数学家就喜欢把其实很简单事情搞得看上去超级复杂，美其名曰“严密”，以凸显其远超常人的智商，实际上我们都知道……好吧他们是真的很聪明TAT。&lt;&#x2F;del&gt;&lt;&#x2F;p&gt;
&lt;p&gt;在实际应用中，函子的概念可以被简单地描述为：&lt;&#x2F;p&gt;
&lt;p&gt;函子（Functor）就是可以被 map-over（即通过 map 向对象中的子对象应用一个函数）的对象。&lt;&#x2F;p&gt;
&lt;p&gt;或者，一码胜千言：&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;haskell&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-haskell &quot;&gt;&lt;code class=&quot;language-haskell&quot; data-lang=&quot;haskell&quot;&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;class &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ebcb8b;&quot;&gt;Functor &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;f &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;where
&lt;&#x2F;span&gt;&lt;span&gt;　　&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;fmap &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;::&lt;&#x2F;span&gt;&lt;span&gt; (&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;a &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;-&amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;b&lt;&#x2F;span&gt;&lt;span&gt;) &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;-&amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;f a &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;-&amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;f b
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;&lt;code&gt;Functor&lt;&#x2F;code&gt; 是一个类型类，它要求实现了它的类型实现 &lt;code&gt;fmap&lt;&#x2F;code&gt; 函数，它取一个 &lt;code&gt;(a -&amp;gt; b)&lt;&#x2F;code&gt; 和一个 &lt;code&gt;f a&lt;&#x2F;code&gt;（即 &lt;code&gt;f&lt;&#x2F;code&gt; 类型里面的 &lt;code&gt;a&lt;&#x2F;code&gt; 类型）值作为参数，返回一个 &lt;code&gt;f b&lt;&#x2F;code&gt; 的值。&lt;&#x2F;p&gt;
&lt;p&gt;比如列表就是一个Functor：&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;haskell&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-haskell &quot;&gt;&lt;code class=&quot;language-haskell&quot; data-lang=&quot;haskell&quot;&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;map &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;::&lt;&#x2F;span&gt;&lt;span&gt; (&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;a &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;-&amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;b&lt;&#x2F;span&gt;&lt;span&gt;) &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;-&amp;gt;&lt;&#x2F;span&gt;&lt;span&gt; [&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;a&lt;&#x2F;span&gt;&lt;span&gt;] &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;-&amp;gt;&lt;&#x2F;span&gt;&lt;span&gt; [&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;b&lt;&#x2F;span&gt;&lt;span&gt;]
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;instance Functor&lt;&#x2F;span&gt;&lt;span&gt; [] &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;where
&lt;&#x2F;span&gt;&lt;span&gt;　　fmap = map
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;另外，Haskell 中的 Set 和 Maybe（可空值）也是Functor。&lt;&#x2F;p&gt;
&lt;p&gt;Maybe是个好东西，下面就用它讲解了：&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;haskell&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-haskell &quot;&gt;&lt;code class=&quot;language-haskell&quot; data-lang=&quot;haskell&quot;&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;instance Functor Maybe where
&lt;&#x2F;span&gt;&lt;span&gt;    fmap func (&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;Just&lt;&#x2F;span&gt;&lt;span&gt; x) = &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;Just&lt;&#x2F;span&gt;&lt;span&gt; (func x)  &lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;-- 有东西写作 Just xxx, map上去就是Just f(xxx)
&lt;&#x2F;span&gt;&lt;span&gt;    fmap func &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;Nothing  &lt;&#x2F;span&gt;&lt;span&gt;= &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;Nothing  &lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;-- 没东西写作 Nothing, map上去还是Nothing
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;总的来说，Functor就是表现的像是容器或者上下文的一个类型，你可以通过fmap向容器中的元素应用一个操作。&lt;&#x2F;p&gt;
&lt;h3 id=&quot;applicative&quot;&gt;Applicative&lt;&#x2F;h3&gt;
&lt;p&gt;&lt;code&gt;Applicative&lt;&#x2F;code&gt; 是 &lt;code&gt;Functor&lt;&#x2F;code&gt; 的升级版本（也称 Applicative Functor），这是个啥呢？&lt;&#x2F;p&gt;
&lt;p&gt;我们已经知道了我们可以将一个函数 &lt;code&gt;map&lt;&#x2F;code&gt; 到一个&lt;code&gt;Functor&lt;&#x2F;code&gt; 上，但是如果我们要应用的函数6也在上下文中呢？&lt;&#x2F;p&gt;
&lt;p&gt;例如 &lt;code&gt;Just (+3)&lt;&#x2F;code&gt; 这种？&lt;&#x2F;p&gt;
&lt;p&gt;在已经能完成Functor所有功能的基础上，Applicative也会帮我们解开函数的上下文，然后应用：&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;haskell&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-haskell &quot;&gt;&lt;code class=&quot;language-haskell&quot; data-lang=&quot;haskell&quot;&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;class &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ebcb8b;&quot;&gt;Functor &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;f&lt;&#x2F;span&gt;&lt;span&gt; =&amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ebcb8b;&quot;&gt;Applicative &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;f &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;where  &lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;-- Applicative一定是Fuctor
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;pure &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;:: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;a &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;-&amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;f a     &lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;-- 返回一个包裹在上下文中的值
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;(&amp;lt;*&amp;gt;) &lt;&#x2F;span&gt;&lt;span&gt;:: f (a -&amp;gt; b) -&amp;gt; f a -&amp;gt; f b   &lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;-- 应用上下文中的函数
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;例如 &lt;code&gt;Maybe&lt;&#x2F;code&gt;：&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;haskell&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-haskell &quot;&gt;&lt;code class=&quot;language-haskell&quot; data-lang=&quot;haskell&quot;&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;instance Applicative Maybe where
&lt;&#x2F;span&gt;&lt;span&gt;    pure = &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;Just
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;Nothing &lt;&#x2F;span&gt;&lt;span&gt;&amp;lt;*&amp;gt; _ = &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;Nothing    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;-- 应用 Nothing 得 Nothing
&lt;&#x2F;span&gt;&lt;span&gt;    (&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;Just&lt;&#x2F;span&gt;&lt;span&gt; func) &amp;lt;*&amp;gt; something = fmap func something
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;h3 id=&quot;monad-ah-finally&quot;&gt;Monad (Ah! Finally!)&lt;&#x2F;h3&gt;
&lt;blockquote&gt;
&lt;p&gt;Monad有啥难的，不过是自函子范畴上的一个幺半群罢了。&lt;&#x2F;p&gt;
&lt;&#x2F;blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;这么说的都给我拖出去毙了。就你懂群论代数系统范畴论。😠&lt;&#x2F;p&gt;
&lt;&#x2F;blockquote&gt;
&lt;p&gt;&lt;code&gt;Monad&lt;&#x2F;code&gt; 是 &lt;code&gt;Applicative&lt;&#x2F;code&gt; 的升级版本，它在 &lt;code&gt;Applicative&lt;&#x2F;code&gt; 的基础上，添加了一个“接受一个上下文中的值和一个(接受普通值返回上下文中的值的函数)，返回一个上下文中的值”的功能。&lt;&#x2F;p&gt;
&lt;p&gt;（简化过的）Monad是这样的：&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;haskell&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-haskell &quot;&gt;&lt;code class=&quot;language-haskell&quot; data-lang=&quot;haskell&quot;&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;class &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ebcb8b;&quot;&gt;Applicative &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;m&lt;&#x2F;span&gt;&lt;span&gt; =&amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ebcb8b;&quot;&gt;Monad &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;m &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;where
&lt;&#x2F;span&gt;&lt;span&gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;return &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;:: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;a &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;-&amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;m a
&lt;&#x2F;span&gt;&lt;span&gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;(&amp;gt;&amp;gt;=) &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;:: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;m a &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;-&amp;gt;&lt;&#x2F;span&gt;&lt;span&gt; (&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;a &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;-&amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;m b&lt;&#x2F;span&gt;&lt;span&gt;) &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;-&amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;m b
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;&lt;code&gt;&amp;gt;&amp;gt;=&lt;&#x2F;code&gt; 的人话名字叫 flatMap。&lt;&#x2F;p&gt;
&lt;p&gt;同样看Maybe：&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;haskell&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-haskell &quot;&gt;&lt;code class=&quot;language-haskell&quot; data-lang=&quot;haskell&quot;&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;class &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ebcb8b;&quot;&gt;Applicative &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;Maybe&lt;&#x2F;span&gt;&lt;span&gt; =&amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ebcb8b;&quot;&gt;Monad &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;Maybe &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;where
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;return &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;:: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;a &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;-&amp;gt; Maybe &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;a
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;(&amp;gt;&amp;gt;=) &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;:: Maybe &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;a &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;-&amp;gt;&lt;&#x2F;span&gt;&lt;span&gt; (&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;a &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;-&amp;gt; Maybe &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;b&lt;&#x2F;span&gt;&lt;span&gt;) &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;-&amp;gt; Maybe &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;b
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;用起来是这种感觉的：&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;haskell&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-haskell &quot;&gt;&lt;code class=&quot;language-haskell&quot; data-lang=&quot;haskell&quot;&gt;&lt;span&gt;half x = &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;if&lt;&#x2F;span&gt;&lt;span&gt; even x
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;then &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;Just&lt;&#x2F;span&gt;&lt;span&gt; (x &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;`&lt;&#x2F;span&gt;&lt;span&gt;div&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;` &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;2&lt;&#x2F;span&gt;&lt;span&gt;)
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;else &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;Nothing
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;pre data-lang=&quot;haskell&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-haskell &quot;&gt;&lt;code class=&quot;language-haskell&quot; data-lang=&quot;haskell&quot;&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;Prelude&lt;&#x2F;span&gt;&lt;span&gt;&amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;Just 20 &lt;&#x2F;span&gt;&lt;span&gt;&amp;gt;&amp;gt;= half      &lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;-- 把Just 20塞进half函数里
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;Just 10
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;Prelude&lt;&#x2F;span&gt;&lt;span&gt;&amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;Just 20 &lt;&#x2F;span&gt;&lt;span&gt;&amp;gt;&amp;gt;= half &amp;gt;&amp;gt;= half    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;-- 把Just 20的结果塞进half函数里
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;Just 5
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;Prelude&lt;&#x2F;span&gt;&lt;span&gt;&amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;Just 20 &lt;&#x2F;span&gt;&lt;span&gt;&amp;gt;&amp;gt;= half &amp;gt;&amp;gt;= half &amp;gt;&amp;gt;= half
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;Nothing
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;链式调用，管道操作，酷毙了。&lt;&#x2F;p&gt;
&lt;h3 id=&quot;zhen-shi-shi-jie-zhong-de-functor-applicative-monad-shi-li&quot;&gt;真实世界中的 Functor&#x2F;Applicative&#x2F;Monad 实例&lt;&#x2F;h3&gt;
&lt;h4 id=&quot;future-promise&quot;&gt;Future&#x2F;Promise&lt;&#x2F;h4&gt;
&lt;p&gt;（尤其是写 JS 的）程序员们常用的 Promise&#x2F;Future 其实是一个 Monad，&lt;code&gt;flatMap&lt;&#x2F;code&gt; 其实就是 &lt;code&gt;then&lt;&#x2F;code&gt;。&lt;&#x2F;p&gt;
&lt;h4 id=&quot;option-maybe-nullable&quot;&gt;Option&#x2F;Maybe&#x2F;Nullable&lt;&#x2F;h4&gt;
&lt;p&gt;Scala, Rust 等语言中常见，同 Haskell 的 &lt;code&gt;Maybe&lt;&#x2F;code&gt;。&lt;&#x2F;p&gt;
&lt;h4 id=&quot;result&quot;&gt;Result&lt;&#x2F;h4&gt;
&lt;p&gt;同 &lt;code&gt;Option&lt;&#x2F;code&gt;, 不过是把 &lt;code&gt;None&lt;&#x2F;code&gt; 换成了具体的错误类型。&lt;&#x2F;p&gt;
&lt;h4 id=&quot;array-iterator-stream&quot;&gt;Array&#x2F;Iterator&#x2F;Stream&lt;&#x2F;h4&gt;
&lt;p&gt;数组或者任何在空间&#x2F;时间上构成一个序列的东西也是 Monad, 比如 Rust 的 &lt;code&gt;Iterator&lt;&#x2F;code&gt; trait 就包含了 &lt;code&gt;flat_map&lt;&#x2F;code&gt; 方法。&lt;&#x2F;p&gt;
&lt;h3 id=&quot;wei-shi-yao-yao-jin-yi-bu-chou-xiang-chu-zhe-xie-lei-xing-lei&quot;&gt;为什么要进一步抽象出这些类型类&lt;&#x2F;h3&gt;
&lt;p&gt;这样，一些函数就可以更好容易地被复用&lt;sup class=&quot;footnote-reference&quot;&gt;&lt;a href=&quot;#1&quot;&gt;1&lt;&#x2F;a&gt;&lt;&#x2F;sup&gt;，比如：&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;haskell&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-haskell &quot;&gt;&lt;code class=&quot;language-haskell&quot; data-lang=&quot;haskell&quot;&gt;&lt;span&gt;double x = &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;2&lt;&#x2F;span&gt;&lt;span&gt; * x
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Without concept of &lt;code&gt;Functor&lt;&#x2F;code&gt;:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;haskell&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-haskell &quot;&gt;&lt;code class=&quot;language-haskell&quot; data-lang=&quot;haskell&quot;&gt;&lt;span&gt;doubleArray     &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;[] &lt;&#x2F;span&gt;&lt;span&gt;= &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;[]
&lt;&#x2F;span&gt;&lt;span&gt;doubleArray (x:xs) = double x : doubleArray xs
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;pre data-lang=&quot;haskell&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-haskell &quot;&gt;&lt;code class=&quot;language-haskell&quot; data-lang=&quot;haskell&quot;&gt;&lt;span&gt;doubleMaybe &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;None &lt;&#x2F;span&gt;&lt;span&gt;= &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;None
&lt;&#x2F;span&gt;&lt;span&gt;doubleMaybe &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;Just&lt;&#x2F;span&gt;&lt;span&gt; x = double x
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;With concept of &lt;code&gt;Functor&lt;&#x2F;code&gt;:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;haskell&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-haskell &quot;&gt;&lt;code class=&quot;language-haskell&quot; data-lang=&quot;haskell&quot;&gt;&lt;span&gt;doubleArray = fmap double
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;pre data-lang=&quot;haskell&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-haskell &quot;&gt;&lt;code class=&quot;language-haskell&quot; data-lang=&quot;haskell&quot;&gt;&lt;span&gt;doubleMaybe = fmap double
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;你甚至不再需要分别定义 &lt;code&gt;doubleArray&lt;&#x2F;code&gt; 和 &lt;code&gt;doubleMaybe&lt;&#x2F;code&gt;，直接用 &lt;code&gt;fmap double&lt;&#x2F;code&gt; 就行。&lt;&#x2F;p&gt;
&lt;h2 id=&quot;cong-han-shu-shi-bian-cheng-dao-han-shu-shi-jia-gou&quot;&gt;从函数式编程到函数式架构&lt;&#x2F;h2&gt;
&lt;p&gt;上面这些东西都很不错，但我觉得你很难在“搬砖”的时候用到他们。&lt;&#x2F;p&gt;
&lt;p&gt;搬砖的时候最多用一下 map、reduce、filter 和少量递归的想法，几乎没有可能会（显式地）用到 Applicative 和 Monad 本身，原因很简单：他们太难了，很多人理解不能。&lt;&#x2F;p&gt;
&lt;p&gt;但是这些都是微观的函数式编程，我认为函数式思想另外一个用途在于架构上，也就是“宏观的函数式编程”。&lt;&#x2F;p&gt;
&lt;p&gt;我们想一想我们在函数式编程里学到了什么。&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;“可变的”、“副作用”是不好的&lt;&#x2F;li&gt;
&lt;li&gt;数据流&amp;gt;&amp;gt;函数&amp;gt;&amp;gt;函数&amp;gt;&amp;gt;函数 = 程序的结果&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;这些想法在架构中也能用到。&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;“可变”、“副作用”会带来管理上的复杂性，每个函数或方法必须明确“调用前要满足的条件”和“调用后会导致的副作用”，而这很可能会导致“认知超载”，故应当限制可变的东西。&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;或者说，可以将系统设计为：&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;系统状态=f(系统状态，用户行为)&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;这样系统状态的改变的唯一原因就是“用户行为”8。&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;领域层（这是从 DDD 里借来的词）&amp;gt;&amp;gt; 渲染函数 =表现层&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;将他们结合起来，我们可以得到这样一个架构：&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;有一个“领域层”&lt;&#x2F;li&gt;
&lt;li&gt;领域层 = applyAction(领域层,用户行为)&lt;&#x2F;li&gt;
&lt;li&gt;表现层 = render(领域层)&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;那么这样一个架构像什么呢？&lt;&#x2F;p&gt;
&lt;p&gt;你可以说它像 MVVM：&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;“领域层” —— VM层&lt;&#x2F;li&gt;
&lt;li&gt;render函数——由MVVM框架负责提供。&lt;&#x2F;li&gt;
&lt;li&gt;用户行为——是指用户修改了VM层的数据&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;但我认为它更像是类似 Flux 的状态管理方案：&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;“领域层”——Store&lt;&#x2F;li&gt;
&lt;li&gt;render函数——自己提供&lt;&#x2F;li&gt;
&lt;li&gt;Action——就是Action&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;相比 MVVM，Dispatcher 为 Flux 提供了一个应用 Action 的统一入口，引起 Store 变化的原因被放在 Dispatcher 里面统一管理了起来，显得更加清晰。&lt;&#x2F;p&gt;
&lt;div class=&quot;footnote-definition&quot; id=&quot;1&quot;&gt;&lt;sup class=&quot;footnote-definition-label&quot;&gt;1&lt;&#x2F;sup&gt;
&lt;p&gt;这些类型呈现出的共有数学结构提供给了我们用相同的方式将函数运用于其上的机会。&lt;&#x2F;p&gt;
&lt;&#x2F;div&gt;
</content>
        
    </entry>
    <entry xml:lang="zh">
        <title>重新开始学数学 • 数理逻辑（2）</title>
        <published>2021-03-25T09:29:44.051+00:00</published>
        <updated>2021-03-25T09:29:44.051+00:00</updated>
        <author>
          <name>Unknown</name>
        </author>
        <link rel="alternate" href="https://longfangsong.github.io/restart-math-logic-2/" type="text/html"/>
        <id>https://longfangsong.github.io/restart-math-logic-2/</id>
        
        <content type="html">&lt;h2 id=&quot;wei-ci-luo-ji&quot;&gt;谓词逻辑&lt;&#x2F;h2&gt;
&lt;h3 id=&quot;wei-ci&quot;&gt;谓词&lt;&#x2F;h3&gt;
&lt;p&gt;就是返回 &lt;code&gt;bool&lt;&#x2F;code&gt; 的函数&lt;&#x2F;p&gt;
&lt;h3 id=&quot;liang-ci&quot;&gt;量词&lt;&#x2F;h3&gt;
&lt;p&gt;就是 $\forall$ 和 $\exists$。&lt;&#x2F;p&gt;
&lt;p&gt;注意量词的优先级比 $\wedge$ 和 $\vee$ 高，例如：$\forall x A \wedge B$ 意思是 $(\forall x A) \wedge B$&lt;&#x2F;p&gt;
&lt;h3 id=&quot;substitution-ti-huan&quot;&gt;substitution（替换）&lt;&#x2F;h3&gt;
&lt;p&gt;设有一个式子 $A$，其中有一个变量 $x$，给定一个项 $t$，用 $t$ 替换所有自由出现的 $x$ 的操作称为一次 substitution，记作：&lt;&#x2F;p&gt;
&lt;p&gt;$$
A[t&#x2F;x]
$$&lt;&#x2F;p&gt;
</content>
        
    </entry>
    <entry xml:lang="zh">
        <title>重新开始学数学 • 数理逻辑（1）</title>
        <published>2021-01-12T10:01:52.110+00:00</published>
        <updated>2022-07-14T22:29:27+00:00</updated>
        <author>
          <name>Unknown</name>
        </author>
        <link rel="alternate" href="https://longfangsong.github.io/restart-math-logic-1/" type="text/html"/>
        <id>https://longfangsong.github.io/restart-math-logic-1/</id>
        
        <content type="html">&lt;h2 id=&quot;ming-ti-luo-ji&quot;&gt;命题逻辑&lt;&#x2F;h2&gt;
&lt;p&gt;我们课上学的基本上就是这些了，大部分就是一些 trivial 的是个人都能想通的东西，就是各种箭头（？）的用法容易混淆：&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;设有命题 $A$ 和 $B$，$A \rightarrow B$ 指 “$A$ 实质蕴含 $B$” 这样一个命题，即&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#2b303b;color:#c0c5ce;&quot;&gt;&lt;code&gt;&lt;span&gt;if A then B
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;设有一堆命题 $A$ 和一个命题 $B$，$A \vdash B$ 指 “$B$ 是 $A$ 的句法后承” 这样一个 sequent。&lt;&#x2F;p&gt;
&lt;p&gt;通过使用某些证明手段，从前提 $A$ 能证出 $B$，那么这个 sequent 就 valid，否则就不vaild。&lt;sup class=&quot;footnote-reference&quot;&gt;&lt;a href=&quot;#2&quot;&gt;1&lt;&#x2F;a&gt;&lt;&#x2F;sup&gt;
$$
\require{bussproofs}
\begin{prooftree}
\AxiomC{A}
\UnaryInfC{$\vdots$}
\UnaryInfC{B}
\end{prooftree}
$$&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;$ A \dashv \vdash B$：$A \vdash B$ 和 $ B \vdash A$ 都 valid，称为 $A$ 和 $B$ provably equivalent。&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;设有一堆命题 $A$ 和一个命题 $B$，$A \models B$：指 “$B$ 是 $A$ 的语义后承”，即如果 $A$ 中每一个命题都为真，则 $B$ 也为真。&lt;&#x2F;p&gt;
&lt;p&gt;在自然演绎中，$A \models B$ 当且仅当 $ A \vdash B $&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;另外常常会使用 $\top$ 和 $\bot$ 分别代表 &lt;code&gt;true&lt;&#x2F;code&gt; 和 &lt;code&gt;false&lt;&#x2F;code&gt;。&lt;&#x2F;p&gt;
&lt;h3 id=&quot;horn-gong-shi-he-horn-ke-man-zu-xing-wen-ti&quot;&gt;Horn 公式和 Horn 可满足性问题&lt;&#x2F;h3&gt;
&lt;p&gt;设 p 为原子公式，&lt;&#x2F;p&gt;
&lt;p&gt;$$
\displaylines {
P ::= \bot | \top | p \\
A ::= P \mid P \wedge A \\
C ::= A \rightarrow P \\
H ::= C \mid C \wedge H
}
$$&lt;&#x2F;p&gt;
&lt;p&gt;其中 H 就是 Horn 公式，C 就是 Horn 子句&lt;sup class=&quot;footnote-reference&quot;&gt;&lt;a href=&quot;#1&quot;&gt;2&lt;&#x2F;a&gt;&lt;&#x2F;sup&gt;。&lt;&#x2F;p&gt;
&lt;p&gt;Horn 公式的几个例子：&lt;&#x2F;p&gt;
&lt;p&gt;$$
(p \wedge q \wedge s \rightarrow p) \wedge(q \wedge r \rightarrow p) \wedge(p \wedge s \rightarrow s)
$$&lt;&#x2F;p&gt;
&lt;p&gt;$$
(p \wedge q \wedge s \rightarrow \perp) \wedge(q \wedge r \rightarrow p) \wedge(\top \rightarrow s)
$$&lt;&#x2F;p&gt;
&lt;p&gt;$$
(p_{2} \wedge p_{3} \wedge p_{5} \rightarrow p_{13}) \wedge (\top \rightarrow p_{5}) \wedge (p_{5} \wedge p_{11} \rightarrow \perp)
$$&lt;&#x2F;p&gt;
&lt;p&gt;Horn 公式的好处在于，和任意公式是否可满足（即 SAT 问题）是 NP 问题不同，HornSAT 是 P 问题，有这么一个判定算法：&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;horn_satisfiabe&lt;&#x2F;span&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;formula&lt;&#x2F;span&gt;&lt;span&gt;: HornFormula) {
&lt;&#x2F;span&gt;&lt;span&gt;  &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;let mut&lt;&#x2F;span&gt;&lt;span&gt; marked = HashSet::new();
&lt;&#x2F;span&gt;&lt;span&gt;  marked.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;add&lt;&#x2F;span&gt;&lt;span&gt;(⊤);
&lt;&#x2F;span&gt;&lt;span&gt;  &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;while let &lt;&#x2F;span&gt;&lt;span&gt;Some(p) = 
&lt;&#x2F;span&gt;&lt;span&gt;    formula.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;find&lt;&#x2F;span&gt;&lt;span&gt;(|&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;it&lt;&#x2F;span&gt;&lt;span&gt;| !it.rhs.marked &amp;amp;&amp;amp; 
&lt;&#x2F;span&gt;&lt;span&gt;      it.lhs.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;all&lt;&#x2F;span&gt;&lt;span&gt;(|&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;it&lt;&#x2F;span&gt;&lt;span&gt;| marked.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;contains&lt;&#x2F;span&gt;&lt;span&gt;(it))
&lt;&#x2F;span&gt;&lt;span&gt;    ).&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;map&lt;&#x2F;span&gt;&lt;span&gt;(|&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;it&lt;&#x2F;span&gt;&lt;span&gt;| it.rhs) {
&lt;&#x2F;span&gt;&lt;span&gt;    marked.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;add&lt;&#x2F;span&gt;&lt;span&gt;(p);
&lt;&#x2F;span&gt;&lt;span&gt;  }
&lt;&#x2F;span&gt;&lt;span&gt;  &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;return &lt;&#x2F;span&gt;&lt;span&gt;!marked.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;contains&lt;&#x2F;span&gt;&lt;span&gt;(⊥);
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;h3 id=&quot;sat-qiu-jie-qi&quot;&gt;Sat 求解器&lt;&#x2F;h3&gt;
&lt;p&gt;感觉这里书上讲的好复杂……&lt;&#x2F;p&gt;
&lt;p&gt;其实就是自顶而下地考虑一个公式的 parse tree，对公式本身每一个子公式的值，如果能通过上层的值和算符的真值表直接判定就直接判定，比如：&lt;&#x2F;p&gt;
&lt;p&gt;$$
\top = \neg p \wedge q
$$&lt;&#x2F;p&gt;
&lt;p&gt;从上层的 $\top$ 和 $\wedge$ 的性质我们就能得出
$$
\neg p = \top
$$&lt;&#x2F;p&gt;
&lt;p&gt;$$
q = \top
$$&lt;&#x2F;p&gt;
&lt;p&gt;不行的话（比如遇到了类似 $\top = p \vee q$ 的情况）就随便选一个子公式把 $\top$ 和 $\bot$ 都试一遍，如果推出了冲突的结论就回溯，如果全判定完了没冲突就成了。&lt;&#x2F;p&gt;
&lt;div class=&quot;footnote-definition&quot; id=&quot;1&quot;&gt;&lt;sup class=&quot;footnote-definition-label&quot;&gt;2&lt;&#x2F;sup&gt;
&lt;p&gt;“子句” 的定义是原子公式或 “$\neg 原子公式$” 的析取。&lt;&#x2F;p&gt;
&lt;&#x2F;div&gt;
&lt;div class=&quot;footnote-definition&quot; id=&quot;2&quot;&gt;&lt;sup class=&quot;footnote-definition-label&quot;&gt;1&lt;&#x2F;sup&gt;
&lt;p&gt;Useless fact: 下面这些横线称为 deduction bar。&lt;&#x2F;p&gt;
&lt;&#x2F;div&gt;
</content>
        
    </entry>
    <entry xml:lang="zh">
        <title>分布式系统 • 时钟</title>
        <published>2020-12-10T22:42:11.815+00:00</published>
        <updated>2020-12-10T22:42:11.815+00:00</updated>
        <author>
          <name>Unknown</name>
        </author>
        <link rel="alternate" href="https://longfangsong.github.io/clocks-in-distributed-system/" type="text/html"/>
        <id>https://longfangsong.github.io/clocks-in-distributed-system/</id>
        
        <content type="html">&lt;h2 id=&quot;wei-shi-yao-zai-fen-bu-shi-xi-tong-zhong-shi-zhong-hen-zhong-yao&quot;&gt;为什么在分布式系统中时钟很重要&lt;&#x2F;h2&gt;
&lt;p&gt;最简单的一个例子：一个读请求和一个修改请求（在外界观察者眼中）先后来到一个系统中的两个不同的节点上（假设所有节点的存储是通过某些“魔法”手段连在一起的），按道理由于读请求先发生，那么他不应当读到写请求写入的数据。但是如果两个节点上的物理时钟出了问题，处理读请求的时钟快了（认为请求到来时的时间戳比较大），而处理写请求的时钟慢了（认为请求到来时的时间戳比较小），此时按照时钟判断出的读写顺序就和实际不同了，这就会带来读写操作进行的顺序和预期不符。&lt;&#x2F;p&gt;
&lt;p&gt;即使是同一个节点上也会遇到时钟由于走的太快而被 NTP 这样的时间同步算法回拨，导致的时间戳不唯一的问题。&lt;&#x2F;p&gt;
&lt;p&gt;可见分布式系统中直接根据物理时钟决定事件发生的先后顺序是不可行的，原因是不同系统中的物理时钟其快慢是无法保证的。&lt;&#x2F;p&gt;
&lt;p&gt;而目前最好的时间校准算法 NTP 也无法很好的保证精度，网络这个东西实在是太不可靠了……&lt;&#x2F;p&gt;
&lt;h2 id=&quot;tso&quot;&gt;TSO&lt;&#x2F;h2&gt;
&lt;p&gt;实际上我们可以确定的一种顺序就是同一节点上事件发生的顺序：&lt;&#x2F;p&gt;
&lt;blockquote&gt;
&lt;p&gt;公理1：在同一节点上有序的两个事件在外界观察者眼中也有序&lt;&#x2F;p&gt;
&lt;&#x2F;blockquote&gt;
&lt;p&gt;那么很简单的一个想法就是：在每次有请求来到系统时，都要经过一个负责分配单调递增的时间戳的节点，给这个请求分配时间戳&lt;&#x2F;p&gt;
&lt;p&gt;但是这样系统里面就出现了这么一个不能扩展的单点，而且这个节点理论上不能宕掉，否则就算是切换新的时间戳分配节点，这个新旧节点之间的时间戳的差异也会造成问题，至少也会引起一个等于“节点之间最大可能物理时间的差距”（通过物理时钟分配时间戳）或者“一个从某种持久化存储中读取数据”（使用累加计数器分配时间戳）的延迟。&lt;&#x2F;p&gt;
&lt;h2 id=&quot;tong-xin-he-luo-ji-shi-zhong&quot;&gt;通信和逻辑时钟&lt;&#x2F;h2&gt;
&lt;p&gt;（两个节点之间的）通信必定有一个发送事件和一个接收事件，分别发生在两个节点上，而无论在任何观察者眼中发送一定先于接收，所以我们可以通过通信来确定一些事件的先后&lt;sup class=&quot;footnote-reference&quot;&gt;&lt;a href=&quot;#1&quot;&gt;1&lt;&#x2F;a&gt;&lt;&#x2F;sup&gt;：&lt;&#x2F;p&gt;
&lt;blockquote&gt;
&lt;p&gt;公理2：对于某个通信，在外界观察者眼中发送先于接收&lt;&#x2F;p&gt;
&lt;&#x2F;blockquote&gt;
&lt;p&gt;结合公理1和公理2，有：&lt;&#x2F;p&gt;
&lt;blockquote&gt;
&lt;p&gt;定理1：对于某个通信，&amp;quot;通信发送之前发生的事件&amp;quot;在外界观察者眼中发生在&amp;quot;通信接收之后发生的事件&amp;quot;之后&lt;&#x2F;p&gt;
&lt;&#x2F;blockquote&gt;
&lt;p&gt;根据这一定理，我们可以通过这个逻辑时间戳建立事件间关于“happens before”的&lt;strong&gt;偏序关系&lt;&#x2F;strong&gt;，即我们可以比较一部分事件的先后关系。&lt;&#x2F;p&gt;
&lt;p&gt;由此 Lamport 创造了 Lamport 逻辑时钟算法：&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;每个节点初始时间戳都为0&lt;&#x2F;li&gt;
&lt;li&gt;每次发生消息交换之外的事件时，本地时间戳 +1&lt;&#x2F;li&gt;
&lt;li&gt;每次发送消息，本地时间戳+1，并带在消息里&lt;&#x2F;li&gt;
&lt;li&gt;每次接收消息，如果消息中的时间戳比本地时间大，那么本地时间戳 = 消息时间戳 + 1，否则正常本地时间戳 + 1‘&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;即每次发生事件，都保证 &lt;code&gt;本地时间戳 = 节点看到过的最大时间戳 + 1&lt;&#x2F;code&gt;&lt;&#x2F;p&gt;
&lt;h3 id=&quot;bao-zheng-liao-shi-yao&quot;&gt;保证了什么&lt;&#x2F;h3&gt;
&lt;p&gt;Lamport逻辑时钟保证了：&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;若系统外部观察者看到事件A在事件B前发生，则系统内部必有 事件A对应的时间戳&amp;lt;事件B对应的时间戳。&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;但反之则不一定成立，即时间戳的大小并不能决定事件的发生顺序。&lt;&#x2F;p&gt;
&lt;h3 id=&quot;quan-xu-hua-gai-jin&quot;&gt;全序化改进&lt;&#x2F;h3&gt;
&lt;p&gt;可以暴力地给每个节点一个编号，把时间戳的定义改为 &lt;code&gt;concat(原本的时间戳, 节点编号)&lt;&#x2F;code&gt;，这样人为地通过时间戳之间的全序关系为事件定出一个全序关系。&lt;&#x2F;p&gt;
&lt;p&gt;虽然这个全序关系和事件在外界观察者眼中的顺序并没有绝对的关系，但是方便了我们进行一些应用。&lt;&#x2F;p&gt;
&lt;h4 id=&quot;ying-yong-lamport-suo&quot;&gt;应用：Lamport 锁&lt;&#x2F;h4&gt;
&lt;p&gt;Lamport锁是一个经典的分布式锁算法，理论上可以在分布式系统中保证某一个资源同一时间只有一个访问者。&lt;&#x2F;p&gt;
&lt;p&gt;算法如下：&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;每个节点维护一个等锁队列&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;当一个节点想要锁上一个资源供自己访问时，发送一个请求锁的消息给所有节点，eg：&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#2b303b;color:#c0c5ce;&quot;&gt;&lt;code&gt;&lt;span&gt;Node A 想要锁上这个资源
&lt;&#x2F;span&gt;&lt;span&gt;—— 发送于 时间戳 T
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;并将这个请求消息放入自己的存储中&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;收到消息后，发送一个确认消息，eg：&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#2b303b;color:#c0c5ce;&quot;&gt;&lt;code&gt;&lt;span&gt;Node B 已收到 Node A 的请求
&lt;&#x2F;span&gt;&lt;span&gt;—— 发送于 时间戳 T&amp;#39;
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;由 Lamport 逻辑时钟算法，T&#x27; &amp;gt; T&lt;&#x2F;p&gt;
&lt;p&gt;并将这个请求消息放入自己的存储中&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;如果某个节点&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;存储里的所有消息中，来自自己的请求的时间戳是最小的&lt;&#x2F;li&gt;
&lt;li&gt;从所有其他节点都收到过，时间戳大于上面说的这个请求的时间戳的消息&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;那么它可以认为自己获取到了这个资源上的锁。&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;当节点用完资源准备释放时，删除自己的储存中所有来自自身的请求消息，然后发送删除自己的锁请求的消息：&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#2b303b;color:#c0c5ce;&quot;&gt;&lt;code&gt;&lt;span&gt;Node A 释放了这个资源
&lt;&#x2F;span&gt;&lt;span&gt;—— 发送于时间戳 XXX
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;其他节点收到后也从自己的存储中删掉所有来自这一节点的请求消息&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;以上就是 Lamport 锁算法。&lt;&#x2F;p&gt;
&lt;h5 id=&quot;tla-proof&quot;&gt;TLA+ Proof&lt;&#x2F;h5&gt;
&lt;p&gt;TODO&lt;&#x2F;p&gt;
&lt;h5 id=&quot;que-xian&quot;&gt;缺陷&lt;&#x2F;h5&gt;
&lt;p&gt;Lamport 锁并没有任何容错机制，无论是网络不通还是节点挂掉，他一概防不出去。&lt;&#x2F;p&gt;
&lt;h2 id=&quot;xiang-liang-shi-zhong&quot;&gt;向量时钟&lt;&#x2F;h2&gt;
&lt;p&gt;向量时钟是对 Lamport 逻辑时钟的一种改进，Lamport 逻辑时钟里面拿到的时间戳……并没有什么卵用，因为凭时间戳的大小并不能确定其他节点上事件的发生顺序，这一情况的根本原因是这里的时间戳只能指示当前节点对&lt;strong&gt;自身&lt;&#x2F;strong&gt;事件推进的认识，而正如我们前面所述，同一节点上的时间戳可以确定出顺序，那么我们是不是能让每个节点上都有所有节点的时间信息？&lt;&#x2F;p&gt;
&lt;p&gt;这就是向量时钟的想法：&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;将原本 Lamport 时钟中每个节点上一个的时间戳改成 为每个节点（包括自己）都设立一个时间戳，这构成了一个时间戳向量&lt;&#x2F;li&gt;
&lt;li&gt;发生事件时更新（+1）时间戳向量中自己对应的那个元素&lt;&#x2F;li&gt;
&lt;li&gt;在发送消息时，发送整个时间戳向量&lt;&#x2F;li&gt;
&lt;li&gt;接收消息时，根据发来的时间戳向量更新自己的时间戳向量（对向量中的每个元素应用 Lamport 时间戳的更新算法）&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;使用向量时钟，我们可以确定部分事件的先后关系：&lt;&#x2F;p&gt;
&lt;p&gt;假设事件 x、y 分别发生在节点 A、B 上：&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;若事件x发生时的时间戳向量（自然是从 A 上取得）中，每个元素全部都小于等于事件  y发生时的时间戳向量的对应元素（从 B 上取得），则 x 早于 y 发生，反之亦然&lt;&#x2F;li&gt;
&lt;li&gt;若两个时间戳向量中的各个元素大小关系各有不同，则不能比较出其发生的先后，可以认为这两个事件是并发发生的。&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;这样，我们可以通过时间戳向量确定很大一部分事件的先后关系。&lt;&#x2F;p&gt;
&lt;h2 id=&quot;hybrid-logical-clocks-hlc&quot;&gt;Hybrid Logical Clocks (HLC)&lt;&#x2F;h2&gt;
&lt;p&gt;向量时钟这样的逻辑时钟虽然让我们能确定一部分事件的先后关系，但是其问题在于只在系统内部有用，而对于系统外部的时间一无所知。这在我们想要知道外部事件的先后顺序或者根据物理时间查询事件时非常不利，而物理时钟又是那么的不可靠。&lt;&#x2F;p&gt;
&lt;p&gt;于是就有了混合时钟这种试图把物理和逻辑时钟结合起来的方案。&lt;&#x2F;p&gt;
&lt;h3 id=&quot;shi-xian&quot;&gt;实现&lt;&#x2F;h3&gt;
&lt;p&gt;容易想到的方法是，每次发送和接收消息时，都在Lamport时间戳的基础上，再多做一个和物理时钟做max的操作，即：&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;发送消息前或者本地发生新的事件，时间戳 = max(时间戳+1, 物理时钟)&lt;&#x2F;li&gt;
&lt;li&gt;接收到消息后，时间戳 = max(本地时间戳+1, 消息时间戳+1, 物理时钟)&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;问题在于这样搞时间戳是可以比物理时间无限制地快下去的，例如所有请求都从某个节点非常快地进入系统，并广播到其他节点，其他节点也对每个事件发送了回复，那就会造成时间戳不断+1，导致时间戳远比物理时间大，此时时间戳相当于退化成了普通的逻辑时钟，让我们失去了对物理时间的感知。&lt;&#x2F;p&gt;
&lt;p&gt;我们可以看出这一实现主要的问题在于大量时间可能会造成时间戳过快的增长而物理时钟赶不上的问题，那我们能不能记录一下物理时钟落后了多少来修正这个问题呢？&lt;&#x2F;p&gt;
&lt;p&gt;这就是 HLC 算法的想法：&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;HLC 时间戳分为两个部分，“物理”部分（常实现为一个变量的高位）和“逻辑”部分（常实现为一个变量的低位）&lt;&#x2F;li&gt;
&lt;li&gt;发送消息前或者本地发生事件
&lt;ul&gt;
&lt;li&gt;若 HLC 时间戳“物理”部分小于现在的物理时钟，证明物理时钟已经赶上了事件发生的速度，此时只需把“物理”部分更新为新的物理时间戳，并将“逻辑”部分清0即可&lt;&#x2F;li&gt;
&lt;li&gt;若 HLC 时间戳“物理”部分大于（物理时钟被回拨时会发生大于的情况）等于现在的物理时钟，证明物理时钟没有赶上了事件发生的速度，此时只需向“逻辑”部分加一即可&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;收到消息后：
&lt;ul&gt;
&lt;li&gt;比较 本地 HLC 时间戳“物理”部分、消息 HLC 时间戳“物理”部分、本地物理时间戳 三者
&lt;ul&gt;
&lt;li&gt;本地 HLC 时间戳“物理”部分和消息“物理”部分相等，同大于本地物理时间戳，证明本地物理时钟既没有赶上本地事件发生的速度，也没有赶上消息发送方上事件发生的速度，那么本地“逻辑”部分的值就可以更新为 &lt;code&gt;max(本地“逻辑”部分, 消息“逻辑”部分) + 1&lt;&#x2F;code&gt;&lt;&#x2F;li&gt;
&lt;li&gt;本地 HLC 时间戳“物理”部分 是其中最大的，说明消息发送方的物理时钟落后于本地物理时钟，但由于 本地物理时间戳 仍然小于 本地 HLC 时间戳的“物理”部分 说明本地物理时间戳没有赶上事件发生的速度，需要向“逻辑”部分加一&lt;&#x2F;li&gt;
&lt;li&gt;消息的 HLC 时间戳“物理”部分 是其中最大的（无论他与本地物理时间戳是否相等），说明本地 HLC 时钟完全落后于消息发送方，那么本地的时间戳就需要直接更新为消息的 HLC 时间戳再在“逻辑”部分加一的结果&lt;&#x2F;li&gt;
&lt;li&gt;本地物理时间戳 是其中最大的，证明物理时钟已经赶上了本地和发送方事件发生的速度，此时只需把“物理”部分更新为新的物理时间戳，并将“逻辑”部分清0即可&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;简单的思考就是： &lt;&#x2F;p&gt;
&lt;ol&gt;
&lt;li&gt;为防止在物理时钟 回拨 或者 精度不足以区别事件先后 时物理时钟无法确定本地事件顺序的问题，增设了一个“逻辑”部分，用来
&lt;ul&gt;
&lt;li&gt;在时钟回拨时让 HLC 时间戳“物理”部分不跟着回拨，而是通过这个逻辑部分确定先后，从而保证时钟的单调性&lt;&#x2F;li&gt;
&lt;li&gt;在物理时钟精度不足时使用逻辑部分确定先后&lt;&#x2F;li&gt;
&lt;li&gt;如果物理时钟比 HLC 时钟“走得快”，就相信物理时钟&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;通信后，保证自己的 HLC 时间戳不比消息的 HLC 时间戳早&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
&lt;h3 id=&quot;bao-zheng-liao-shi-yao-1&quot;&gt;保证了什么&lt;&#x2F;h3&gt;
&lt;ol&gt;
&lt;li&gt;对任何事件x和y，若x发生在y之前，则 x对应的 HLC 时间戳 &amp;lt; y 对应的 HLC 时间戳&lt;&#x2F;li&gt;
&lt;li&gt;HLC 时间戳对应的物理时间和节点实际的物理时间的差有确定的上限，这个上限基本上是 两倍的机器的时间和ntp server时间存在的 误差范围（ntp offset），平时这个 offset 一般都是几个 ms。&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
&lt;h3 id=&quot;tla-proof-1&quot;&gt;TLA+ Proof&lt;&#x2F;h3&gt;
&lt;p&gt;TODO&lt;&#x2F;p&gt;
&lt;div class=&quot;footnote-definition&quot; id=&quot;1&quot;&gt;&lt;sup class=&quot;footnote-definition-label&quot;&gt;1&lt;&#x2F;sup&gt;
&lt;p&gt;有些人将定理1和2确定出的时间顺序关系称为“因果关系”，但是个人并不觉得这是个好名字，因为这些事件之间并不一定存在谁引起谁，借用这个名词可能会产生误解&lt;&#x2F;p&gt;
&lt;&#x2F;div&gt;
</content>
        
    </entry>
    <entry xml:lang="zh">
        <title>Parsing • LR(0)分析</title>
        <published>2020-05-22T22:56:58.045+00:00</published>
        <updated>2020-05-22T22:56:58.045+00:00</updated>
        <author>
          <name>Unknown</name>
        </author>
        <link rel="alternate" href="https://longfangsong.github.io/lr0/" type="text/html"/>
        <id>https://longfangsong.github.io/lr0/</id>
        
        <content type="html">&lt;p&gt;如果你已经理解了&lt;a href=&quot;https:&#x2F;&#x2F;longfangsong.github.io&#x2F;shift-reduce&#x2F;&quot;&gt;移进-归约分析&lt;&#x2F;a&gt;的基本执行流程了，那么你一定会问，我该如何决定某个步骤上应该“移进”还是应该“归约”呢？应该选择哪个推导式来归约呢？如果我们构造的文法和表达式求值一样简单，那手动根据“栈中现有的值”和“下面要输入的值”来判断就可以了，那么如果我们处理的文法比较复杂呢？&lt;&#x2F;p&gt;
&lt;p&gt;举一个经典的表达式文法的例子：&lt;&#x2F;p&gt;
&lt;p&gt;$$
E \rightarrow E+T|T
$$&lt;&#x2F;p&gt;
&lt;p&gt;$$
T \rightarrow T*F|F
$$&lt;&#x2F;p&gt;
&lt;p&gt;$$
F \rightarrow (E) | \textbf{id}
$$&lt;&#x2F;p&gt;
&lt;p&gt;我们来模拟一下匹配字符串 $\textbf{id}*\textbf{id}+(\textbf{id}+\textbf{id})*\textbf{id}$ 的过程，并尝试解释每一步选择移进还是归约的原因。&lt;&#x2F;p&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;符号栈&lt;&#x2F;th&gt;&lt;th&gt;剩余输入&lt;&#x2F;th&gt;&lt;th&gt;动作&lt;&#x2F;th&gt;&lt;th&gt;原因&lt;&#x2F;th&gt;&lt;&#x2F;tr&gt;&lt;&#x2F;thead&gt;&lt;tbody&gt;
&lt;tr&gt;&lt;td&gt;&lt;&#x2F;td&gt;&lt;td&gt;$\textbf{id}*\textbf{id}+(\textbf{id}+\textbf{id})*\textbf{id}$&lt;&#x2F;td&gt;&lt;td&gt;移进 $\textbf{id}$&lt;&#x2F;td&gt;&lt;td&gt;没得选&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;$\textbf{id}$&lt;&#x2F;td&gt;&lt;td&gt;$*\textbf{id}+(\textbf{id}+\textbf{id})*\textbf{id}$&lt;&#x2F;td&gt;&lt;td&gt;栈顶归约为 $F$&lt;&#x2F;td&gt;&lt;td&gt;下一个符号是$*$，而没有包含 $\textbf{id} *$ 的规则，但栈顶可以归约&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;$F$&lt;&#x2F;td&gt;&lt;td&gt;$*\textbf{id}+(\textbf{id}+\textbf{id})*\textbf{id}$&lt;&#x2F;td&gt;&lt;td&gt;栈顶归约为 $T$&lt;&#x2F;td&gt;&lt;td&gt;下一个符号是$*$，而没有包含$F *$ 的规则，但栈顶可以归约&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;$T$&lt;&#x2F;td&gt;&lt;td&gt;$*\textbf{id}+(\textbf{id}+\textbf{id})*\textbf{id}$&lt;&#x2F;td&gt;&lt;td&gt;移进 $*$&lt;&#x2F;td&gt;&lt;td&gt;下一个符号是$*$， 而没有包含 $ T *$ 的规则&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;$T*$&lt;&#x2F;td&gt;&lt;td&gt;$\textbf{id}+(\textbf{id}+\textbf{id})*\textbf{id}$&lt;&#x2F;td&gt;&lt;td&gt;移进 $\textbf{id}$&lt;&#x2F;td&gt;&lt;td&gt;栈顶不能归约，只能移进&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;$T*\textbf{id}$&lt;&#x2F;td&gt;&lt;td&gt;$+(\textbf{id}+\textbf{id})*\textbf{id}$&lt;&#x2F;td&gt;&lt;td&gt;栈顶归约为 $F$&lt;&#x2F;td&gt;&lt;td&gt;下一个符号是$+$，而没有包含 $T *\textbf{id}+$ 或者 $\textbf{id}+$ 的规则，但栈顶可以归约&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;$T*F$&lt;&#x2F;td&gt;&lt;td&gt;$+(\textbf{id}+\textbf{id})*\textbf{id}$&lt;&#x2F;td&gt;&lt;td&gt;栈顶归约为 $T$&lt;&#x2F;td&gt;&lt;td&gt;下一个符号是$+$，而没有包含$T * F+$ 或者 $F+$ 的规则，但栈顶可以归约&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;$T$&lt;&#x2F;td&gt;&lt;td&gt;$+(\textbf{id}+\textbf{id})*\textbf{id}$&lt;&#x2F;td&gt;&lt;td&gt;栈顶归约为 $E$&lt;&#x2F;td&gt;&lt;td&gt;下一个符号是$+$，而没有包含$T+$ 的规则，但栈顶可以归约&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;$E$&lt;&#x2F;td&gt;&lt;td&gt;$+(\textbf{id}+\textbf{id})*\textbf{id}$&lt;&#x2F;td&gt;&lt;td&gt;移进 $+$&lt;&#x2F;td&gt;&lt;td&gt;栈顶不能归约，只能移进&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;$E+$&lt;&#x2F;td&gt;&lt;td&gt;$(\textbf{id}+\textbf{id})*\textbf{id}$&lt;&#x2F;td&gt;&lt;td&gt;移进 $($&lt;&#x2F;td&gt;&lt;td&gt;栈顶不能归约，只能移进&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;$E+($&lt;&#x2F;td&gt;&lt;td&gt;$\textbf{id}+\textbf{id})*\textbf{id}$&lt;&#x2F;td&gt;&lt;td&gt;移进 $\textbf{id}$&lt;&#x2F;td&gt;&lt;td&gt;栈顶不能归约，只能移进&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;$E+(\textbf{id}$&lt;&#x2F;td&gt;&lt;td&gt;$+\textbf{id})*\textbf{id}$&lt;&#x2F;td&gt;&lt;td&gt;栈顶归约为 $F$&lt;&#x2F;td&gt;&lt;td&gt;下一个符号是$+$，而没有包含 $\textbf{id}+$ 的规则，但栈顶可以归约&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;$E+(F$&lt;&#x2F;td&gt;&lt;td&gt;$+\textbf{id})*\textbf{id}$&lt;&#x2F;td&gt;&lt;td&gt;栈顶归约为 $T$&lt;&#x2F;td&gt;&lt;td&gt;下一个符号是$+$，而没有包含 $F+$ 的规则，但栈顶可以归约&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;$E+(T$&lt;&#x2F;td&gt;&lt;td&gt;$+\textbf{id})*\textbf{id}$&lt;&#x2F;td&gt;&lt;td&gt;栈顶归约为 $E$&lt;&#x2F;td&gt;&lt;td&gt;下一个符号是$+$，而没有 包含 $T+$ 的规则，但栈顶可以归约&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;$E+(E$&lt;&#x2F;td&gt;&lt;td&gt;$+\textbf{id})*\textbf{id}$&lt;&#x2F;td&gt;&lt;td&gt;移进&lt;&#x2F;td&gt;&lt;td&gt;栈顶不能归约，只能移进&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;$E+(E+$&lt;&#x2F;td&gt;&lt;td&gt;$\textbf{id})*\textbf{id}$&lt;&#x2F;td&gt;&lt;td&gt;移进&lt;&#x2F;td&gt;&lt;td&gt;栈顶不能归约，只能移进&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;$E+(E+\textbf{id}$&lt;&#x2F;td&gt;&lt;td&gt;$)*\textbf{id}$&lt;&#x2F;td&gt;&lt;td&gt;栈顶归约为 $F$&lt;&#x2F;td&gt;&lt;td&gt;下一个符号是$)$，而没有 包含 $\textbf{id})$ 的规则，但栈顶可以归约&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;$E+(E+F$&lt;&#x2F;td&gt;&lt;td&gt;$)*\textbf{id}$&lt;&#x2F;td&gt;&lt;td&gt;栈顶归约为 $T$&lt;&#x2F;td&gt;&lt;td&gt;下一个符号是$)$，而没有 包含 $F)$ 的规则，但栈顶可以归约&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;$E+(E+T$&lt;&#x2F;td&gt;&lt;td&gt;$)*\textbf{id}$&lt;&#x2F;td&gt;&lt;td&gt;栈顶归约为 $E$&lt;&#x2F;td&gt;&lt;td&gt;下一个符号是$+$，而没有包含 $T)$ 的规则，但栈顶可以归约&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;$E+(E+E$&lt;&#x2F;td&gt;&lt;td&gt;$)*\textbf{id}$&lt;&#x2F;td&gt;&lt;td&gt;移进&lt;&#x2F;td&gt;&lt;td&gt;栈顶不能归约，只能移进&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;$E+(E+E)$&lt;&#x2F;td&gt;&lt;td&gt;$*\textbf{id}$&lt;&#x2F;td&gt;&lt;td&gt;栈顶归约为 $F$&lt;&#x2F;td&gt;&lt;td&gt;下一个符号是$*$，没有包含 $)*$ 的规则，但栈顶可以归约&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;$E+F$&lt;&#x2F;td&gt;&lt;td&gt;$*\textbf{id}$&lt;&#x2F;td&gt;&lt;td&gt;栈顶归约为 $T$&lt;&#x2F;td&gt;&lt;td&gt;下一个符号是$*$，没有包含 $F*$ 的规则，但栈顶可以归约&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;$E+T$&lt;&#x2F;td&gt;&lt;td&gt;$*\textbf{id}$&lt;&#x2F;td&gt;&lt;td&gt;移进&lt;&#x2F;td&gt;&lt;td&gt;这里是tricky的地方，这里考虑到优先级问题必须移进，这样看来**优先移进，不行了再归约可能是处理优先级问题的方案**&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;$E+T*$&lt;&#x2F;td&gt;&lt;td&gt;$\textbf{id}$&lt;&#x2F;td&gt;&lt;td&gt;移进&lt;&#x2F;td&gt;&lt;td&gt;栈顶不能归约，只能移进&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;$E+T*\textbf{id}$&lt;&#x2F;td&gt;&lt;td&gt;&lt;&#x2F;td&gt;&lt;td&gt;栈顶归约为 $F$&lt;&#x2F;td&gt;&lt;td&gt;没有符号了，往死里归约&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;$E+T*F$&lt;&#x2F;td&gt;&lt;td&gt;&lt;&#x2F;td&gt;&lt;td&gt;栈顶归约为 $T$&lt;&#x2F;td&gt;&lt;td&gt;没有符号了，往死里归约&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;$E+T$&lt;&#x2F;td&gt;&lt;td&gt;&lt;&#x2F;td&gt;&lt;td&gt;栈顶归约为 $E$&lt;&#x2F;td&gt;&lt;td&gt;没有符号了，往死里归约&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;$E$&lt;&#x2F;td&gt;&lt;td&gt;&lt;&#x2F;td&gt;&lt;td&gt;接受&lt;&#x2F;td&gt;&lt;td&gt;&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;&#x2F;tbody&gt;&lt;&#x2F;table&gt;
&lt;p&gt;这是一个漫长的过程，在这个过程中我们发现：&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;为了处理运算符的优先级，优先进行移进
&lt;ul&gt;
&lt;li&gt;这和我们编写计算器的方式很像&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;在移进会导致栈中不包含某个可以归约的“前缀”时，必须先归约&lt;&#x2F;li&gt;
&lt;li&gt;在栈中的内容不同时，要考虑的是否可以归约的部分也不一样
&lt;ul&gt;
&lt;li&gt;例如在处理栈为 $T*$ 和 $E+T*$ 时，其实都只要考虑 $T*$ 的部分就可以了&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;那么我们可以看一下有哪些方法解决这些问题。&lt;&#x2F;p&gt;
&lt;h2 id=&quot;lr-0-xiang-zhuang-tai-chan-sheng-shi-zhong-de-cdot-yu-lr-0-zhuang-tai-ji&quot;&gt;LR(0)项、状态、产生式中的 “$\cdot$” 与LR(0) 状态机&lt;&#x2F;h2&gt;
&lt;p&gt;我们从前面的最后一个问题开始着手。&lt;&#x2F;p&gt;
&lt;p&gt;我们看 $E+T*$ 这里，在这种&lt;strong&gt;状态&lt;&#x2F;strong&gt;下，我们能用来归约的产生式只有 $T \rightarrow T*F$ 一个，会归约到栈顶上多了一个 $T$ 的状态。&lt;sup class=&quot;footnote-reference&quot;&gt;&lt;a href=&quot;#0&quot;&gt;1&lt;&#x2F;a&gt;&lt;&#x2F;sup&gt;&lt;&#x2F;p&gt;
&lt;p&gt;而在 $T*$ 这里，在这种&lt;strong&gt;状态&lt;&#x2F;strong&gt;下，我们也能用来归约的产生式只有 $T \rightarrow T*F$ 一个，也只会归约到栈顶上多了一个 $T$ 的状态。&lt;&#x2F;p&gt;
&lt;p&gt;可以看出从“往栈上放一个$T$的角度来看”这两个状态其实是同一个状态。&lt;&#x2F;p&gt;
&lt;h3 id=&quot;lr-0-xiang&quot;&gt;LR(0)项&lt;&#x2F;h3&gt;
&lt;p&gt;我们引入$\cdot$标记来分割生成式匹配过了的部分和还需要匹配的部分，所以现在这个状态可以写成：
$$
T \rightarrow T*\cdot F
$$
也就代表在这个状态下，已经匹配到了$T*$，接下来如果能成功地匹配到一个$F$，就能顺利地归约为栈顶上的一个 $T$。&lt;&#x2F;p&gt;
&lt;p&gt;像这种标记过匹配到的状态的产生式，我们称之为“LR(0)项”，简称“项”。&lt;&#x2F;p&gt;
&lt;h3 id=&quot;xiang-ji-bi-bao&quot;&gt;项集闭包&lt;&#x2F;h3&gt;
&lt;p&gt;我们考虑上面说到的 $T \rightarrow T*\cdot F$，以及另外两个项：
$$
F \rightarrow \cdot(E)
$$
$$
F \rightarrow \cdot \textbf{id}
$$&lt;&#x2F;p&gt;
&lt;p&gt;我们可以看到在 $T \rightarrow T*\cdot F$ 项的对应状态下，上面两个项所代表的状态其实就是 $T \rightarrow T*\cdot F$ 在试图匹配 $F$ 时的“子状态”或“等价状态”。&lt;&#x2F;p&gt;
&lt;p&gt;那么我们就把这两个状态和原先的 $T \rightarrow T*\cdot F$ 放在一个集合里面，称之为“ $T \rightarrow T*\cdot F$ 的项集闭包”，其中 $T \rightarrow T*\cdot F$ 称为闭包的核心。&lt;&#x2F;p&gt;
&lt;p&gt;那么项集闭包有啥用呢？我们仍然举上面文法的例子：&lt;&#x2F;p&gt;
&lt;p&gt;比如现在栈中有$...T*$，我们在 $T \rightarrow T*\cdot F$ 状态，我们看到前面有一个$&#x27;(&#x27;$，此时我们就可以根据这个$&#x27;(&#x27;$ 和项集闭包中的$F \rightarrow \cdot(E)$，转到$F \rightarrow (\cdot E)$ 状态，然后去匹配出一个 $F$，放到栈顶，然后进行 $T$ 的归约。&lt;&#x2F;p&gt;
&lt;p&gt;把所有的项、对应的项集闭包以及状态之间的转换关系列出来，我们就可以建立起一个 LR(0) 状态机：&lt;&#x2F;p&gt;
&lt;p&gt;&lt;img src=&quot;https:&#x2F;&#x2F;longfangsong.github.io&#x2F;lr0&#x2F;i100.png&quot; alt=&quot;i100&quot; &#x2F;&gt;&lt;&#x2F;p&gt;
&lt;p&gt;可以看到每一个产生式对应的所有项都会出现在这个状态机里面，而每条边上则指示了在栈顶又被压入某个符号时的状态转换。&lt;&#x2F;p&gt;
&lt;p&gt;其中$E&#x27;$是为了标记我们最终匹配到什么而设置的，其实这个例子来讲说到底就是$E$。&lt;&#x2F;p&gt;
&lt;h4 id=&quot;shang-shu-guo-cheng-de-suan-fa-miao-shu&quot;&gt;上述过程的算法描述&lt;&#x2F;h4&gt;
&lt;p&gt;这部分看看就行了，看懂了上面的你可以自己想到这些的。&lt;&#x2F;p&gt;
&lt;p&gt;根据龙书，上面的过程的算法描述为：&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;求每个LR(0)项，直接往所有每个产生式里能插的地方（包括开头和结尾）插入“$\cdot$”即可&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;对开始符号所在的项 $S&#x27;\rightarrow \cdot S$，求其闭包&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;寻找每个我们拿到的闭包在某个输入下转换到的项集（称为$GOTO$函数）&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;求法&lt;&#x2F;p&gt;
&lt;blockquote&gt;
&lt;p&gt;“If $A → α·Bβ$ is in $CLOSURE(I)$ and $B → γ$ is a production, then add the item $B → ·γ$ to $CLOSURE(I)$, if it is not already there. Apply this rule until no more new items can be added to $CLOSURE(I)$.”&lt;&#x2F;p&gt;
&lt;&#x2F;blockquote&gt;
&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;重复上一步，直到不再有新的项集出现为止&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;h3 id=&quot;shi-yong-lr-0-zhuang-tai-ji-jin-xing-pi-pei&quot;&gt;使用 LR(0) 状态机进行匹配&lt;&#x2F;h3&gt;
&lt;p&gt;为了存储一路匹配上来时经过的状态，我们需要在分析表中增设一个状态栈。&lt;&#x2F;p&gt;
&lt;p&gt;我不想再画上面那一百万行的巨大表格了，所以我们这次直接用龙书上的例子：&lt;&#x2F;p&gt;
&lt;p&gt;分析$\textbf{id} * \textbf{id}$：&lt;&#x2F;p&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;状态栈&lt;&#x2F;th&gt;&lt;th&gt;符号栈&lt;&#x2F;th&gt;&lt;th&gt;剩余输入&lt;&#x2F;th&gt;&lt;th&gt;动作&lt;&#x2F;th&gt;&lt;&#x2F;tr&gt;&lt;&#x2F;thead&gt;&lt;tbody&gt;
&lt;tr&gt;&lt;td&gt;$I_0$&lt;&#x2F;td&gt;&lt;td&gt;&lt;&#x2F;td&gt;&lt;td&gt;$\textbf{id} * \textbf{id}$&lt;&#x2F;td&gt;&lt;td&gt;根据状态机的标识，转到$I_5$（即压入状态栈），同时移进 $\textbf{id}$&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;$I_0I_5$&lt;&#x2F;td&gt;&lt;td&gt;$\textbf{id}$&lt;&#x2F;td&gt;&lt;td&gt;$* \textbf{id}$&lt;&#x2F;td&gt;&lt;td&gt;根据状态机的标识，无处可转，进行归约，弹状态栈&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;$I_0$&lt;&#x2F;td&gt;&lt;td&gt;$F$&lt;&#x2F;td&gt;&lt;td&gt;$* \textbf{id}$&lt;&#x2F;td&gt;&lt;td&gt;弹栈后进行下一步状态转移，转到$I_3$&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;$I_0I_3$&lt;&#x2F;td&gt;&lt;td&gt;$F$&lt;&#x2F;td&gt;&lt;td&gt;$* \textbf{id}$&lt;&#x2F;td&gt;&lt;td&gt;根据状态机的标识，无处可转，进行归约，弹状态栈&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;$I_0$&lt;&#x2F;td&gt;&lt;td&gt;$T$&lt;&#x2F;td&gt;&lt;td&gt;$* \textbf{id}$&lt;&#x2F;td&gt;&lt;td&gt;弹栈后进行下一步状态转移，转到$I_2$&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;$I_0I_2$&lt;&#x2F;td&gt;&lt;td&gt;$T$&lt;&#x2F;td&gt;&lt;td&gt;$* \textbf{id}$&lt;&#x2F;td&gt;&lt;td&gt;根据状态机的标识，转到$I_7$，同时移进 $*$&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;$I_0I_2I_7$&lt;&#x2F;td&gt;&lt;td&gt;$T*$&lt;&#x2F;td&gt;&lt;td&gt;$\textbf{id}$&lt;&#x2F;td&gt;&lt;td&gt;根据状态机的标识，转到$I_5$，同时移进 $\textbf{id}$&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;$I_0I_2I_7I_5$&lt;&#x2F;td&gt;&lt;td&gt;$T*\textbf{id}$&lt;&#x2F;td&gt;&lt;td&gt;&lt;&#x2F;td&gt;&lt;td&gt;根据状态机的标识，无处可转，进行归约，弹状态栈&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;$I_0I_2I_7$&lt;&#x2F;td&gt;&lt;td&gt;$T*F$&lt;&#x2F;td&gt;&lt;td&gt;&lt;&#x2F;td&gt;&lt;td&gt;弹栈后进行下一步状态转移，转到$I_{10}$&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;$I_0I_2I_{10}$&lt;&#x2F;td&gt;&lt;td&gt;$T$&lt;&#x2F;td&gt;&lt;td&gt;&lt;&#x2F;td&gt;&lt;td&gt;根据状态机的标识，无处可转，进行归约，弹状态栈&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;$I_0I_2$&lt;&#x2F;td&gt;&lt;td&gt;$E$&lt;&#x2F;td&gt;&lt;td&gt;&lt;&#x2F;td&gt;&lt;td&gt;根据状态机的标识，无处可转，进行归约，弹状态栈&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;$I_0$&lt;&#x2F;td&gt;&lt;td&gt;$E$&lt;&#x2F;td&gt;&lt;td&gt;&lt;&#x2F;td&gt;&lt;td&gt;弹栈后进行下一步状态转移，转到$I_1$&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;$I_0I_1$&lt;&#x2F;td&gt;&lt;td&gt;$E&#x27;$&lt;&#x2F;td&gt;&lt;td&gt;&lt;&#x2F;td&gt;&lt;td&gt;接受&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;&#x2F;tbody&gt;&lt;&#x2F;table&gt;
&lt;p&gt;注意我这里的步骤比龙书上多了些，龙书将“弹栈后进行下一步状态转移”这一步和下面的步骤合并起来写。&lt;&#x2F;p&gt;
&lt;p&gt;其实说实话你可以把这个状态栈用函数（递归）调用的方法消去的。&lt;&#x2F;p&gt;
&lt;h3 id=&quot;chong-tu&quot;&gt;冲突&lt;&#x2F;h3&gt;
&lt;p&gt;看了上面的步骤你会发现，LR(0) 的每个项集闭包中不可以包含：&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;一个项认为已经可以归约了，另一个项认为还需要移进
$$
A \rightarrow a\cdot b
$$
$$
B \rightarrow c \cdot
$$&lt;&#x2F;p&gt;
&lt;p&gt;这称为移进-归约冲突。&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;两个项认为可以归约出不同的东西
$$
A \rightarrow b \cdot
$$
$$
C \rightarrow d \cdot
$$&lt;&#x2F;p&gt;
&lt;p&gt;这称为归约-归约冲突。&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;有此类冲突的不是LR(0)文法，需要用其他分析方法分析。&lt;&#x2F;p&gt;
&lt;div class=&quot;footnote-definition&quot; id=&quot;0&quot;&gt;&lt;sup class=&quot;footnote-definition-label&quot;&gt;1&lt;&#x2F;sup&gt;
&lt;p&gt;这里也可以理解成，匹配完了$E+$ 之后，再递归地（用“干净”的栈帧）匹配后面的以$T*$开头的内容&lt;&#x2F;p&gt;
&lt;&#x2F;div&gt;
</content>
        
    </entry>
    <entry xml:lang="zh">
        <title>Parsing • 移进-归约分析</title>
        <published>2020-05-22T22:56:58.045+00:00</published>
        <updated>2020-05-22T22:56:58.045+00:00</updated>
        <author>
          <name>Unknown</name>
        </author>
        <link rel="alternate" href="https://longfangsong.github.io/shift-reduce/" type="text/html"/>
        <id>https://longfangsong.github.io/shift-reduce/</id>
        
        <content type="html">&lt;p&gt;回忆你很可能在大一大二&lt;sup class=&quot;footnote-reference&quot;&gt;&lt;a href=&quot;#1&quot;&gt;1&lt;&#x2F;a&gt;&lt;&#x2F;sup&gt;写过的运用栈进行表达式求值的程序，我们将其简化到只支持加法和乘法，这里给出一个Rust语言的例子（写的比较随意……），太长不看党可以直接跳过看下面的分析：&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;let mut&lt;&#x2F;span&gt;&lt;span&gt; input = String::new();
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;stdin&lt;&#x2F;span&gt;&lt;span&gt;().&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;read_to_string&lt;&#x2F;span&gt;&lt;span&gt;(&amp;amp;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;mut&lt;&#x2F;span&gt;&lt;span&gt; input).&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;unwrap&lt;&#x2F;span&gt;&lt;span&gt;();
&lt;&#x2F;span&gt;&lt;span&gt;    input = input.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;trim&lt;&#x2F;span&gt;&lt;span&gt;().&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;to_owned&lt;&#x2F;span&gt;&lt;span&gt;();
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;let mut&lt;&#x2F;span&gt;&lt;span&gt; current_number = String::new();
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;let mut&lt;&#x2F;span&gt;&lt;span&gt; stack = Vec::new();
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;for&lt;&#x2F;span&gt;&lt;span&gt; ch in input.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;chars&lt;&#x2F;span&gt;&lt;span&gt;() {
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;match&lt;&#x2F;span&gt;&lt;span&gt; ch {
&lt;&#x2F;span&gt;&lt;span&gt;            &amp;#39;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;0&lt;&#x2F;span&gt;&lt;span&gt;&amp;#39;..=&amp;#39;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;9&lt;&#x2F;span&gt;&lt;span&gt;&amp;#39; =&amp;gt; current_number.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;push&lt;&#x2F;span&gt;&lt;span&gt;(ch),
&lt;&#x2F;span&gt;&lt;span&gt;            &amp;#39;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;+&lt;&#x2F;span&gt;&lt;span&gt;&amp;#39; | &amp;#39;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;*&lt;&#x2F;span&gt;&lt;span&gt;&amp;#39; =&amp;gt; {
&lt;&#x2F;span&gt;&lt;span&gt;                &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;if &lt;&#x2F;span&gt;&lt;span&gt;!current_number.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;is_empty&lt;&#x2F;span&gt;&lt;span&gt;() {
&lt;&#x2F;span&gt;&lt;span&gt;                    stack.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;push&lt;&#x2F;span&gt;&lt;span&gt;(Token::Value(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;i32&lt;&#x2F;span&gt;&lt;span&gt;::from_str(&amp;amp;current_number).&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;unwrap&lt;&#x2F;span&gt;&lt;span&gt;()));
&lt;&#x2F;span&gt;&lt;span&gt;                    current_number = String::new();
&lt;&#x2F;span&gt;&lt;span&gt;                }
&lt;&#x2F;span&gt;&lt;span&gt;                &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; top_op = stack.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;iter&lt;&#x2F;span&gt;&lt;span&gt;().&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;rev&lt;&#x2F;span&gt;&lt;span&gt;()
&lt;&#x2F;span&gt;&lt;span&gt;                    .&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;find_map&lt;&#x2F;span&gt;&lt;span&gt;(|&amp;amp;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;it&lt;&#x2F;span&gt;&lt;span&gt;| &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;if let &lt;&#x2F;span&gt;&lt;span&gt;Token::Op(op) = it { Some(op) } &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;else &lt;&#x2F;span&gt;&lt;span&gt;{ None });
&lt;&#x2F;span&gt;&lt;span&gt;                &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;if&lt;&#x2F;span&gt;&lt;span&gt; top_op.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;is_some&lt;&#x2F;span&gt;&lt;span&gt;() {
&lt;&#x2F;span&gt;&lt;span&gt;                    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;let mut&lt;&#x2F;span&gt;&lt;span&gt; top_op = top_op.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;unwrap&lt;&#x2F;span&gt;&lt;span&gt;();
&lt;&#x2F;span&gt;&lt;span&gt;                    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;&#x2F;&#x2F; 下面的条件实际上是&amp;quot;栈上最后一个操作符优先级大于等于当前读到的操作符&amp;quot;
&lt;&#x2F;span&gt;&lt;span&gt;                    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;while&lt;&#x2F;span&gt;&lt;span&gt; ch == &amp;#39;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;+&lt;&#x2F;span&gt;&lt;span&gt;&amp;#39; || top_op == &amp;#39;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;*&lt;&#x2F;span&gt;&lt;span&gt;&amp;#39; {
&lt;&#x2F;span&gt;&lt;span&gt;                        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; op2 = stack.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;pop&lt;&#x2F;span&gt;&lt;span&gt;().&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;unwrap&lt;&#x2F;span&gt;&lt;span&gt;();
&lt;&#x2F;span&gt;&lt;span&gt;                        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; op = stack.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;pop&lt;&#x2F;span&gt;&lt;span&gt;().&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;unwrap&lt;&#x2F;span&gt;&lt;span&gt;(); &lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;&#x2F;&#x2F; should be equal to top_op
&lt;&#x2F;span&gt;&lt;span&gt;                        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; op1 = stack.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;pop&lt;&#x2F;span&gt;&lt;span&gt;().&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;unwrap&lt;&#x2F;span&gt;&lt;span&gt;();
&lt;&#x2F;span&gt;&lt;span&gt;                        stack.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;push&lt;&#x2F;span&gt;&lt;span&gt;(Token::Value(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;eval&lt;&#x2F;span&gt;&lt;span&gt;(op1, op, op2)));
&lt;&#x2F;span&gt;&lt;span&gt;                        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; next_top_op = stack.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;iter&lt;&#x2F;span&gt;&lt;span&gt;().&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;rev&lt;&#x2F;span&gt;&lt;span&gt;()
&lt;&#x2F;span&gt;&lt;span&gt;                            .&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;find_map&lt;&#x2F;span&gt;&lt;span&gt;(|&amp;amp;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;it&lt;&#x2F;span&gt;&lt;span&gt;| &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;if let &lt;&#x2F;span&gt;&lt;span&gt;Token::Op(op) = it { Some(op) } &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;else &lt;&#x2F;span&gt;&lt;span&gt;{ None });
&lt;&#x2F;span&gt;&lt;span&gt;                        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;if&lt;&#x2F;span&gt;&lt;span&gt; next_top_op.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;is_none&lt;&#x2F;span&gt;&lt;span&gt;() { &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;break&lt;&#x2F;span&gt;&lt;span&gt;; }
&lt;&#x2F;span&gt;&lt;span&gt;                        top_op = next_top_op.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;unwrap&lt;&#x2F;span&gt;&lt;span&gt;()
&lt;&#x2F;span&gt;&lt;span&gt;                    }
&lt;&#x2F;span&gt;&lt;span&gt;                }
&lt;&#x2F;span&gt;&lt;span&gt;                stack.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;push&lt;&#x2F;span&gt;&lt;span&gt;(Token::Op(ch));
&lt;&#x2F;span&gt;&lt;span&gt;            }
&lt;&#x2F;span&gt;&lt;span&gt;            _ =&amp;gt; unreachable!()
&lt;&#x2F;span&gt;&lt;span&gt;        }
&lt;&#x2F;span&gt;&lt;span&gt;    }
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;if &lt;&#x2F;span&gt;&lt;span&gt;!current_number.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;is_empty&lt;&#x2F;span&gt;&lt;span&gt;() {
&lt;&#x2F;span&gt;&lt;span&gt;        stack.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;push&lt;&#x2F;span&gt;&lt;span&gt;(Token::Value(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;i32&lt;&#x2F;span&gt;&lt;span&gt;::from_str(&amp;amp;current_number).&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;unwrap&lt;&#x2F;span&gt;&lt;span&gt;()));
&lt;&#x2F;span&gt;&lt;span&gt;        current_number.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;clear&lt;&#x2F;span&gt;&lt;span&gt;();
&lt;&#x2F;span&gt;&lt;span&gt;    }
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;let mut&lt;&#x2F;span&gt;&lt;span&gt; top_op = stack.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;iter&lt;&#x2F;span&gt;&lt;span&gt;().&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;rev&lt;&#x2F;span&gt;&lt;span&gt;()
&lt;&#x2F;span&gt;&lt;span&gt;        .&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;find_map&lt;&#x2F;span&gt;&lt;span&gt;(|&amp;amp;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;it&lt;&#x2F;span&gt;&lt;span&gt;| &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;if let &lt;&#x2F;span&gt;&lt;span&gt;Token::Op(op) = it { Some(op) } &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;else &lt;&#x2F;span&gt;&lt;span&gt;{ None });
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;while&lt;&#x2F;span&gt;&lt;span&gt; top_op.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;is_some&lt;&#x2F;span&gt;&lt;span&gt;() {
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; op2 = stack.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;pop&lt;&#x2F;span&gt;&lt;span&gt;().&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;unwrap&lt;&#x2F;span&gt;&lt;span&gt;();
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; op = stack.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;pop&lt;&#x2F;span&gt;&lt;span&gt;().&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;unwrap&lt;&#x2F;span&gt;&lt;span&gt;();
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; op1 = stack.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;pop&lt;&#x2F;span&gt;&lt;span&gt;().&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;unwrap&lt;&#x2F;span&gt;&lt;span&gt;();
&lt;&#x2F;span&gt;&lt;span&gt;        stack.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;push&lt;&#x2F;span&gt;&lt;span&gt;(Token::Value(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;eval&lt;&#x2F;span&gt;&lt;span&gt;(op1, op, op2)));
&lt;&#x2F;span&gt;&lt;span&gt;        top_op = stack.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;iter&lt;&#x2F;span&gt;&lt;span&gt;().&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;rev&lt;&#x2F;span&gt;&lt;span&gt;()
&lt;&#x2F;span&gt;&lt;span&gt;            .&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;find_map&lt;&#x2F;span&gt;&lt;span&gt;(|&amp;amp;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;it&lt;&#x2F;span&gt;&lt;span&gt;| &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;if let &lt;&#x2F;span&gt;&lt;span&gt;Token::Op(op) = it { Some(op) } &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;else &lt;&#x2F;span&gt;&lt;span&gt;{ None });
&lt;&#x2F;span&gt;&lt;span&gt;    }
&lt;&#x2F;span&gt;&lt;span&gt;		println!(&amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;{:?}&lt;&#x2F;span&gt;&lt;span&gt;&amp;quot;, stack[&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;0&lt;&#x2F;span&gt;&lt;span&gt;]);
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;我们以表达式$1+2*3+4$的求值来观察这一过程：&lt;&#x2F;p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;输入数字1，压入栈中&lt;&#x2F;p&gt;
&lt;p&gt;&lt;img src=&quot;https:&#x2F;&#x2F;longfangsong.github.io&#x2F;shift-reduce&#x2F;i1.svg&quot; alt=&quot;i1&quot; &#x2F;&gt;&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;输入操作符&#x27;+&#x27;，压入栈中&lt;&#x2F;p&gt;
&lt;p&gt;&lt;img src=&quot;https:&#x2F;&#x2F;longfangsong.github.io&#x2F;shift-reduce&#x2F;i2.svg&quot; alt=&quot;i2&quot; &#x2F;&gt;&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;输入数字2，压入栈中&lt;&#x2F;p&gt;
&lt;p&gt;&lt;img src=&quot;https:&#x2F;&#x2F;longfangsong.github.io&#x2F;shift-reduce&#x2F;i3.svg&quot; alt=&quot;i3&quot; &#x2F;&gt;&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;输入操作符&#x27;*&#x27;，压入栈中&lt;&#x2F;p&gt;
&lt;p&gt;&lt;img src=&quot;https:&#x2F;&#x2F;longfangsong.github.io&#x2F;shift-reduce&#x2F;i4.svg&quot; alt=&quot;i4&quot; &#x2F;&gt;&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;输入数字3，压入栈中&lt;&#x2F;p&gt;
&lt;p&gt;&lt;img src=&quot;https:&#x2F;&#x2F;longfangsong.github.io&#x2F;shift-reduce&#x2F;i5.svg&quot; alt=&quot;i5&quot; &#x2F;&gt;&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;输入操作符&#x27;+&#x27;，优先级低于栈中最后一个压入的运算符，先对栈中内容求值，再将&#x27;+&#x27;压入栈中&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&#x27;*&#x27;优先级高于&#x27;+&#x27;，求值&lt;&#x2F;p&gt;
&lt;p&gt;&lt;img src=&quot;https:&#x2F;&#x2F;longfangsong.github.io&#x2F;shift-reduce&#x2F;i6.svg&quot; alt=&quot;i6&quot; &#x2F;&gt;&lt;&#x2F;p&gt;
&lt;p&gt;&lt;img src=&quot;https:&#x2F;&#x2F;longfangsong.github.io&#x2F;shift-reduce&#x2F;i7.svg&quot; alt=&quot;i7&quot; &#x2F;&gt;&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;&#x27;+&#x27;优先级等于&#x27;+&#x27;，求值&lt;&#x2F;p&gt;
&lt;p&gt;&lt;img src=&quot;https:&#x2F;&#x2F;longfangsong.github.io&#x2F;shift-reduce&#x2F;i8.svg&quot; alt=&quot;i8&quot; &#x2F;&gt;&lt;&#x2F;p&gt;
&lt;p&gt;&lt;img src=&quot;https:&#x2F;&#x2F;longfangsong.github.io&#x2F;shift-reduce&#x2F;i9.svg&quot; alt=&quot;i9&quot; &#x2F;&gt;&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;栈中没有运算符了，压入&#x27;+&#x27;&lt;&#x2F;p&gt;
&lt;p&gt;&lt;img src=&quot;https:&#x2F;&#x2F;longfangsong.github.io&#x2F;shift-reduce&#x2F;i10.svg&quot; alt=&quot;i10&quot; &#x2F;&gt;&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;看到数字4，压入&lt;&#x2F;p&gt;
&lt;p&gt;&lt;img src=&quot;https:&#x2F;&#x2F;longfangsong.github.io&#x2F;shift-reduce&#x2F;i11.svg&quot; alt=&quot;i11&quot; &#x2F;&gt;&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;没有输入了，不断求值直到没有更多运算符&lt;&#x2F;p&gt;
&lt;p&gt;&lt;img src=&quot;https:&#x2F;&#x2F;longfangsong.github.io&#x2F;shift-reduce&#x2F;i12.svg&quot; alt=&quot;i12&quot; &#x2F;&gt;&lt;&#x2F;p&gt;
&lt;p&gt;&lt;img src=&quot;https:&#x2F;&#x2F;longfangsong.github.io&#x2F;shift-reduce&#x2F;i13.svg&quot; alt=&quot;i13&quot; &#x2F;&gt;&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
&lt;p&gt;这里的11就是我们求得得答案。&lt;&#x2F;p&gt;
&lt;h2 id=&quot;yi-jin-he-gui-yue&quot;&gt;移进和归约&lt;&#x2F;h2&gt;
&lt;p&gt;我们看到，我们上面的分析过程中出现了两种操作：&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;移进：将输入的值或者操作符&lt;strong&gt;压入&lt;&#x2F;strong&gt;栈中&lt;&#x2F;li&gt;
&lt;li&gt;归约：将输入的值和&lt;strong&gt;栈顶&lt;&#x2F;strong&gt;的某几个值经过计算，变为一般来说更少的几个值，&lt;strong&gt;压回&lt;&#x2F;strong&gt;栈中&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;我们可以将“值”、“操作符”推广到“文法元素”，得到了文法分析中的移进和归约&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;移进：将输入的某个token&lt;strong&gt;压入&lt;&#x2F;strong&gt;栈中&lt;&#x2F;li&gt;
&lt;li&gt;归约：将输入的值和&lt;strong&gt;栈顶&lt;&#x2F;strong&gt;的某几个文法元素经过计算，变为一般来说更少的几个文法元素，&lt;strong&gt;压回&lt;&#x2F;strong&gt;栈中&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;那么我们就能将上面的例子推广到更一般的，非数字的场景，以文法&lt;sup class=&quot;footnote-reference&quot;&gt;&lt;a href=&quot;#2&quot;&gt;2&lt;&#x2F;a&gt;&lt;&#x2F;sup&gt;：
$$
Expr \rightarrow id | Expr + Expr | Expr * Expr
$$
和表达式$a+b*c+d$为例（图中的所有蓝色节点均代表$Expr$，其中复杂$Expr$已经画为AST的样子）：&lt;&#x2F;p&gt;
&lt;p&gt;&lt;img src=&quot;https:&#x2F;&#x2F;longfangsong.github.io&#x2F;shift-reduce&#x2F;i14.svg&quot; alt=&quot;i14&quot; &#x2F;&gt;&lt;&#x2F;p&gt;
&lt;p&gt;通过简单地将上面求值中的数字改为了文法元素（也即AST的节点），我们容易地将表达式求值的方法扩展到了求表达式对应的AST。&lt;&#x2F;p&gt;
&lt;h2 id=&quot;chong-tu&quot;&gt;冲突&lt;&#x2F;h2&gt;
&lt;p&gt;在移进-归约分析过程中，可能会遇到某些情况下，有多种可能使用的行为，例如：&lt;&#x2F;p&gt;
&lt;p&gt;&lt;img src=&quot;https:&#x2F;&#x2F;longfangsong.github.io&#x2F;shift-reduce&#x2F;i3.svg&quot; alt=&quot;i3&quot; &#x2F;&gt;&lt;&#x2F;p&gt;
&lt;p&gt;此时是否应当将1+2归约为3？这就要等到下一个操作符到来才能决定。&lt;&#x2F;p&gt;
&lt;h3 id=&quot;yi-jin-gui-yue-chong-tu&quot;&gt;移进-归约冲突&lt;&#x2F;h3&gt;
&lt;p&gt;当某个输入可以选择与栈中内容结合，进行归约，也可以选择直接压入栈，后续再进行归约时，就说我们遇到了一个移进-归约冲突。&lt;&#x2F;p&gt;
&lt;p&gt;上述的例子就是一个典型的移进-归约冲突。&lt;&#x2F;p&gt;
&lt;h3 id=&quot;gui-yue-gui-yue-chong-tu&quot;&gt;归约-归约冲突&lt;&#x2F;h3&gt;
&lt;p&gt;当我们遇到了某个输入与栈中内容结合，其结构符合多个产生式时，可以有多种方式进行归约，这时就说我们遇到了一个归约-归约冲突。&lt;&#x2F;p&gt;
&lt;div class=&quot;footnote-definition&quot; id=&quot;1&quot;&gt;&lt;sup class=&quot;footnote-definition-label&quot;&gt;1&lt;&#x2F;sup&gt;
&lt;p&gt;&lt;del&gt;我初三就会写了，你来打我呀&lt;&#x2F;del&gt;（虽然当年写的爆炸丑陋）&lt;&#x2F;p&gt;
&lt;&#x2F;div&gt;
&lt;div class=&quot;footnote-definition&quot; id=&quot;2&quot;&gt;&lt;sup class=&quot;footnote-definition-label&quot;&gt;2&lt;&#x2F;sup&gt;
&lt;p&gt;这里要注意其实可以说归约时用的产生式是$Expr+ \rightarrow Expr*Expr+|Expr+Expr+$，这样就没有了优先级这个概念，但这样就是个上下文有关文法了。&lt;&#x2F;p&gt;
&lt;&#x2F;div&gt;
</content>
        
    </entry>
    <entry xml:lang="zh">
        <title>Parsing • LL(1)文法的分析，以及First集和Follow集究竟是什么</title>
        <published>2020-05-17T16:37:01.045+00:00</published>
        <updated>2020-05-17T16:37:01.045+00:00</updated>
        <author>
          <name>Unknown</name>
        </author>
        <link rel="alternate" href="https://longfangsong.github.io/ll1/" type="text/html"/>
        <id>https://longfangsong.github.io/ll1/</id>
        
        <content type="html">&lt;h2 id=&quot;wei-shi-yao-xu-yao-firstji-he-followji&quot;&gt;为什么需要First集和Follow集&lt;&#x2F;h2&gt;
&lt;p&gt;了解&lt;a href=&quot;https:&#x2F;&#x2F;longfangsong.github.io&#x2F;parsing-combinator&#x2F;&quot;&gt;带回朔的递归下降文法分析方法&lt;&#x2F;a&gt;的同学可能会发现这种分析法由于在文法中每个出现 &lt;code&gt;|&lt;&#x2F;code&gt; 的点上，都会&lt;strong&gt;尝试&lt;&#x2F;strong&gt;这个点上所有可能的生成式，直到有一个匹配成功为止，这种方案虽然保证了对所有文法中的句子，最终都能通过这种方式构建出其语法树，但由于可能存在的大量回朔，效率就会收到影响。&lt;&#x2F;p&gt;
&lt;p&gt;那么我们就要想了，有没有什么方法可以选择出这个点上&lt;strong&gt;唯一&lt;&#x2F;strong&gt;的生成式，来消除所有回朔的可能性，这样效率就能大大提升了。&lt;&#x2F;p&gt;
&lt;p&gt;事实证明，对于一部分文法来说，这么做是可能的。&lt;&#x2F;p&gt;
&lt;h2 id=&quot;ke-yi-xuan-chu-wei-yi-sheng-cheng-shi-de-shi-li&quot;&gt;可以选出唯一生成式的实例&lt;&#x2F;h2&gt;
&lt;p&gt;例如下面一个（消除了左递归的，所有的$|$都拆开了的）文法：
$$
\displaylines {
E \rightarrow T E&#x27; \\
E&#x27; \rightarrow + T E&#x27; \\
E&#x27; \rightarrow \epsilon \\
T \rightarrow F T&#x27; \\
T&#x27; \rightarrow * FT&#x27; \\
T&#x27; \rightarrow \epsilon \\
F \rightarrow (E) \\
F \rightarrow id
}
$$
可以看出，在调用某个（直接或间接）带有&lt;code&gt;|&lt;&#x2F;code&gt;的parse函数，并看到了下一个输入为某个符号时，选用的生成式是：&lt;&#x2F;p&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;parse\输入符号&lt;&#x2F;th&gt;&lt;th&gt;$id$&lt;&#x2F;th&gt;&lt;th&gt;$+$&lt;&#x2F;th&gt;&lt;th&gt;$*$&lt;&#x2F;th&gt;&lt;th&gt;$($&lt;&#x2F;th&gt;&lt;th&gt;$)$&lt;&#x2F;th&gt;&lt;th&gt;输入结束（接受输入）&lt;&#x2F;th&gt;&lt;&#x2F;tr&gt;&lt;&#x2F;thead&gt;&lt;tbody&gt;
&lt;tr&gt;&lt;td&gt;$E$&lt;&#x2F;td&gt;&lt;td&gt;$E\rightarrow TE&#x27;$&lt;&#x2F;td&gt;&lt;td&gt;&lt;&#x2F;td&gt;&lt;td&gt;&lt;&#x2F;td&gt;&lt;td&gt;$E\rightarrow TE&#x27;$&lt;&#x2F;td&gt;&lt;td&gt;&lt;&#x2F;td&gt;&lt;td&gt;&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;$E&#x27;$&lt;&#x2F;td&gt;&lt;td&gt;&lt;&#x2F;td&gt;&lt;td&gt;$E&#x27;\rightarrow +TE&#x27;$&lt;&#x2F;td&gt;&lt;td&gt;&lt;&#x2F;td&gt;&lt;td&gt;&lt;&#x2F;td&gt;&lt;td&gt;$E&#x27;\rightarrow \epsilon$&lt;&#x2F;td&gt;&lt;td&gt;$E&#x27;\rightarrow \epsilon$&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;$T$&lt;&#x2F;td&gt;&lt;td&gt;$T\rightarrow FT&#x27;$&lt;&#x2F;td&gt;&lt;td&gt;&lt;&#x2F;td&gt;&lt;td&gt;&lt;&#x2F;td&gt;&lt;td&gt;$T\rightarrow FT&#x27;$&lt;&#x2F;td&gt;&lt;td&gt;&lt;&#x2F;td&gt;&lt;td&gt;&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;$T&#x27;$&lt;&#x2F;td&gt;&lt;td&gt;&lt;&#x2F;td&gt;&lt;td&gt;$T&#x27;\rightarrow \epsilon$&lt;&#x2F;td&gt;&lt;td&gt;$T&#x27;\rightarrow *FT&#x27;$&lt;&#x2F;td&gt;&lt;td&gt;&lt;&#x2F;td&gt;&lt;td&gt;$T&#x27;\rightarrow \epsilon$&lt;&#x2F;td&gt;&lt;td&gt;$T&#x27;\rightarrow \epsilon$&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;$F$&lt;&#x2F;td&gt;&lt;td&gt;$F\rightarrow id$&lt;&#x2F;td&gt;&lt;td&gt;&lt;&#x2F;td&gt;&lt;td&gt;&lt;&#x2F;td&gt;&lt;td&gt;$F\rightarrow (E)$&lt;&#x2F;td&gt;&lt;td&gt;&lt;&#x2F;td&gt;&lt;td&gt;&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;&#x2F;tbody&gt;&lt;&#x2F;table&gt;
&lt;p&gt;这里生成式的选择（即每个格子中的产生式）正是唯一的。&lt;&#x2F;p&gt;
&lt;p&gt;那么如何求这张表呢？&lt;&#x2F;p&gt;
&lt;p&gt;容易想到的是，对某个产生式：
$$
A \rightarrow BCD...X
$$
检查其能生成的每个句子中的第一个符号，并将该产生式填入$A$对应行中，这些符号的对应的列中即可。&lt;&#x2F;p&gt;
&lt;p&gt;而求出“能生成的每个句子中的第一个符号”的方法是：按顺序检查$B,C,D...X$中的每一个，如果这个符号是$\epsilon$，那么略过这个符号继续往下看就好了（如果后面啥也没有了，那就把$\epsilon$看成是终结符），如果是终结符，那这“第一个符号”就是它了，如果是非终结符，那么递归地往下看这个符号就好了。&lt;&#x2F;p&gt;
&lt;p&gt;取前面例子中的$E \rightarrow T E&#x27;$为例：&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;检查$T$，是非终结符，递归地向下看，有：&lt;&#x2F;p&gt;
&lt;p&gt;$T \rightarrow F T&#x27;$&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;检查$F$，是非终结符，递归地向下看，有：&lt;&#x2F;p&gt;
&lt;p&gt;$F \rightarrow (E)$&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;检查&#x27;$($&#x27;，是终结符，故下一步看到&#x27;$($&#x27;时，可以选择$E \rightarrow T E&#x27;$，填入表$E$行&#x27;$)$&#x27;列中。&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;$F \rightarrow id$&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;检查$id$，是终结符，故下一步看到$id$时，可以选择$E \rightarrow T E&#x27;$，填入表$E$行$id$列中。&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;$F$不会为$\epsilon$，故到此结束&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;$T$不会为$\epsilon$，故到此结束&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;考虑过每个非终结符对应的产生式后，对应的这一行除了最后一列就填好了，非终结符全部考虑过后，这整个表除了最后一列就都填好了。&lt;&#x2F;p&gt;
&lt;p&gt;最后一列的事情暂时按下不表，我们此时已经自己推出了这个First集了。&lt;&#x2F;p&gt;
&lt;h2 id=&quot;firstji&quot;&gt;First集&lt;&#x2F;h2&gt;
&lt;p&gt;到这里，你就已经自己发明出First集的定义与求法了：&lt;&#x2F;p&gt;
&lt;h3 id=&quot;ding-yi&quot;&gt;定义&lt;&#x2F;h3&gt;
&lt;p&gt;龙书的定义里面有一堆数学符号，其实说到底和我上面的定义完全一致。&lt;&#x2F;p&gt;
&lt;blockquote&gt;
&lt;p&gt;Define $FIRST(α)$, where $α$ is any string of grammar symbols, to be the set of terminals that begin strings derived from $α$. If $\alpha \stackrel{*}{\Rightarrow} \epsilon$, then $\epsilon$ is also in $FIRST(α)$.  ——  “Compilers: Principles, Techniques, and Tools, 2&#x2F;e” &lt;&#x2F;p&gt;
&lt;&#x2F;blockquote&gt;
&lt;p&gt;定义$FIRST(α)$，其中$\alpha$是一个语法符号构成的任意串，为一组可以被$\alpha$推导出的终结符串的起始字符的集合。如果$\alpha \stackrel{*}{\Rightarrow} \epsilon$，那$\epsilon$也在$FIRST(α)$中。&lt;&#x2F;p&gt;
&lt;p&gt;这不就是我们上面说的“能生成的每个句子中的第一个符号”按照推导式左侧的非终结符全部并起来的结果吗。&lt;&#x2F;p&gt;
&lt;h3 id=&quot;qiu-fa&quot;&gt;求法&lt;&#x2F;h3&gt;
&lt;p&gt;同理，数学符号……&lt;&#x2F;p&gt;
&lt;blockquote&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;If X is a terminal, then $FIRST(X) = {X}$.&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;If X is a nonterminal and $X → Y_1Y_2 ... Y_k$ is a production for some $k \ge 1$, then place &#x27;a&#x27; in $FIRST(X)$ if for some $i$, &#x27;a&#x27; is in $FIRST(Y_i)$, and $\epsilon$ is in all of $FIRST(Y_1), ..., FIRST(Y_{i – 1})$; that is, $Y_1Y_2...Y_{i-1} \stackrel{*}{\Rightarrow} \epsilon$. &lt;&#x2F;p&gt;
&lt;p&gt;If $\epsilon$ is in $FIRST(Y_j)$ for all $j = 1, 2, ..., k$, then add $\epsilon$ to $FIRST(X)$. &lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;If $X \rightarrow \epsilon$ is a production, then add $\epsilon$ to $FIRST(X)$.&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
&lt;p&gt;—— “Compilers: Principles, Techniques, and Tools, 2&#x2F;e” &lt;&#x2F;p&gt;
&lt;&#x2F;blockquote&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;若X是终结符，则$FIRST(X) = {X}$&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;若X是非终结符：&lt;&#x2F;p&gt;
&lt;p&gt;若$\epsilon$ 在所有 $FIRST(Y_1), ..., FIRST(Y_{i – 1})$ 中，在&#x27;a&#x27; 在 $FIRST(Y_i)$中。则&#x27;a&#x27;也在$FIRST(X)$中。&lt;&#x2F;p&gt;
&lt;p&gt;若对所有$j = 1, 2, ..., k$，$\epsilon$都在$FIRST(Y_j)$中，则$\epsilon$也在$FIRST(X)$中。&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;若有生成式$X\rightarrow \epsilon$，则$\epsilon$也在$FIRST(X)$中。&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
&lt;p&gt;和上面我们自己推出的求法相比也非常相似，不过是按照推导式左侧的非终结符全部并起来的结果。&lt;&#x2F;p&gt;
&lt;p&gt;而这种求法，显然是可以用动态规划法加速的。&lt;&#x2F;p&gt;
&lt;h2 id=&quot;zui-hou-yi-lie&quot;&gt;最后一列&lt;&#x2F;h2&gt;
&lt;p&gt;那这个最后一列怎么处理呢？&lt;&#x2F;p&gt;
&lt;p&gt;也很简单，如果从起始符号开始，在经过数次推导之后，在由某个非终结符作为最右边的非终结符时推导可以使整个文法的分析结束，这个非终结符对应推出$\epsilon$的推导式就能填在最后一列对应的行中。&lt;sup class=&quot;footnote-reference&quot;&gt;&lt;a href=&quot;#1&quot;&gt;1&lt;&#x2F;a&gt;&lt;&#x2F;sup&gt;&lt;&#x2F;p&gt;
&lt;p&gt;那么怎么找出这些“从起始符号开始，在经过数次推导&lt;sup class=&quot;footnote-reference&quot;&gt;&lt;a href=&quot;#2&quot;&gt;2&lt;&#x2F;a&gt;&lt;&#x2F;sup&gt;之后，作为最右边的非终结符时推导可以使整个文法的分析结束”的非终结符号呢？&lt;&#x2F;p&gt;
&lt;p&gt;首先我们可以看开始符号最右边的符号，这个符号一定符合我们的要求，在这里这个符号是$E &#x27;$。&lt;&#x2F;p&gt;
&lt;p&gt;如果对某个符合条件的符号$Z$和另外某个（单个）符号$X$，有产生式$Z\rightarrow YX$或$Z\rightarrow YXW$，其中$W \stackrel{*}{\Rightarrow} \epsilon$，则$X$也符合要求。&lt;&#x2F;p&gt;
&lt;p&gt;从我们的例子上来看，将上面的$Z$可以带入$E&#x27;$和$E$，有：&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;$E\rightarrow TE&#x27;$，而存在$E&#x27; \rightarrow \epsilon$，故$T$也符合要求，但不能推出$\epsilon$&lt;&#x2F;li&gt;
&lt;li&gt;$T \rightarrow* FT&#x27;$，故$T&#x27; $也符合要求，将$T&#x27; \rightarrow \epsilon$填入适当位置&lt;&#x2F;li&gt;
&lt;li&gt;$T \rightarrow* FT&#x27;$，而存在$T&#x27; \rightarrow \epsilon$，故$F$也符合要求，但$F$不能推出$\epsilon$&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;h2 id=&quot;followji&quot;&gt;Follow集&lt;&#x2F;h2&gt;
&lt;h3 id=&quot;ding-yi-1&quot;&gt;定义&lt;&#x2F;h3&gt;
&lt;p&gt;Follow集的定义在我们上面的求法的基础上进行了扩展：&lt;&#x2F;p&gt;
&lt;blockquote&gt;
&lt;p&gt;“Define $FOLLOW(A)$, for nonterminal A, to be the set of terminals $a$ that can appear immediately to the right of A in some sentential form; that is, the set of terminals a such that there exists a derivation of the form $S \stackrel{*}{\Rightarrow} \alpha Aa\beta$, for some $\alpha$ and $\beta$”&lt;&#x2F;p&gt;
&lt;p&gt;——  “Compilers: Principles, Techniques, and Tools, 2&#x2F;e” &lt;&#x2F;p&gt;
&lt;&#x2F;blockquote&gt;
&lt;p&gt;Follow集就是在文法的所有句子中，可能出现在“由非终结符A生成的部分”之后的终结符的集合。而上述例子所求的其实就是这里的“终结符”为“输入结束标记”的特例。&lt;&#x2F;p&gt;
&lt;h3 id=&quot;qiu-fa-1&quot;&gt;求法&lt;&#x2F;h3&gt;
&lt;blockquote&gt;
&lt;ol&gt;
&lt;li&gt;Place $\$$ in $FOLLOW(S)$, where S is the start symbol, and $ is the input right endmarker.&lt;&#x2F;li&gt;
&lt;li&gt;If there is a production $A → αBβ$, then everything in $FIRST(β)$ except $\epsilon$ is in $FOLLOW(B)$.&lt;&#x2F;li&gt;
&lt;li&gt;If there is a production $A → αB$, or a production $A → αBβ$, where $FIRST(β)$ contains $\epsilon$, then everything in $FOLLOW(A)$is in $FOLLOW(B)$.
—— “Compilers: Principles, Techniques, and Tools, 2&#x2F;e”&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
&lt;&#x2F;blockquote&gt;
&lt;ol&gt;
&lt;li&gt;输入结束标记（龙书中称为$\$$）在$FOLLOW(S)$中&lt;&#x2F;li&gt;
&lt;li&gt;若有$A → αBβ$，则 $FIRST(β)$ 中所有不为 $\epsilon$ 的元素都在 $FOLLOW(B)$ 中&lt;&#x2F;li&gt;
&lt;li&gt;若有$A → αB$，或 $A → αBβ$，其中 $FIRST(β)$ 包含 $\epsilon$ 则 $FOLLOW(A)$ 中的所有元素也在 $FOLLOW(B)$ 中。&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
&lt;p&gt;和我们上面的例子唯一差别在于第2条，不过也很好想，$FIRST(β)$就是$\beta$能推出的第一个非终结符的所有可能取值的集合，而$B$与$β$是紧挨着的，$B$的下一个元素就是$\beta$的第一个元素（$\epsilon$除外）。&lt;&#x2F;p&gt;
&lt;h2 id=&quot;zong-jie&quot;&gt;总结&lt;&#x2F;h2&gt;
&lt;p&gt;有了上面讲的填这类表的方法之后，对于填完后每个格子至多只有一个推导式的文法，我们就可以写出完全不含有回朔的自顶向下文法分析器（递归或者非递归均可），这类文法也就是$LL(1)$文法。当然如果将表头中的一个符号变为多个符号的组合，这种方法也可以推广到$LL(N)$文法上。&lt;&#x2F;p&gt;
&lt;p&gt;同时我们也终于明白了$FIRST$集和$FOLLOW$集的求法，这两个集合在之后的移进-规约分析中也有用。&lt;&#x2F;p&gt;
&lt;div class=&quot;footnote-definition&quot; id=&quot;1&quot;&gt;&lt;sup class=&quot;footnote-definition-label&quot;&gt;1&lt;&#x2F;sup&gt;
&lt;p&gt;这里可能要自己感觉一下，如果有人有更好的讲法，请在评论区留言&lt;&#x2F;p&gt;
&lt;&#x2F;div&gt;
&lt;div class=&quot;footnote-definition&quot; id=&quot;2&quot;&gt;&lt;sup class=&quot;footnote-definition-label&quot;&gt;2&lt;&#x2F;sup&gt;
&lt;p&gt;注意这里“数次”含0次，所以起始符号自然符合要求&lt;&#x2F;p&gt;
&lt;&#x2F;div&gt;
</content>
        
    </entry>
    <entry xml:lang="zh">
        <title>Parsing • 最简单的 Parser 写法——含回朔的递归自顶而下分析</title>
        <published>2020-05-17T16:30:31.045+00:00</published>
        <updated>2020-05-17T16:30:31.045+00:00</updated>
        <author>
          <name>Unknown</name>
        </author>
        <link rel="alternate" href="https://longfangsong.github.io/parsing-combinator/" type="text/html"/>
        <id>https://longfangsong.github.io/parsing-combinator/</id>
        
        <content type="html">&lt;p&gt;如果你听了老师上课讲的那一大坨根本没人听得懂的parse方法之后认为自己这辈子都造不出编译器了，那么本文介绍含回朔的递归自顶而下分析法正是你所需要的，这种方式非常容易想到，也非常容易编写，除了文法分析之外，对于词法分析，这个方法也可以一手包办，而且足以应付绝大多数编程语言的构造。&lt;&#x2F;p&gt;
&lt;p&gt;我们先结合一个例子来看一下这玩意怎么使的：&lt;&#x2F;p&gt;
&lt;h2 id=&quot;zhu-yao-si-xiang&quot;&gt;主要思想&lt;&#x2F;h2&gt;
&lt;p&gt;含回朔的递归自顶而下分析法的主要思想是：将每个非终结符（推导式左边）的分析写成一个函数，将右侧的内容组合写在函数体里面，如果这个函数从左向右匹配某段代码字符串成功，就返回存放了对应信息的结构体和剩下的字符串，否则返回Error。&lt;&#x2F;p&gt;
&lt;h2 id=&quot;shi-jian&quot;&gt;实践&lt;&#x2F;h2&gt;
&lt;p&gt;我们要分析的文法是：
$$
\displaylines {
Expression \rightarrow Ident | Constant | InBrackets \mid Expression * Expression | Expression + Expression \\
InBrackets \rightarrow &#x27;(&#x27; Expression&#x27;)&#x27; \\
Ident \rightarrow [a-zA-Z][a-zA-Z0-9]* \\
Constant \rightarrow [0-9]*
}
$$&lt;&#x2F;p&gt;
&lt;p&gt;上面的例子可以写成四个函数&lt;sup class=&quot;footnote-reference&quot;&gt;&lt;a href=&quot;#1&quot;&gt;1&lt;&#x2F;a&gt;&lt;&#x2F;sup&gt;：&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;expression&lt;&#x2F;span&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;code&lt;&#x2F;span&gt;&lt;span&gt;: string) -&amp;gt; (Expresion, string) | Error;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;in_brackets&lt;&#x2F;span&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;code&lt;&#x2F;span&gt;&lt;span&gt;: string) -&amp;gt; (InBrackets, string) | Error;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;ident&lt;&#x2F;span&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;code&lt;&#x2F;span&gt;&lt;span&gt;: string) -&amp;gt; (Ident, string) | Error;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;constant&lt;&#x2F;span&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;code&lt;&#x2F;span&gt;&lt;span&gt;: string) -&amp;gt; (Constant, string) | Error;
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;那么函数体怎么写呢？&lt;&#x2F;p&gt;
&lt;h3 id=&quot;alt-many0he-tag&quot;&gt;&lt;code&gt;alt&lt;&#x2F;code&gt;、&lt;code&gt;many0&lt;&#x2F;code&gt;和&lt;code&gt;tag&lt;&#x2F;code&gt;&lt;&#x2F;h3&gt;
&lt;p&gt;我们首先针对&lt;code&gt;|&lt;&#x2F;code&gt;和&lt;code&gt;*&lt;&#x2F;code&gt;，定义两个函数：&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;&#x2F;&#x2F; 接受一组parser函数和字符串作为参数，返回其中最早成功匹配的parser的匹配结果，相当于|
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;alt&lt;&#x2F;span&gt;&lt;span&gt;&amp;lt;R&amp;gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;parsers&lt;&#x2F;span&gt;&lt;span&gt;: Vec&amp;lt;Fn(string) -&amp;gt; (R, string) &lt;&#x2F;span&gt;&lt;span style=&quot;background-color:#bf616a;color:#2b303b;&quot;&gt;|&lt;&#x2F;span&gt;&lt;span&gt; Error&amp;gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;input&lt;&#x2F;span&gt;&lt;span&gt;: string) -&amp;gt; (R, string) | Error {
&lt;&#x2F;span&gt;&lt;span&gt;	&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;for&lt;&#x2F;span&gt;&lt;span&gt; parser in parsers {
&lt;&#x2F;span&gt;&lt;span&gt;		&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;if &lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;parser&lt;&#x2F;span&gt;&lt;span&gt;(input) != Error {
&lt;&#x2F;span&gt;&lt;span&gt;			&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;return &lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;parser&lt;&#x2F;span&gt;&lt;span&gt;(input)
&lt;&#x2F;span&gt;&lt;span&gt;		}
&lt;&#x2F;span&gt;&lt;span&gt;	}
&lt;&#x2F;span&gt;&lt;span&gt;	&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;return&lt;&#x2F;span&gt;&lt;span&gt; Error
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;&#x2F;&#x2F; 接受一个parser函数，返回其重复匹配0次以上的结果，相当于*
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;many0&lt;&#x2F;span&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;parser&lt;&#x2F;span&gt;&lt;span&gt;: Fn(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;string&lt;&#x2F;span&gt;&lt;span&gt;) -&amp;gt; (&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;R&lt;&#x2F;span&gt;&lt;span&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;string&lt;&#x2F;span&gt;&lt;span&gt;) | Error, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;input&lt;&#x2F;span&gt;&lt;span&gt;: string) -&amp;gt; (Vec&amp;lt;R&amp;gt;, string) | Error {
&lt;&#x2F;span&gt;&lt;span&gt;	result = new Vec();
&lt;&#x2F;span&gt;&lt;span&gt;	&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;while &lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;parser&lt;&#x2F;span&gt;&lt;span&gt;(input) != error {
&lt;&#x2F;span&gt;&lt;span&gt;		r, input = &lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;parser&lt;&#x2F;span&gt;&lt;span&gt;(input)
&lt;&#x2F;span&gt;&lt;span&gt;		result.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;push&lt;&#x2F;span&gt;&lt;span&gt;(r)
&lt;&#x2F;span&gt;&lt;span&gt;	}
&lt;&#x2F;span&gt;&lt;span&gt;	&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;return &lt;&#x2F;span&gt;&lt;span&gt;(result, input)
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;在实现一个&lt;code&gt;tag&lt;&#x2F;code&gt;函数来识别某些指定的字面量&lt;sup class=&quot;footnote-reference&quot;&gt;&lt;a href=&quot;#2&quot;&gt;2&lt;&#x2F;a&gt;&lt;&#x2F;sup&gt;：&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;tag&lt;&#x2F;span&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;tagname&lt;&#x2F;span&gt;&lt;span&gt;: string, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;code&lt;&#x2F;span&gt;&lt;span&gt;: string) -&amp;gt; (string, string) | Error {
&lt;&#x2F;span&gt;&lt;span&gt;	&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;if&lt;&#x2F;span&gt;&lt;span&gt; code.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;starts_with&lt;&#x2F;span&gt;&lt;span&gt;(tagname) {
&lt;&#x2F;span&gt;&lt;span&gt;		&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;return&lt;&#x2F;span&gt;&lt;span&gt; tagname, code[&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;len&lt;&#x2F;span&gt;&lt;span&gt;(tagname):]
&lt;&#x2F;span&gt;&lt;span&gt;	} &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;else &lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;		&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;return&lt;&#x2F;span&gt;&lt;span&gt; Error
&lt;&#x2F;span&gt;&lt;span&gt;	}
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;然后就可以实现上面的几个函数了：&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;mul&lt;&#x2F;span&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;code&lt;&#x2F;span&gt;&lt;span&gt;: string) -&amp;gt; (Expression, string) | Error {
&lt;&#x2F;span&gt;&lt;span&gt;	&lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;&#x2F;&#x2F; 识别左操作数, ? 代表如果它前面的函数返回Error，则当前函数也返回Error
&lt;&#x2F;span&gt;&lt;span&gt;	lhs, rest = &lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;expression&lt;&#x2F;span&gt;&lt;span&gt;(code)?
&lt;&#x2F;span&gt;&lt;span&gt;	&lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;&#x2F;&#x2F; 识别*号
&lt;&#x2F;span&gt;&lt;span&gt;	op, rest = &lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;tag&lt;&#x2F;span&gt;&lt;span&gt;(&amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;*&lt;&#x2F;span&gt;&lt;span&gt;&amp;quot;, rest)?
&lt;&#x2F;span&gt;&lt;span&gt;	&lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;&#x2F;&#x2F; 识别右操作数
&lt;&#x2F;span&gt;&lt;span&gt;	rhs, rest = &lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;expression&lt;&#x2F;span&gt;&lt;span&gt;(rest)?
&lt;&#x2F;span&gt;&lt;span&gt;	&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;return&lt;&#x2F;span&gt;&lt;span&gt; Expression {lhs, &amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;*&lt;&#x2F;span&gt;&lt;span&gt;&amp;quot;, rhs}
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;&#x2F;&#x2F; add 函数同理，*变为+
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;expression&lt;&#x2F;span&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;code&lt;&#x2F;span&gt;&lt;span&gt;: string) -&amp;gt; (Expresion, string) | Error {
&lt;&#x2F;span&gt;&lt;span&gt;	&lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;&#x2F;&#x2F; 注意这里的顺序，优先级越低操作符对应的函数越要在前面
&lt;&#x2F;span&gt;&lt;span&gt;	&lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;&#x2F;&#x2F; 不理解的话考虑一下1+2*3会怎么被parse就知道了
&lt;&#x2F;span&gt;&lt;span&gt;	&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;return &lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;alt&lt;&#x2F;span&gt;&lt;span&gt;([
&lt;&#x2F;span&gt;&lt;span&gt;		add,
&lt;&#x2F;span&gt;&lt;span&gt;		mul,
&lt;&#x2F;span&gt;&lt;span&gt;		ident,
&lt;&#x2F;span&gt;&lt;span&gt;		constant,
&lt;&#x2F;span&gt;&lt;span&gt;		in_brackets,
&lt;&#x2F;span&gt;&lt;span&gt;	], code)
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;in_brackets&lt;&#x2F;span&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;code&lt;&#x2F;span&gt;&lt;span&gt;: string) -&amp;gt; (InBrackets, string) | Error {
&lt;&#x2F;span&gt;&lt;span&gt;	bracket, rest = &lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;tag&lt;&#x2F;span&gt;&lt;span&gt;(&amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;(&lt;&#x2F;span&gt;&lt;span&gt;&amp;quot;,code)?
&lt;&#x2F;span&gt;&lt;span&gt;	expr, rest = &lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;expression&lt;&#x2F;span&gt;&lt;span&gt;(rest)?
&lt;&#x2F;span&gt;&lt;span&gt;	bracket, rest = &lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;tag&lt;&#x2F;span&gt;&lt;span&gt;(&amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;)&lt;&#x2F;span&gt;&lt;span&gt;&amp;quot;,code)?
&lt;&#x2F;span&gt;&lt;span&gt;	&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;return&lt;&#x2F;span&gt;&lt;span&gt; InBrackets(expr), rest
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;ident&lt;&#x2F;span&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;code&lt;&#x2F;span&gt;&lt;span&gt;: string) -&amp;gt; (Ident, string) | Error {
&lt;&#x2F;span&gt;&lt;span&gt;	&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;return &lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;alt&lt;&#x2F;span&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;tag&lt;&#x2F;span&gt;&lt;span&gt;(&amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;a&lt;&#x2F;span&gt;&lt;span&gt;&amp;quot;, code), &lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;tag&lt;&#x2F;span&gt;&lt;span&gt;(&amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;b&lt;&#x2F;span&gt;&lt;span&gt;&amp;quot;, code),........) 
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;digit&lt;&#x2F;span&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;code&lt;&#x2F;span&gt;&lt;span&gt;: string) -&amp;gt; (string, string) | Error {
&lt;&#x2F;span&gt;&lt;span&gt;	&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;return &lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;alt&lt;&#x2F;span&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;tag&lt;&#x2F;span&gt;&lt;span&gt;(&amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;0&lt;&#x2F;span&gt;&lt;span&gt;&amp;quot;, code), &lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;tag&lt;&#x2F;span&gt;&lt;span&gt;(&amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;1&lt;&#x2F;span&gt;&lt;span&gt;&amp;quot;, code),........) 
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;constant&lt;&#x2F;span&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;code&lt;&#x2F;span&gt;&lt;span&gt;: string) -&amp;gt; (Constant, string) | Error {
&lt;&#x2F;span&gt;&lt;span&gt;	&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;return &lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;many0&lt;&#x2F;span&gt;&lt;span&gt;(digit, code)
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;h3 id=&quot;zuo-di-gui&quot;&gt;左递归&lt;&#x2F;h3&gt;
&lt;p&gt;实际写出来之后会发现这里有一个问题：&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;expression&lt;&#x2F;span&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;code&lt;&#x2F;span&gt;&lt;span&gt;: string) -&amp;gt; (Expresion, string) | Error {
&lt;&#x2F;span&gt;&lt;span&gt;	&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;return &lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;alt&lt;&#x2F;span&gt;&lt;span&gt;([
&lt;&#x2F;span&gt;&lt;span&gt;		add,
&lt;&#x2F;span&gt;&lt;span&gt;		mul,
&lt;&#x2F;span&gt;&lt;span&gt;		ident,
&lt;&#x2F;span&gt;&lt;span&gt;		constant,
&lt;&#x2F;span&gt;&lt;span&gt;		in_brackets,
&lt;&#x2F;span&gt;&lt;span&gt;	], code)
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;其中的&lt;code&gt;mul&lt;&#x2F;code&gt;，间接调用了&lt;code&gt;expression(code)&lt;&#x2F;code&gt;，而这时又会反过去调用&lt;code&gt;mul(code)&lt;&#x2F;code&gt;，且其中的&lt;code&gt;code&lt;&#x2F;code&gt;参数一直没有变化，&lt;code&gt;add&lt;&#x2F;code&gt;也有这个问题，这样在程序中就会造成无限递归。&lt;&#x2F;p&gt;
&lt;p&gt;这也是为什么课上说在做自顶而下文法分析的时候要先消除左递归的原因。&lt;&#x2F;p&gt;
&lt;p&gt;怎么消除也很简单，我们要让&lt;code&gt;mul&lt;&#x2F;code&gt;和&lt;code&gt;add&lt;&#x2F;code&gt;至少从&lt;code&gt;code&lt;&#x2F;code&gt;中“消耗”一个优先级比其自身高的expression，即：&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#2b303b;color:#c0c5ce;&quot;&gt;&lt;code&gt;&lt;span&gt;fn higher_than_mul(code: string) -&amp;gt; (Expression, string) | Error {
&lt;&#x2F;span&gt;&lt;span&gt;	return alt([
&lt;&#x2F;span&gt;&lt;span&gt;		ident,
&lt;&#x2F;span&gt;&lt;span&gt;		constant,
&lt;&#x2F;span&gt;&lt;span&gt;		in_brackets
&lt;&#x2F;span&gt;&lt;span&gt;	], code)
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;fn mul(code: string) -&amp;gt; (Expression, string) | Error {
&lt;&#x2F;span&gt;&lt;span&gt;	&#x2F;&#x2F; 识别左操作数, 消耗掉一个优先级高于*结果的语法元素
&lt;&#x2F;span&gt;&lt;span&gt;	lhs, rest = higher_than_mul(code)?
&lt;&#x2F;span&gt;&lt;span&gt;	&#x2F;&#x2F; 识别*号
&lt;&#x2F;span&gt;&lt;span&gt;	op, rest = tag(&amp;quot;*&amp;quot;, rest)?
&lt;&#x2F;span&gt;&lt;span&gt;	&#x2F;&#x2F; 识别右操作数
&lt;&#x2F;span&gt;&lt;span&gt;	rhs, rest = expression(rest)?
&lt;&#x2F;span&gt;&lt;span&gt;	return Expression {lhs, &amp;quot;*&amp;quot;, rhs}
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;&#x2F;&#x2F; add 同理，你应该自己能想到的
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;实际上就相当于将Expression部分的文法改成了：
$$
\displaylines {
Expression \rightarrow Add | Mul | Ident | Constant | InBrackets \\
Add \rightarrow HigherThanAdd + Expression \\
Mul \rightarrow HigherThanMul * Expression \\
HigherThanMul \rightarrow Ident | Constant|InBrackets \\
HigherThanAdd \rightarrow Mul | HighterThanMul
}
$$
和书上讲的消除左递归的方案是不是很像？&lt;&#x2F;p&gt;
&lt;p&gt;这样一个简单表达式的parser就完成了。&lt;&#x2F;p&gt;
&lt;h2 id=&quot;you-shi-yu-bu-zu&quot;&gt;优势与不足&lt;&#x2F;h2&gt;
&lt;h3 id=&quot;you-shi&quot;&gt;优势&lt;&#x2F;h3&gt;
&lt;p&gt;这种parser的优势有：&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;容易理解与实现&lt;&#x2F;li&gt;
&lt;li&gt;写出的代码是完全可读可调试的&lt;&#x2F;li&gt;
&lt;li&gt;这种分析器可以分析 $LL(k)$ 文法，在实践中，这一分析器可以应用于几乎所有可能会碰到的文法，当然，除了C++之外，C++不是$CFG$……。&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;h3 id=&quot;bu-zu&quot;&gt;不足&lt;&#x2F;h3&gt;
&lt;p&gt;这种parser的不足有：&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;效率问题，回朔可能会带来一定的性能问题，因此可能不适用于一些极其要求性能的场合&lt;sup class=&quot;footnote-reference&quot;&gt;&lt;a href=&quot;#3&quot;&gt;3&lt;&#x2F;a&gt;&lt;&#x2F;sup&gt;&lt;&#x2F;li&gt;
&lt;li&gt;一般来说生成的所有运算符都是右结合的，上面的例子由于加法和乘法都有交换律所以也没关系，但是减法和除法就会出现问题，需要在 AST 上做 hack 解决，hack 的一个方案如下：
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;将文法的相应部分改写成：
$$
\displaylines {
Add \rightarrow HigherThanAdd\ (+ HigherThanAdd)* \\
Mul \rightarrow HigherThanMul\ (* HigherThanMul)* \\
}
$$&lt;&#x2F;p&gt;
&lt;p&gt;然后将 parse 得到的东西用如下方法转换（折叠）为 AST：&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;to_ast&lt;&#x2F;span&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;first&lt;&#x2F;span&gt;&lt;span&gt;: RValue, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;rest&lt;&#x2F;span&gt;&lt;span&gt;: Vec&amp;lt;(String, RValue)&amp;gt;) -&amp;gt; BinOp {
&lt;&#x2F;span&gt;&lt;span&gt;  &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;let mut&lt;&#x2F;span&gt;&lt;span&gt; current_lhs = first;
&lt;&#x2F;span&gt;&lt;span&gt;  &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;for &lt;&#x2F;span&gt;&lt;span&gt;(op, value) in rest.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;into_iter&lt;&#x2F;span&gt;&lt;span&gt;() {
&lt;&#x2F;span&gt;&lt;span&gt;      current_lhs = BinOp {
&lt;&#x2F;span&gt;&lt;span&gt;          operator: op,
&lt;&#x2F;span&gt;&lt;span&gt;          lhs: Box::new(current_lhs),
&lt;&#x2F;span&gt;&lt;span&gt;          rhs: Box::new(value),
&lt;&#x2F;span&gt;&lt;span&gt;      }
&lt;&#x2F;span&gt;&lt;span&gt;      .&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;into&lt;&#x2F;span&gt;&lt;span&gt;()
&lt;&#x2F;span&gt;&lt;span&gt;  }
&lt;&#x2F;span&gt;&lt;span&gt;  current_lhs.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;try_into&lt;&#x2F;span&gt;&lt;span&gt;().&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;unwrap&lt;&#x2F;span&gt;&lt;span&gt;()
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;div class=&quot;footnote-definition&quot; id=&quot;1&quot;&gt;&lt;sup class=&quot;footnote-definition-label&quot;&gt;1&lt;&#x2F;sup&gt;
&lt;p&gt;本文中的代码均为伪代码，返回类型也不太严谨（如果你一定要深究的话，那么可以把它们看作是协变的），实际实现可以参考&lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;Geal&#x2F;nom&quot;&gt;Geal&#x2F;nom&lt;&#x2F;a&gt;及&lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;longfangsong&#x2F;tiny-nom&quot;&gt;我对其的简化实现&lt;&#x2F;a&gt;。&lt;&#x2F;p&gt;
&lt;&#x2F;div&gt;
&lt;div class=&quot;footnote-definition&quot; id=&quot;2&quot;&gt;&lt;sup class=&quot;footnote-definition-label&quot;&gt;2&lt;&#x2F;sup&gt;
&lt;p&gt;你可以认为tag是用来识别“终结符”的&lt;&#x2F;p&gt;
&lt;&#x2F;div&gt;
&lt;div class=&quot;footnote-definition&quot; id=&quot;3&quot;&gt;&lt;sup class=&quot;footnote-definition-label&quot;&gt;3&lt;&#x2F;sup&gt;
&lt;p&gt;一般的编译器中，文法分析器的性能其实是无需首先考虑的（后端每个步骤的耗时常常是整个前端的耗时的十倍甚至百倍之多），但在部分场合比如数据库中SQL的解释中，较慢的文法分析器可能会带来性能瓶颈。&lt;&#x2F;p&gt;
&lt;&#x2F;div&gt;
</content>
        
    </entry>
    <entry xml:lang="zh">
        <title>分布式系统 • 两阶段提交</title>
        <published>2020-04-23T16:09:46.815+00:00</published>
        <updated>2020-04-23T16:09:46.815+00:00</updated>
        <author>
          <name>Unknown</name>
        </author>
        <link rel="alternate" href="https://longfangsong.github.io/2pc/" type="text/html"/>
        <id>https://longfangsong.github.io/2pc/</id>
        
        <content type="html">&lt;blockquote&gt;
&lt;p&gt;经典的分布式数据库模型中，同一个数据库的各个副本运行在不同的节点上，每个副本的数 据要求完全一致。数据库中的操作都是事务 (transaction)，一个事务是一系列读、写操作，事务满足 ACID。每个事务的最终状态要么是提交 (commit)，要么是失败 (abort)。一旦一个事务成功提交，那么这个事务中所有的写操作中成功，否则所有的写操作都失败。&lt;&#x2F;p&gt;
&lt;&#x2F;blockquote&gt;
&lt;p&gt;为了适应这种 ACID 模型，2PC 提供的解决方案是：首先由一个节点（提议者）询问每个其他节点（参与者）是否同意提交某个事务，如果全部同意，则实际提交这个事务，否则拒绝提交这个事务。&lt;&#x2F;p&gt;
&lt;h2 id=&quot;gong-zuo-liu-cheng&quot;&gt;工作流程&lt;&#x2F;h2&gt;
&lt;h3 id=&quot;cheng-gong-ti-jiao&quot;&gt;成功提交&lt;&#x2F;h3&gt;
&lt;p&gt;在任何一个新的事务到来时，master会先将事务开始的相关信息写入日志。&lt;&#x2F;p&gt;
&lt;p&gt;注意要 commit 的内容在第一次询问时会被 cache 在各个 node 上，如果决定了 commit，直接做这个 cache 里的内容就好了，这部分 cache 也被用于决定后续的事务是否可以被提交。&lt;&#x2F;p&gt;
&lt;p&gt;&lt;img src=&quot;https:&#x2F;&#x2F;longfangsong.github.io&#x2F;2pc&#x2F;2pc-step1.svg&quot; alt=&quot;2pc-step1&quot; &#x2F;&gt;&lt;&#x2F;p&gt;
&lt;hr &#x2F;&gt;
&lt;p&gt;&lt;img src=&quot;https:&#x2F;&#x2F;longfangsong.github.io&#x2F;2pc&#x2F;2pc-step2-all-agree.svg&quot; alt=&quot;2pc-step2-all-agree&quot; &#x2F;&gt;&lt;&#x2F;p&gt;
&lt;hr &#x2F;&gt;
&lt;p&gt;&lt;img src=&quot;https:&#x2F;&#x2F;longfangsong.github.io&#x2F;2pc&#x2F;2pc-step3-do-commit.svg&quot; alt=&quot;2pc-step3-do-commit&quot; &#x2F;&gt;&lt;&#x2F;p&gt;
&lt;hr &#x2F;&gt;
&lt;p&gt;注意最后的 commit 请求完成后node还需要通知一声master，让master记录此次事务完成。&lt;&#x2F;p&gt;
&lt;h3 id=&quot;shi-bai&quot;&gt;失败&lt;&#x2F;h3&gt;
&lt;p&gt;失败提交的可能场景是某些节点上其他事务（可能是上一步留下来还没有完成提交的事务）和待提交的事务有冲突。&lt;&#x2F;p&gt;
&lt;p&gt;&lt;img src=&quot;https:&#x2F;&#x2F;longfangsong.github.io&#x2F;2pc&#x2F;2pc-step1-8094287.svg&quot; alt=&quot;2pc-step1&quot; &#x2F;&gt;&lt;&#x2F;p&gt;
&lt;hr &#x2F;&gt;
&lt;p&gt;&lt;img src=&quot;https:&#x2F;&#x2F;longfangsong.github.io&#x2F;2pc&#x2F;2pc-step2-has-disagree.svg&quot; alt=&quot;2pc-step2-has-disagree&quot; &#x2F;&gt;&lt;&#x2F;p&gt;
&lt;hr &#x2F;&gt;
&lt;p&gt;&lt;img src=&quot;https:&#x2F;&#x2F;longfangsong.github.io&#x2F;2pc&#x2F;2pc-step3-do-reject.svg&quot; alt=&quot;2pc-step3-do-reject&quot; &#x2F;&gt;&lt;&#x2F;p&gt;
&lt;h2 id=&quot;yi-chang-qing-kuang-chu-li&quot;&gt;异常情况处理&lt;&#x2F;h2&gt;
&lt;h3 id=&quot;dang-ji&quot;&gt;宕机&lt;&#x2F;h3&gt;
&lt;p&gt;宕机恢复后可以通过日志确定自己处于何种状态。&lt;&#x2F;p&gt;
&lt;h4 id=&quot;master&quot;&gt;Master&lt;&#x2F;h4&gt;
&lt;p&gt;Master宕机后恢复，如果发现自己处于：&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;事务开始了，但还没有作出决定是否commit最后一个事务的状态&lt;&#x2F;p&gt;
&lt;p&gt;那么重新询问全部节点是否可以commit，然后继续一般流程即可。&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;已经决定是否commit最后一个事务，但还没有实际commit&#x2F;reject的状态&lt;&#x2F;p&gt;
&lt;p&gt;简单地从通知所有节点实际进行commit&#x2F;reject这步开始继续一般流程即可。&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;h4 id=&quot;node&quot;&gt;Node&lt;&#x2F;h4&gt;
&lt;p&gt;Node宕机后恢复，如果发现自己处于：&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;已经接到对某个事务的投票请求，但还未投票&lt;&#x2F;p&gt;
&lt;p&gt;检查并投票，然后继续流程。&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;已经投票，但还没有实际提交&lt;&#x2F;p&gt;
&lt;p&gt;等待Master发送&#x2F;重发commit&#x2F;reject消息即可&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;h3 id=&quot;chao-shi&quot;&gt;超时&lt;&#x2F;h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Node为某次事务是否commit的投票超时&lt;&#x2F;p&gt;
&lt;p&gt;Master直接认为它选择了reject这个事务。&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;Node某次事务实际提交&#x2F;拒绝后的确认超时&lt;&#x2F;p&gt;
&lt;p&gt;不断重试要求其提交，直到Node再次上线并返回确认。&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;Node迟迟没有收到Master对某次事务的最终决定&lt;&#x2F;p&gt;
&lt;p&gt;不断重发自己的投票结果，直到收到决定。&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;这种不断重试的机制决定了2PC如果不加修改的话，A和P都是很糟糕的，不过相应地也换来了完全的C。&lt;&#x2F;p&gt;
</content>
        
    </entry>
    <entry xml:lang="zh">
        <title>分布式系统 • CAP 定理</title>
        <published>2020-04-23T16:09:46.815+00:00</published>
        <updated>2022-07-13T23:38:26+00:00</updated>
        <author>
          <name>Unknown</name>
        </author>
        <link rel="alternate" href="https://longfangsong.github.io/cap-theorem/" type="text/html"/>
        <id>https://longfangsong.github.io/cap-theorem/</id>
        
        <content type="html">&lt;p&gt;CAP 定理是说，对于一个分布式系统来说，不可能同时满足以下三点：&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;（强外部）一致性（&lt;strong&gt;C&lt;&#x2F;strong&gt;onsistency）&lt;&#x2F;li&gt;
&lt;li&gt;可用性（&lt;strong&gt;A&lt;&#x2F;strong&gt;vailability）（即每次请求没有物理上不可用的节点时都能获取到非错的响应）&lt;&#x2F;li&gt;
&lt;li&gt;分区容错性（&lt;strong&gt;P&lt;&#x2F;strong&gt;artition tolerance）（即如果分布式系统由于某些原因，存在互相不能通信的两&#x2F;几组节点，那么这个系统仍然应该正常的提供服务）&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;h2 id=&quot;li-zi-zhi-guan-de-bu-yan-ge-zheng-ming&quot;&gt;例子（直观的不严格证明）&lt;&#x2F;h2&gt;
&lt;p&gt;假设有两个节点和一个Client：&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;如果要保证可用性（A）和分区容错性（P），那么在网络出现分区时，无论用户的请求被发送到了两个节点中的任何一个，无论如何都要做出相应，而在一个节点上的插入请求无法被另一个节点知道，这样两个节点间不可能保持一致性，即放弃了C。&lt;&#x2F;p&gt;
&lt;p&gt;&lt;img src=&quot;https:&#x2F;&#x2F;longfangsong.github.io&#x2F;cap-theorem&#x2F;AP.png&quot; alt=&quot;AP&quot; &#x2F;&gt;&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;如果要保证一致性（C）和分区容错性（P），那么为了修正上一个系统的问题，对在插入某个数据时没有得到插入的节点，或者其上对应数据不是最新的节点，在被请求这个数据时只能返回错误，这就放弃了A。&lt;&#x2F;p&gt;
&lt;p&gt;&lt;img src=&quot;https:&#x2F;&#x2F;longfangsong.github.io&#x2F;cap-theorem&#x2F;CP.png&quot; alt=&quot;CP&quot; &#x2F;&gt;&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;如果要保证一致性（C）和可用性（A），那么不得不允许两个节点之间可以通信，在每次插入时将数据分发到每一个节点上，但此时如果节点之间网络不可达，那么这个分发操作就不可行。&lt;&#x2F;p&gt;
&lt;p&gt;&lt;img src=&quot;https:&#x2F;&#x2F;longfangsong.github.io&#x2F;cap-theorem&#x2F;CA.png&quot; alt=&quot;CA&quot; &#x2F;&gt;&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;h2 id=&quot;chang-jian-wu-qu&quot;&gt;常见误区&lt;&#x2F;h2&gt;
&lt;p&gt;要注意的是，实践中并不是说去选择 CAP 中的两个，放弃另外一个。CAP 里的每个标准都不是绝对的“有”或者“没有”的关系，而是一个程度的问题，例如一致性可以降低到任何一个一致性等级，可用性可以做到 n 个 9，而分区容错性可以降低到有“部分”节点和其他部分不能通信时整个系统可用的程度。&lt;&#x2F;p&gt;
</content>
        
    </entry>
    <entry xml:lang="zh">
        <title>分布式系统 • 基本概念</title>
        <published>2020-04-22T16:09:46.815+00:00</published>
        <updated>2020-04-22T16:09:46.815+00:00</updated>
        <author>
          <name>Unknown</name>
        </author>
        <link rel="alternate" href="https://longfangsong.github.io/distributed-system/" type="text/html"/>
        <id>https://longfangsong.github.io/distributed-system/</id>
        
        <content type="html">&lt;p&gt;先拜一拜伟大的 &lt;strong&gt;Leslie Lamport&lt;&#x2F;strong&gt; 祖师爷。&lt;&#x2F;p&gt;
&lt;p&gt;&lt;img src=&quot;https:&#x2F;&#x2F;upload.wikimedia.org&#x2F;wikipedia&#x2F;commons&#x2F;thumb&#x2F;5&#x2F;50&#x2F;Leslie_Lamport.jpg&#x2F;150px-Leslie_Lamport.jpg&quot; alt=&quot;Leslie Lamport&quot; &#x2F;&gt;&lt;&#x2F;p&gt;
&lt;h2 id=&quot;shi-yao-shi-fen-bu-shi-xi-tong&quot;&gt;什么是分布式系统&lt;&#x2F;h2&gt;
&lt;blockquote&gt;
&lt;p&gt;分布式系统是一组电脑，透过网络相互连接传递消息与通信后并协调它们的行为而形成的系统。 —— wikipedia&lt;&#x2F;p&gt;
&lt;&#x2F;blockquote&gt;
&lt;p&gt;当然我觉得这个定义有点狭窄了，我扩展范围后的定义是：&lt;&#x2F;p&gt;
&lt;blockquote&gt;
&lt;p&gt;分布式系统是一组抽象的计算和存储单元，通过某种方式相互连接传递消息并协调它们的行为而形成的系统。&lt;&#x2F;p&gt;
&lt;&#x2F;blockquote&gt;
&lt;p&gt;讲道理，单机上的一组进程其实也一定程度上具有分布式系统的功能，也存在分布式系统中的问题，只不过部分问题的发生率降低了而已，因此我觉得将分布式系统窄化到多个物理计算机之间是不甚合理的。&lt;sup class=&quot;footnote-reference&quot;&gt;&lt;a href=&quot;#1&quot;&gt;1&lt;&#x2F;a&gt;&lt;&#x2F;sup&gt;&lt;&#x2F;p&gt;
&lt;h2 id=&quot;fen-bu-shi-xi-tong-de-zuo-yong&quot;&gt;分布式系统的作用&lt;&#x2F;h2&gt;
&lt;p&gt;主要是：&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;满足扩展性（Scalability）需求：一台机器吃不消了，多上几台机器就能顶住&lt;&#x2F;li&gt;
&lt;li&gt;满足高可用性（Availability）需求：某几个机器down了，整个服务不能down&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;h2 id=&quot;fen-bu-shi-xi-tong-de-nan-dian&quot;&gt;分布式系统的难点&lt;&#x2F;h2&gt;
&lt;p&gt;分布式系统涉及到多个计算与存储单元（称为节点），故：&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;相比单个节点，更容易出现某些节点故障&lt;&#x2F;li&gt;
&lt;li&gt;节点之间的通信可能出现问题，消息可能会丢失、重复、乱序&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;相对来说，分布式“计算”的门槛是相对较低的，如果某个节点烂了直接换个节点算就行了，而存储问题就比较大了。&lt;&#x2F;p&gt;
&lt;h2 id=&quot;chang-yong-gai-nian&quot;&gt;常用概念&lt;&#x2F;h2&gt;
&lt;h3 id=&quot;nei-bu-yi-zhi-xing&quot;&gt;内部一致性&lt;&#x2F;h3&gt;
&lt;p&gt;内部一致性（Consistency in ACID）指数据库内部的数据完整性（由各类约束、触发器，再加上数据库的隔离性保证）。&lt;&#x2F;p&gt;
&lt;p&gt;当我们在说：&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;zh.wikipedia.org&#x2F;wiki&#x2F;%E5%8F%AF%E4%B8%B2%E8%A1%8C%E6%80%A7&quot;&gt;可串行化&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;zh.wikipedia.org&#x2F;wiki&#x2F;%E5%BF%AB%E7%85%A7%E9%9A%94%E7%A6%BB&quot;&gt;快照隔离&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;zh.wikipedia.org&#x2F;wiki&#x2F;%E4%BA%8B%E5%8B%99%E9%9A%94%E9%9B%A2#%E5%8F%AF%E9%87%8D%E5%A4%8D%E8%AF%BB&quot;&gt;可重复读&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;zh.wikipedia.org&#x2F;wiki&#x2F;%E4%BA%8B%E5%8B%99%E9%9A%94%E9%9B%A2#%E6%8F%90%E4%BA%A4%E8%AF%BB&quot;&gt;读已提交&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;zh.wikipedia.org&#x2F;wiki&#x2F;%E4%BA%8B%E5%8B%99%E9%9A%94%E9%9B%A2#%E6%9C%AA%E6%8F%90%E4%BA%A4%E8%AF%BB&quot;&gt;读未提交&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;li&gt;脏写&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;zh.wikipedia.org&#x2F;wiki&#x2F;%E4%BA%8B%E5%8B%99%E9%9A%94%E9%9B%A2#%E8%84%8F%E8%AF%BB&quot;&gt;脏读&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;zh.wikipedia.org&#x2F;wiki&#x2F;%E4%BA%8B%E5%8B%99%E9%9A%94%E9%9B%A2#%E4%B8%8D%E5%8F%AF%E9%87%8D%E5%A4%8D%E8%AF%BB&quot;&gt;不可重复读&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;zh.wikipedia.org&#x2F;wiki&#x2F;%E4%BA%8B%E5%8B%99%E9%9A%94%E9%9B%A2#%E5%B9%BB%E5%BD%B1%E8%AF%BB&quot;&gt;幻读&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;li&gt;Read Skew&lt;&#x2F;li&gt;
&lt;li&gt;Write Skew&lt;&#x2F;li&gt;
&lt;li&gt;Lost Update&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;我们说的就和内部一致性有关。&lt;&#x2F;p&gt;
&lt;h3 id=&quot;wai-bu-yi-zhi-xing&quot;&gt;外部一致性&lt;&#x2F;h3&gt;
&lt;p&gt;指 Read 和 Write 应该遵守怎样的时间线顺序，比如 Linearizability 外部一致性级别就保证了每一个读操作都将返回“（某个标准时钟规定的）最近的写操作”。
CAP 中的 C 指的是外部一致性。
当我们在说：&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;zh.wikipedia.org&#x2F;wiki&#x2F;%E7%BA%BF%E6%80%A7%E4%B8%80%E8%87%B4%E6%80%A7&quot;&gt;线性一致性&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Sequential_consistency&quot;&gt;顺序一致性&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Causal_consistency&quot;&gt;因果一致性&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;zh.wikipedia.org&#x2F;wiki&#x2F;%E6%9C%80%E7%BB%88%E4%B8%80%E8%87%B4%E6%80%A7&quot;&gt;最终一致性&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;zh.wikipedia.org&#x2F;wiki&#x2F;Raft&quot;&gt;Raft 共识算法&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;zh.wikipedia.org&#x2F;wiki&#x2F;Paxos%E7%AE%97%E6%B3%95&quot;&gt;Paxos 共识算法&lt;&#x2F;a&gt;&lt;sup class=&quot;footnote-reference&quot;&gt;&lt;a href=&quot;#2&quot;&gt;2&lt;&#x2F;a&gt;&lt;&#x2F;sup&gt;&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;我们所说的就和外部一致性相关。&lt;&#x2F;p&gt;
&lt;div class=&quot;footnote-definition&quot; id=&quot;1&quot;&gt;&lt;sup class=&quot;footnote-definition-label&quot;&gt;1&lt;&#x2F;sup&gt;
&lt;p&gt;我记得伟大的羊学长说过，集群是操作系统在网络上scale的结果。&lt;&#x2F;p&gt;
&lt;&#x2F;div&gt;
&lt;div class=&quot;footnote-definition&quot; id=&quot;2&quot;&gt;&lt;sup class=&quot;footnote-definition-label&quot;&gt;2&lt;&#x2F;sup&gt;
&lt;p&gt;有些人称 “XX 共识算法” 为 “XX 一致性算法”，个人觉得可以理解为“用来解决一致性问题的算法”，问题也不大。&lt;&#x2F;p&gt;
&lt;&#x2F;div&gt;
</content>
        
    </entry>
    <entry xml:lang="zh">
        <title>Hello zola!</title>
        <published>2020-01-02T15:00:00+00:00</published>
        <updated>2020-01-02T15:00:00+00:00</updated>
        <author>
          <name>Unknown</name>
        </author>
        <link rel="alternate" href="https://longfangsong.github.io/hello-zola/" type="text/html"/>
        <id>https://longfangsong.github.io/hello-zola/</id>
        
        <content type="html">&lt;p&gt;I wrote a lot of blogs, and I used to use hexo as a static site generator, it kind of work well, but I&#x27;m afraid with more and more posts I have, the speed of hexo become unacceptable, moreover, the plugin system works well if I add only one plugin, but become odd if there&#x27;re many plugins work together:&lt;&#x2F;p&gt;
&lt;p&gt;Here&#x27;s an image from my origin blog, powered by hexo:&lt;&#x2F;p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https:&#x2F;&#x2F;longfangsong.github.io&#x2F;hello-zola&#x2F;ouch.png&quot; alt=&quot;ouch&quot; &#x2F;&gt;&lt;&#x2F;p&gt;
&lt;&#x2F;blockquote&gt;
&lt;p&gt;Ouch!&lt;&#x2F;p&gt;
&lt;p&gt;And then, since I&#x27;m a big fan of Rust, I found zola, though this tool is not as complete as hexo, I can use its shortcodes feature to embed different of things to my blog!&lt;&#x2F;p&gt;
&lt;p&gt;For example, terminal record:&lt;&#x2F;p&gt;
&lt;script id=&quot;asciicast-9EhVw8rujVjpPVBV5kQMdAIHe&quot; src=&quot;https:&#x2F;&#x2F;asciinema.org&#x2F;a&#x2F;9EhVw8rujVjpPVBV5kQMdAIHe.js&quot; async&gt;&lt;&#x2F;script&gt;
&lt;p&gt;Which I never imagined when using hexo!&lt;&#x2F;p&gt;
&lt;p&gt;And zola do make it easier to customize a theme, in hexo, if I want to customize a theme, I have to fork it, and do some edit on it. But in zola I can do this easily by override a template block.&lt;&#x2F;p&gt;
&lt;p&gt;But there remains some problems:&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;The &lt;code&gt;translations&lt;&#x2F;code&gt; in a theme cannot be used in the site based on that theme. Hope will fixed after &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;getzola&#x2F;zola&#x2F;pull&#x2F;1148&quot;&gt;#1148&lt;&#x2F;a&gt;.&lt;&#x2F;li&gt;
&lt;li&gt;Cannot paginate over another section.&lt;sup class=&quot;footnote-reference&quot;&gt;&lt;a href=&quot;#1&quot;&gt;1&lt;&#x2F;a&gt;&lt;&#x2F;sup&gt;&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;Anyway, I&#x27;ll absolutly move my blog to zola.&lt;&#x2F;p&gt;
&lt;p&gt;Also I&#x27;m looking forward to contribute something to this project, and I started with &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;getzola&#x2F;themes&#x2F;pull&#x2F;49&quot;&gt;migrating a theme&lt;&#x2F;a&gt;, which I&#x27;ll also used on my blog.&lt;&#x2F;p&gt;
&lt;p&gt;Hope zola will become a better project in the future!&lt;&#x2F;p&gt;
&lt;div class=&quot;footnote-definition&quot; id=&quot;1&quot;&gt;&lt;sup class=&quot;footnote-definition-label&quot;&gt;1&lt;&#x2F;sup&gt;
&lt;p&gt;Or maybe I misunderstood the &lt;code&gt;pagination&lt;&#x2F;code&gt; feature ...&lt;&#x2F;p&gt;
&lt;&#x2F;div&gt;
</content>
        
    </entry>
    <entry xml:lang="zh">
        <title>一个最简单的编译器的实现</title>
        <published>2019-05-21T16:39:56.026+00:00</published>
        <updated>2019-05-21T16:39:56.026+00:00</updated>
        <author>
          <name>Unknown</name>
        </author>
        <link rel="alternate" href="https://longfangsong.github.io/build-a-compiler-in-the-easiest-way/" type="text/html"/>
        <id>https://longfangsong.github.io/build-a-compiler-in-the-easiest-way/</id>
        
        <content type="html">&lt;p&gt;本文将会带领读者做出一个简单的类C（但比C简单无数倍）语言的编译器。&lt;&#x2F;p&gt;
&lt;p&gt;参考代码在这里，本文完成时的版本是这个。&lt;&#x2F;p&gt;
&lt;p&gt;这个语言支持：&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;两种基本数据类型：&lt;code&gt;int&lt;&#x2F;code&gt; 和 &lt;code&gt;double&lt;&#x2F;code&gt;&lt;&#x2F;li&gt;
&lt;li&gt;上述数据类型的数组&lt;&#x2F;li&gt;
&lt;li&gt;两种控制结构：&lt;code&gt;if&lt;&#x2F;code&gt;（当然可以有可选的 &lt;code&gt;else&lt;&#x2F;code&gt;）和 &lt;code&gt;while&lt;&#x2F;code&gt;&lt;&#x2F;li&gt;
&lt;li&gt;基本数学和关系运算：&lt;code&gt;+&lt;&#x2F;code&gt;、&lt;code&gt;-&lt;&#x2F;code&gt;、&lt;code&gt;*&lt;&#x2F;code&gt;、&lt;code&gt;&#x2F;&lt;&#x2F;code&gt;、&lt;code&gt;&amp;lt;&lt;&#x2F;code&gt;、&lt;code&gt;&amp;lt;=&lt;&#x2F;code&gt;、&lt;code&gt;&amp;gt;&lt;&#x2F;code&gt;、&lt;code&gt;&amp;gt;=&lt;&#x2F;code&gt;、&lt;code&gt;==&lt;&#x2F;code&gt;、&lt;code&gt;!=&lt;&#x2F;code&gt;&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;本文假设读者是一个比较熟练的C语言&lt;sup class=&quot;footnote-reference&quot;&gt;&lt;a href=&quot;#1&quot;&gt;1&lt;&#x2F;a&gt;&lt;&#x2F;sup&gt;程序猿，并具有基本的正则表达式知识。&lt;&#x2F;p&gt;
&lt;p&gt;同时本文读者应当熟悉 flex &amp;amp; bison 的基本使用，如果你对此不熟悉，可以参考我的 &lt;a href=&quot;https:&#x2F;&#x2F;longfangsong.github.io&#x2F;build-a-compiler-in-the-easiest-way&#x2F;.&quot;&gt;另一篇文章&lt;&#x2F;a&gt;。&lt;&#x2F;p&gt;
&lt;h2 id=&quot;bian-yi-guo-cheng&quot;&gt;编译过程&lt;&#x2F;h2&gt;
&lt;p&gt;首先本文中所述的编译器编译一个程序的过程如下&lt;sup class=&quot;footnote-reference&quot;&gt;&lt;a href=&quot;#2&quot;&gt;2&lt;&#x2F;a&gt;&lt;&#x2F;sup&gt;：&lt;&#x2F;p&gt;
&lt;p&gt;&lt;img src=&quot;https:&#x2F;&#x2F;longfangsong.github.io&#x2F;build-a-compiler-in-the-easiest-way&#x2F;.&#x2F;routine.svg&quot; alt=&quot;routine&quot; &#x2F;&gt;&lt;&#x2F;p&gt;
&lt;p&gt;显然很多代码都不用我们自己写，生在这样一个有丰富工具的时代既是幸运，也是一种不幸。&lt;&#x2F;p&gt;
&lt;h3 id=&quot;ci-fa-fen-xi&quot;&gt;词法分析&lt;&#x2F;h3&gt;
&lt;p&gt;在此给出 flex 的关键部分代码：&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;l&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-l &quot;&gt;&lt;code class=&quot;language-l&quot; data-lang=&quot;l&quot;&gt;&lt;span&gt;&amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;char&lt;&#x2F;span&gt;&lt;span&gt;&amp;quot;                      {yylval.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;type&lt;&#x2F;span&gt;&lt;span&gt;=Char; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;return&lt;&#x2F;span&gt;&lt;span&gt; TYPE;}
&lt;&#x2F;span&gt;&lt;span&gt;&amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;int&lt;&#x2F;span&gt;&lt;span&gt;&amp;quot;                       {yylval.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;type&lt;&#x2F;span&gt;&lt;span&gt;=Int; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;return&lt;&#x2F;span&gt;&lt;span&gt; TYPE;}
&lt;&#x2F;span&gt;&lt;span&gt;&amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;double&lt;&#x2F;span&gt;&lt;span&gt;&amp;quot;                    {yylval.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;type&lt;&#x2F;span&gt;&lt;span&gt;=Double; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;return&lt;&#x2F;span&gt;&lt;span&gt; TYPE;}
&lt;&#x2F;span&gt;&lt;span&gt;&amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;string&lt;&#x2F;span&gt;&lt;span&gt;&amp;quot;                    {yylval.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;type&lt;&#x2F;span&gt;&lt;span&gt;=String; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;return&lt;&#x2F;span&gt;&lt;span&gt; TYPE;}
&lt;&#x2F;span&gt;&lt;span&gt;&amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;if&lt;&#x2F;span&gt;&lt;span&gt;&amp;quot;                        {&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;return&lt;&#x2F;span&gt;&lt;span&gt; IF;}
&lt;&#x2F;span&gt;&lt;span&gt;&amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;else&lt;&#x2F;span&gt;&lt;span&gt;&amp;quot;                      {&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;return&lt;&#x2F;span&gt;&lt;span&gt; ELSE;}
&lt;&#x2F;span&gt;&lt;span&gt;&amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;while&lt;&#x2F;span&gt;&lt;span&gt;&amp;quot;                     {&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;return&lt;&#x2F;span&gt;&lt;span&gt; WHILE;}
&lt;&#x2F;span&gt;&lt;span&gt;&amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;print&lt;&#x2F;span&gt;&lt;span&gt;&amp;quot;                     {&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;return&lt;&#x2F;span&gt;&lt;span&gt; PRINT;}
&lt;&#x2F;span&gt;&lt;span&gt;([-])?[&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;0&lt;&#x2F;span&gt;&lt;span&gt;-&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;9&lt;&#x2F;span&gt;&lt;span&gt;]+                {yylval.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;int_value&lt;&#x2F;span&gt;&lt;span&gt;=&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;atoi&lt;&#x2F;span&gt;&lt;span&gt;(yytext); &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;return&lt;&#x2F;span&gt;&lt;span&gt; INT_LITERAL;}
&lt;&#x2F;span&gt;&lt;span&gt;([-])?[&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;0&lt;&#x2F;span&gt;&lt;span&gt;-&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;9&lt;&#x2F;span&gt;&lt;span&gt;]+\.[&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;0&lt;&#x2F;span&gt;&lt;span&gt;-&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;9&lt;&#x2F;span&gt;&lt;span&gt;]*        {yylval.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;double_value&lt;&#x2F;span&gt;&lt;span&gt;=&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;atof&lt;&#x2F;span&gt;&lt;span&gt;(yytext); &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;return&lt;&#x2F;span&gt;&lt;span&gt; DOUBLE_LITERAL;}
&lt;&#x2F;span&gt;&lt;span&gt;[a-zA-Z][&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;0&lt;&#x2F;span&gt;&lt;span&gt;-9a-zA-Z_]*       {yylval.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;string_value&lt;&#x2F;span&gt;&lt;span&gt;=&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;strdup&lt;&#x2F;span&gt;&lt;span&gt;(yytext); &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;return&lt;&#x2F;span&gt;&lt;span&gt; IDENTIFY;}
&lt;&#x2F;span&gt;&lt;span&gt;&amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;==&lt;&#x2F;span&gt;&lt;span&gt;&amp;quot;                        {&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;return&lt;&#x2F;span&gt;&lt;span&gt; EQUAL;}
&lt;&#x2F;span&gt;&lt;span&gt;&amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;!=&lt;&#x2F;span&gt;&lt;span&gt;&amp;quot;                        {&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;return&lt;&#x2F;span&gt;&lt;span&gt; NONEQUAL;}
&lt;&#x2F;span&gt;&lt;span&gt;&amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;&amp;lt;&lt;&#x2F;span&gt;&lt;span&gt;&amp;quot;                         {&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;return &lt;&#x2F;span&gt;&lt;span&gt;*yytext;}
&lt;&#x2F;span&gt;&lt;span&gt;&amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;&amp;lt;=&lt;&#x2F;span&gt;&lt;span&gt;&amp;quot;                        {&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;return&lt;&#x2F;span&gt;&lt;span&gt; LESSEQ;}
&lt;&#x2F;span&gt;&lt;span&gt;&amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;&amp;gt;&lt;&#x2F;span&gt;&lt;span&gt;&amp;quot;                         {&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;return &lt;&#x2F;span&gt;&lt;span&gt;*yytext;}
&lt;&#x2F;span&gt;&lt;span&gt;&amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;&amp;gt;=&lt;&#x2F;span&gt;&lt;span&gt;&amp;quot;                        {&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;return&lt;&#x2F;span&gt;&lt;span&gt; GREATEREQ;}
&lt;&#x2F;span&gt;&lt;span&gt;&amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;+&lt;&#x2F;span&gt;&lt;span&gt;&amp;quot;                         {&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;return &lt;&#x2F;span&gt;&lt;span&gt;*yytext;}
&lt;&#x2F;span&gt;&lt;span&gt;&amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;-&lt;&#x2F;span&gt;&lt;span&gt;&amp;quot;                         {&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;return &lt;&#x2F;span&gt;&lt;span&gt;*yytext;}
&lt;&#x2F;span&gt;&lt;span&gt;&amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;*&lt;&#x2F;span&gt;&lt;span&gt;&amp;quot;                         {&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;return &lt;&#x2F;span&gt;&lt;span&gt;*yytext;}
&lt;&#x2F;span&gt;&lt;span&gt;&amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;&#x2F;&lt;&#x2F;span&gt;&lt;span&gt;&amp;quot;                         {&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;return &lt;&#x2F;span&gt;&lt;span&gt;*yytext;}
&lt;&#x2F;span&gt;&lt;span&gt;&amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;[&lt;&#x2F;span&gt;&lt;span&gt;&amp;quot;                         {&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;return &lt;&#x2F;span&gt;&lt;span&gt;*yytext;}
&lt;&#x2F;span&gt;&lt;span&gt;&amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;]&lt;&#x2F;span&gt;&lt;span&gt;&amp;quot;                         {&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;return &lt;&#x2F;span&gt;&lt;span&gt;*yytext;}
&lt;&#x2F;span&gt;&lt;span&gt;[ \t]                       {}
&lt;&#x2F;span&gt;&lt;span&gt;.                           {&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;return &lt;&#x2F;span&gt;&lt;span&gt;*yytext;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;h3 id=&quot;yu-fa-fen-xi&quot;&gt;语法分析&lt;&#x2F;h3&gt;
&lt;p&gt;在此给出 bison 的关键部分代码：&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;bison&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-bison &quot;&gt;&lt;code class=&quot;language-bison&quot; data-lang=&quot;bison&quot;&gt;&lt;span&gt;program:
&lt;&#x2F;span&gt;&lt;span&gt;    program statement           
&lt;&#x2F;span&gt;&lt;span&gt;    |                          
&lt;&#x2F;span&gt;&lt;span&gt;    ;
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;assign:
&lt;&#x2F;span&gt;&lt;span&gt;    &amp;#39;=&amp;#39; expression             
&lt;&#x2F;span&gt;&lt;span&gt;    ;
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;defineStatement:
&lt;&#x2F;span&gt;&lt;span&gt;    TYPE IDENTIFY &amp;#39;;&amp;#39;
&lt;&#x2F;span&gt;&lt;span&gt;    | TYPE IDENTIFY &amp;#39;[&amp;#39; INT_LITERAL &amp;#39;]&amp;#39; &amp;#39;;&amp;#39; 
&lt;&#x2F;span&gt;&lt;span&gt;    | TYPE IDENTIFY assign &amp;#39;;&amp;#39;
&lt;&#x2F;span&gt;&lt;span&gt;    ;
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;assignStatement:
&lt;&#x2F;span&gt;&lt;span&gt;    referenceExpression assign &amp;#39;;&amp;#39;
&lt;&#x2F;span&gt;&lt;span&gt;    ;
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;statementList:
&lt;&#x2F;span&gt;&lt;span&gt;    statementList statement                 
&lt;&#x2F;span&gt;&lt;span&gt;    |                                       
&lt;&#x2F;span&gt;&lt;span&gt;    ;
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;block:
&lt;&#x2F;span&gt;&lt;span&gt;    &amp;#39;{&amp;#39; statementList &amp;#39;&lt;&#x2F;span&gt;&lt;span style=&quot;background-color:#bf616a;color:#2b303b;&quot;&gt;}&lt;&#x2F;span&gt;&lt;span&gt;&amp;#39; 
&lt;&#x2F;span&gt;&lt;span&gt;    ;
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;ifStatement:
&lt;&#x2F;span&gt;&lt;span&gt;    IF expression block                   
&lt;&#x2F;span&gt;&lt;span&gt;    | IF expression block ELSE block        
&lt;&#x2F;span&gt;&lt;span&gt;    ;
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;whileStatement:
&lt;&#x2F;span&gt;&lt;span&gt;    WHILE expression block                  
&lt;&#x2F;span&gt;&lt;span&gt;;
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;printStatement:
&lt;&#x2F;span&gt;&lt;span&gt;    PRINT &amp;#39;(&amp;#39; expression &amp;#39;)&amp;#39; &amp;#39;;&amp;#39;
&lt;&#x2F;span&gt;&lt;span&gt;;
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;statement:
&lt;&#x2F;span&gt;&lt;span&gt;    defineStatement
&lt;&#x2F;span&gt;&lt;span&gt;    | assignStatement
&lt;&#x2F;span&gt;&lt;span&gt;    | block
&lt;&#x2F;span&gt;&lt;span&gt;    | ifStatement
&lt;&#x2F;span&gt;&lt;span&gt;    | whileStatement
&lt;&#x2F;span&gt;&lt;span&gt;    | printStatement
&lt;&#x2F;span&gt;&lt;span&gt;;
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;referenceExpression:
&lt;&#x2F;span&gt;&lt;span&gt;    IDENTIFY 
&lt;&#x2F;span&gt;&lt;span&gt;    | IDENTIFY &amp;#39;[&amp;#39; expression &amp;#39;]&amp;#39; 
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;atomExpression:
&lt;&#x2F;span&gt;&lt;span&gt;    INT_LITERAL                            
&lt;&#x2F;span&gt;&lt;span&gt;    | DOUBLE_LITERAL                      
&lt;&#x2F;span&gt;&lt;span&gt;    | referenceExpression                  
&lt;&#x2F;span&gt;&lt;span&gt;    | &amp;#39;(&amp;#39; expression &amp;#39;)&amp;#39;                  
&lt;&#x2F;span&gt;&lt;span&gt;    ;
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;unaryOperator:
&lt;&#x2F;span&gt;&lt;span&gt;    &amp;#39;+&amp;#39;
&lt;&#x2F;span&gt;&lt;span&gt;    | &amp;#39;-&amp;#39;
&lt;&#x2F;span&gt;&lt;span&gt;    | &amp;#39;!&amp;#39;
&lt;&#x2F;span&gt;&lt;span&gt;    ;
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;unaryExpression:
&lt;&#x2F;span&gt;&lt;span&gt;    atomExpression                        
&lt;&#x2F;span&gt;&lt;span&gt;    | unaryOperator atomExpression         
&lt;&#x2F;span&gt;&lt;span&gt;;
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;binaryOrAtomExpression:
&lt;&#x2F;span&gt;&lt;span&gt;    unaryExpression                                    
&lt;&#x2F;span&gt;&lt;span&gt;    | binaryOrAtomExpression &amp;#39;+&amp;#39; unaryExpression       
&lt;&#x2F;span&gt;&lt;span&gt;    | binaryOrAtomExpression &amp;#39;-&amp;#39; unaryExpression   
&lt;&#x2F;span&gt;&lt;span&gt;    | binaryOrAtomExpression &amp;#39;*&amp;#39; unaryExpression        
&lt;&#x2F;span&gt;&lt;span&gt;    | binaryOrAtomExpression &amp;#39;&#x2F;&amp;#39; unaryExpression      
&lt;&#x2F;span&gt;&lt;span&gt;    | binaryOrAtomExpression &amp;#39;&amp;lt;&amp;#39; unaryExpression       
&lt;&#x2F;span&gt;&lt;span&gt;    | binaryOrAtomExpression &amp;#39;&amp;gt;&amp;#39; unaryExpression       
&lt;&#x2F;span&gt;&lt;span&gt;    | binaryOrAtomExpression LESSEQ     unaryExpression 
&lt;&#x2F;span&gt;&lt;span&gt;    | binaryOrAtomExpression GREATEREQ  unaryExpression
&lt;&#x2F;span&gt;&lt;span&gt;    | binaryOrAtomExpression EQUAL      unaryExpression 
&lt;&#x2F;span&gt;&lt;span&gt;    | binaryOrAtomExpression NONEQUAL   unaryExpression 
&lt;&#x2F;span&gt;&lt;span&gt;;
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;expression:
&lt;&#x2F;span&gt;&lt;span&gt;    binaryOrAtomExpression 
&lt;&#x2F;span&gt;&lt;span&gt;    ;
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;注意此处没有给出相应的行为代码，因为首先需要理解AST才能明白这些行为。&lt;&#x2F;p&gt;
&lt;h3 id=&quot;ast-chou-xiang-yu-fa-shu&quot;&gt;AST（抽象语法树）&lt;&#x2F;h3&gt;
&lt;p&gt;抽象语法树将语法分析得到的语法单元组织成树状。&lt;&#x2F;p&gt;
&lt;p&gt;基本上每个statement和expression都可以对应AST上的一个node。&lt;&#x2F;p&gt;
&lt;h4 id=&quot;ben-bian-yi-qi-de-astshe-ji&quot;&gt;本编译器的AST设计&lt;&#x2F;h4&gt;
&lt;p&gt;部分参考了llvm的AST设计。&lt;&#x2F;p&gt;
&lt;p&gt;&lt;img src=&quot;https:&#x2F;&#x2F;longfangsong.github.io&#x2F;build-a-compiler-in-the-easiest-way&#x2F;.&#x2F;AST.svg&quot; alt=&quot;ast&quot; &#x2F;&gt;&lt;&#x2F;p&gt;
&lt;p&gt;因此我们就能写出 &lt;code&gt;%union&lt;&#x2F;code&gt; 和 &lt;code&gt;%type&lt;&#x2F;code&gt;：&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;bison&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-bison &quot;&gt;&lt;code class=&quot;language-bison&quot; data-lang=&quot;bison&quot;&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;%union &lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;    int int_value;
&lt;&#x2F;span&gt;&lt;span&gt;    double double_value;
&lt;&#x2F;span&gt;&lt;span&gt;    char* string_value;
&lt;&#x2F;span&gt;&lt;span&gt;    ASTNode* node;
&lt;&#x2F;span&gt;&lt;span&gt;    SymbolType type;
&lt;&#x2F;span&gt;&lt;span&gt;};
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;%token &lt;&#x2F;span&gt;&lt;span&gt;&amp;lt;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;type&lt;&#x2F;span&gt;&lt;span&gt;&amp;gt; TYPE
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;%token &lt;&#x2F;span&gt;&lt;span&gt;&amp;lt;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;string_value&lt;&#x2F;span&gt;&lt;span&gt;&amp;gt; IDENTIFY
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;%token &lt;&#x2F;span&gt;&lt;span&gt;&amp;lt;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;int_value&lt;&#x2F;span&gt;&lt;span&gt;&amp;gt; INT_LITERAL
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;%token &lt;&#x2F;span&gt;&lt;span&gt;&amp;lt;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;double_value&lt;&#x2F;span&gt;&lt;span&gt;&amp;gt; DOUBLE_LITERAL
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;%token &lt;&#x2F;span&gt;&lt;span&gt;&amp;lt;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;type&lt;&#x2F;span&gt;&lt;span&gt;&amp;gt; STRING INT DOUBLE
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;%token &lt;&#x2F;span&gt;&lt;span&gt;&amp;lt;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;void&lt;&#x2F;span&gt;&lt;span&gt;&amp;gt; IF ELSE WHILE FOR
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;%token &lt;&#x2F;span&gt;&lt;span&gt;&amp;lt;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;void&lt;&#x2F;span&gt;&lt;span&gt;&amp;gt; LESSEQ GREATEREQ EQUAL NONEQUAL
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;%token &lt;&#x2F;span&gt;&lt;span&gt;&amp;lt;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;void&lt;&#x2F;span&gt;&lt;span&gt;&amp;gt; PRINT
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;%left &lt;&#x2F;span&gt;&lt;span&gt;&amp;#39;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;&amp;gt;&lt;&#x2F;span&gt;&lt;span&gt;&amp;#39; &amp;#39;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;&amp;lt;&lt;&#x2F;span&gt;&lt;span&gt;&amp;#39; LESSEQ GREATEREQ EQUAL NONEQUAL
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;%left &lt;&#x2F;span&gt;&lt;span&gt;&amp;#39;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;+&lt;&#x2F;span&gt;&lt;span&gt;&amp;#39; &amp;#39;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;-&lt;&#x2F;span&gt;&lt;span&gt;&amp;#39;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;%left &lt;&#x2F;span&gt;&lt;span&gt;&amp;#39;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;*&lt;&#x2F;span&gt;&lt;span&gt;&amp;#39; &amp;#39;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;&#x2F;&lt;&#x2F;span&gt;&lt;span&gt;&amp;#39;
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;%type &lt;&#x2F;span&gt;&lt;span&gt;&amp;lt;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;node&lt;&#x2F;span&gt;&lt;span&gt;&amp;gt; statement assignStatement statementList block ifStatement whileStatement defineStatement printStatement
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;%type &lt;&#x2F;span&gt;&lt;span&gt;&amp;lt;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;node&lt;&#x2F;span&gt;&lt;span&gt;&amp;gt; expression referenceExpression assign atomExpression unaryExpression binaryOrAtomExpression
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;%type &lt;&#x2F;span&gt;&lt;span&gt;&amp;lt;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;node&lt;&#x2F;span&gt;&lt;span&gt;&amp;gt; program
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;整个程序是一个 &lt;code&gt;CompoundStatement&lt;&#x2F;code&gt;，我们要把结果存在一个全局变量中：&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;c&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-c &quot;&gt;&lt;code class=&quot;language-c&quot; data-lang=&quot;c&quot;&gt;&lt;span&gt;CompoundStatement *result;
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;然后向 &lt;code&gt;bison&lt;&#x2F;code&gt; 代码中加入行为部分，以 &lt;code&gt;program&lt;&#x2F;code&gt; 和 &lt;code&gt;binaryOrAtomExpression&lt;&#x2F;code&gt; 为例：&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;bison&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-bison &quot;&gt;&lt;code class=&quot;language-bison&quot; data-lang=&quot;bison&quot;&gt;&lt;span&gt;program:
&lt;&#x2F;span&gt;&lt;span&gt;    program statement           {add_statement((CompoundStatement *)$1, (Statement*)$2);&lt;&#x2F;span&gt;&lt;span style=&quot;background-color:#bf616a;color:#2b303b;&quot;&gt;}&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;    |                           {result=create_compound_statement(); $$=(ASTNode*)result;&lt;&#x2F;span&gt;&lt;span style=&quot;background-color:#bf616a;color:#2b303b;&quot;&gt;}&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;    ;
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;binaryOrAtomExpression:
&lt;&#x2F;span&gt;&lt;span&gt;    unaryExpression                                     {$$=$1;&lt;&#x2F;span&gt;&lt;span style=&quot;background-color:#bf616a;color:#2b303b;&quot;&gt;}&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;    | binaryOrAtomExpression &amp;#39;+&amp;#39; unaryExpression        {$$=(ASTNode*)create_binary_operation_result(&amp;#39;+&amp;#39;,(RValue*)$1,(RValue*)$3);&lt;&#x2F;span&gt;&lt;span style=&quot;background-color:#bf616a;color:#2b303b;&quot;&gt;}&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;    | binaryOrAtomExpression &amp;#39;-&amp;#39; unaryExpression        {$$=(ASTNode*)create_binary_operation_result(&amp;#39;-&amp;#39;,(RValue*)$1,(RValue*)$3);&lt;&#x2F;span&gt;&lt;span style=&quot;background-color:#bf616a;color:#2b303b;&quot;&gt;}&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;    | binaryOrAtomExpression &amp;#39;*&amp;#39; unaryExpression        {$$=(ASTNode*)create_binary_operation_result(&amp;#39;*&amp;#39;,(RValue*)$1,(RValue*)$3);&lt;&#x2F;span&gt;&lt;span style=&quot;background-color:#bf616a;color:#2b303b;&quot;&gt;}&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;    | binaryOrAtomExpression &amp;#39;&#x2F;&amp;#39; unaryExpression        {$$=(ASTNode*)create_binary_operation_result(&amp;#39;&#x2F;&amp;#39;,(RValue*)$1,(RValue*)$3);&lt;&#x2F;span&gt;&lt;span style=&quot;background-color:#bf616a;color:#2b303b;&quot;&gt;}&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;    | binaryOrAtomExpression &amp;#39;&amp;lt;&amp;#39; unaryExpression        {$$=(ASTNode*)create_binary_operation_result(&amp;#39;&amp;lt;&amp;#39;,(RValue*)$1,(RValue*)$3);&lt;&#x2F;span&gt;&lt;span style=&quot;background-color:#bf616a;color:#2b303b;&quot;&gt;}&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;    | binaryOrAtomExpression &amp;#39;&amp;gt;&amp;#39; unaryExpression        {$$=(ASTNode*)create_binary_operation_result(&amp;#39;&amp;gt;&amp;#39;,(RValue*)$1,(RValue*)$3);&lt;&#x2F;span&gt;&lt;span style=&quot;background-color:#bf616a;color:#2b303b;&quot;&gt;}&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;    | binaryOrAtomExpression LESSEQ     unaryExpression {$$=(ASTNode*)create_binary_operation_result(LESSEQ, (RValue*)$1,(RValue*)$3);&lt;&#x2F;span&gt;&lt;span style=&quot;background-color:#bf616a;color:#2b303b;&quot;&gt;}&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;    | binaryOrAtomExpression GREATEREQ  unaryExpression {$$=(ASTNode*)create_binary_operation_result(GREATEREQ,(RValue*)$1,(RValue*)$3);&lt;&#x2F;span&gt;&lt;span style=&quot;background-color:#bf616a;color:#2b303b;&quot;&gt;}&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;    | binaryOrAtomExpression EQUAL      unaryExpression {$$=(ASTNode*)create_binary_operation_result(EQUAL, (RValue*)$1,(RValue*)$3);&lt;&#x2F;span&gt;&lt;span style=&quot;background-color:#bf616a;color:#2b303b;&quot;&gt;}&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;    | binaryOrAtomExpression NONEQUAL   unaryExpression {$$=(ASTNode*)create_binary_operation_result(NONEQUAL, (RValue*)$1,(RValue*)$3);&lt;&#x2F;span&gt;&lt;span style=&quot;background-color:#bf616a;color:#2b303b;&quot;&gt;}&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;h3 id=&quot;fu-hao-biao-yu-zuo-yong-yu&quot;&gt;符号表与作用域&lt;&#x2F;h3&gt;
&lt;p&gt;这个编译器由于不涉及多文件，也没有复杂类型，符号表的设计较为简单，维护一个全局符号表栈即可：&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;c&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-c &quot;&gt;&lt;code class=&quot;language-c&quot; data-lang=&quot;c&quot;&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;typedef enum &lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;    Bool,
&lt;&#x2F;span&gt;&lt;span&gt;    Int,
&lt;&#x2F;span&gt;&lt;span&gt;    String,
&lt;&#x2F;span&gt;&lt;span&gt;    Double,
&lt;&#x2F;span&gt;&lt;span&gt;    Array
&lt;&#x2F;span&gt;&lt;span&gt;} SymbolType;
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;typedef struct &lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;    SymbolType type;
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;bool&lt;&#x2F;span&gt;&lt;span&gt; mutable;
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;char &lt;&#x2F;span&gt;&lt;span&gt;*name;
&lt;&#x2F;span&gt;&lt;span&gt;    size_t namespace_id;
&lt;&#x2F;span&gt;&lt;span&gt;} Symbol;
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;typedef struct &lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;    Symbol base;
&lt;&#x2F;span&gt;&lt;span&gt;    SymbolType elementType;
&lt;&#x2F;span&gt;&lt;span&gt;    size_t length;
&lt;&#x2F;span&gt;&lt;span&gt;} ArraySymbol;
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;typedef struct &lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;    size_t length;
&lt;&#x2F;span&gt;&lt;span&gt;    Symbol **symbols;
&lt;&#x2F;span&gt;&lt;span&gt;    size_t namespace_id;
&lt;&#x2F;span&gt;&lt;span&gt;} SymbolTableFrame;
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;typedef struct &lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;    size_t length;
&lt;&#x2F;span&gt;&lt;span&gt;    SymbolTableFrame **frames;
&lt;&#x2F;span&gt;&lt;span&gt;} SymbolTableStack;
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;SymbolTableStack symbol_table_stack = {&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;0&lt;&#x2F;span&gt;&lt;span&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;NULL&lt;&#x2F;span&gt;&lt;span&gt;};
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;void &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;push_frame&lt;&#x2F;span&gt;&lt;span&gt;();
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;void &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;pop_frame&lt;&#x2F;span&gt;&lt;span&gt;();
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;void &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;add_symbol&lt;&#x2F;span&gt;&lt;span&gt;(Symbol *&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;symbol&lt;&#x2F;span&gt;&lt;span&gt;);
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;Symbol *&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;get_symbol&lt;&#x2F;span&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;char &lt;&#x2F;span&gt;&lt;span&gt;*&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;name&lt;&#x2F;span&gt;&lt;span&gt;);
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;其中 &lt;code&gt;get_symbol&lt;&#x2F;code&gt; 从栈顶向栈底寻找名字为 &lt;code&gt;name&lt;&#x2F;code&gt; 的符号。&lt;&#x2F;p&gt;
&lt;p&gt;在 &lt;code&gt;add_symbol&lt;&#x2F;code&gt; 时，会设置 &lt;code&gt;symbol&lt;&#x2F;code&gt; 的 &lt;code&gt;namespace_id&lt;&#x2F;code&gt; 为 &lt;code&gt;frame&lt;&#x2F;code&gt; 的 &lt;code&gt;namespace_id&lt;&#x2F;code&gt;，这在代码生成时会作为变量名称的一部分出现。&lt;&#x2F;p&gt;
&lt;p&gt;在语法分析时：&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;bison&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-bison &quot;&gt;&lt;code class=&quot;language-bison&quot; data-lang=&quot;bison&quot;&gt;&lt;span&gt;block:
&lt;&#x2F;span&gt;&lt;span&gt;    &amp;#39;{&amp;#39; {push_frame();&lt;&#x2F;span&gt;&lt;span style=&quot;background-color:#bf616a;color:#2b303b;&quot;&gt;}&lt;&#x2F;span&gt;&lt;span&gt; statementList &amp;#39;&lt;&#x2F;span&gt;&lt;span style=&quot;background-color:#bf616a;color:#2b303b;&quot;&gt;}&lt;&#x2F;span&gt;&lt;span&gt;&amp;#39;   {$$=$3;pop_frame();&lt;&#x2F;span&gt;&lt;span style=&quot;background-color:#bf616a;color:#2b303b;&quot;&gt;}&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;    ;
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;每遇到一个 &lt;code&gt;block&lt;&#x2F;code&gt;，就 &lt;code&gt;push&lt;&#x2F;code&gt; 一个 &lt;code&gt;frame&lt;&#x2F;code&gt;，离开 &lt;code&gt;block&lt;&#x2F;code&gt; 时 &lt;code&gt;pop&lt;&#x2F;code&gt; 即可，这样这个 &lt;code&gt;block&lt;&#x2F;code&gt; 内声明的 &lt;code&gt;symbol&lt;&#x2F;code&gt; 就会获得一个和这个 &lt;code&gt;block&lt;&#x2F;code&gt; 对应的 &lt;code&gt;namespace_id&lt;&#x2F;code&gt;。&lt;&#x2F;p&gt;
&lt;p&gt;在使用 &lt;code&gt;symbol&lt;&#x2F;code&gt; 时，由于刚刚进入的 &lt;code&gt;block&lt;&#x2F;code&gt; 对应的 &lt;code&gt;frame&lt;&#x2F;code&gt; 在栈顶附近，故会优先在这个 &lt;code&gt;frame&lt;&#x2F;code&gt; 中寻找名字为 &lt;code&gt;name&lt;&#x2F;code&gt;的符号，在这个 &lt;code&gt;frame&lt;&#x2F;code&gt; 中找不到时才会逐级向上寻找，这样就实现了作用域。&lt;&#x2F;p&gt;
&lt;h3 id=&quot;mu-biao-dai-ma-sheng-cheng&quot;&gt;目标代码生成&lt;&#x2F;h3&gt;
&lt;p&gt;为了方便代码跨平台和借用 llvm 的优秀的代码优化能力&lt;sup class=&quot;footnote-reference&quot;&gt;&lt;a href=&quot;#3&quot;&gt;3&lt;&#x2F;a&gt;&lt;&#x2F;sup&gt;，我们的目标代码是 LLVM IR。&lt;&#x2F;p&gt;
&lt;p&gt;LLVM IR兼有高级语言和汇编的特点，比如：&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;LLVM IR 是强类型的&lt;&#x2F;li&gt;
&lt;li&gt;LLVM IR 中的许多控制结构类似汇编，如 if、while 等控制结构都通过 br 跳转来表示&lt;&#x2F;li&gt;
&lt;li&gt;LLVM IR 中的”局部变量”相当程度上是一个”寄存器”，但 LLVM IR 逻辑上有无限多的这种”寄存器”，需要注意的是 LLVM IR是一种 SSA 形式的 IR，所以一个”寄存器”只能赋值一次。&lt;&#x2F;li&gt;
&lt;li&gt;LLVM 的很多操作都类似汇编的格式，如：&lt;code&gt;%a = add i32 1, %b&lt;&#x2F;code&gt; 类似 &lt;code&gt;add %a, 1, %b&lt;&#x2F;code&gt;&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;在此讲一些我们用到的 LLVM IR：&lt;&#x2F;p&gt;
&lt;h4 id=&quot;bian-liang-ding-yi&quot;&gt;变量定义&lt;&#x2F;h4&gt;
&lt;p&gt;用 &lt;code&gt;alloca&lt;&#x2F;code&gt; 在栈上开辟一块空间：&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;llvm&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-llvm &quot;&gt;&lt;code class=&quot;language-llvm&quot; data-lang=&quot;llvm&quot;&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;%i_0&lt;&#x2F;span&gt;&lt;span&gt; = &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;alloca i32
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;注意 &lt;code&gt;alloca&lt;&#x2F;code&gt; 返回的是一个指针。&lt;&#x2F;p&gt;
&lt;h4 id=&quot;bian-liang-de-fu-zhi&quot;&gt;变量的赋值&lt;&#x2F;h4&gt;
&lt;p&gt;使用 &lt;code&gt;store&lt;&#x2F;code&gt;：&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;llvm&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-llvm &quot;&gt;&lt;code class=&quot;language-llvm&quot; data-lang=&quot;llvm&quot;&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;store i32 &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;0&lt;&#x2F;span&gt;&lt;span&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;i32* &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;%i_0
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;即将 &lt;code&gt;0&lt;&#x2F;code&gt; 放入 &lt;code&gt;%i_0&lt;&#x2F;code&gt; 所指的变量中。&lt;&#x2F;p&gt;
&lt;h4 id=&quot;du-qu-bian-liang-de-zhi&quot;&gt;读取变量的值&lt;&#x2F;h4&gt;
&lt;p&gt;用 &lt;code&gt;load&lt;&#x2F;code&gt;：&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;llvm&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-llvm &quot;&gt;&lt;code class=&quot;language-llvm&quot; data-lang=&quot;llvm&quot;&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;%temp&lt;&#x2F;span&gt;&lt;span&gt; = &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;load i32&lt;&#x2F;span&gt;&lt;span&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;i32* &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;%i_0
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;即将 &lt;code&gt;%i_0&lt;&#x2F;code&gt; 所指的变量中的值放入 &lt;code&gt;%temp&lt;&#x2F;code&gt; 寄存器中。&lt;&#x2F;p&gt;
&lt;h4 id=&quot;yun-suan&quot;&gt;运算&lt;&#x2F;h4&gt;
&lt;p&gt;以加法为例：&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;llvm&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-llvm &quot;&gt;&lt;code class=&quot;language-llvm&quot; data-lang=&quot;llvm&quot;&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;%temp_22&lt;&#x2F;span&gt;&lt;span&gt; = &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;add i32 &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;%temp_21&lt;&#x2F;span&gt;&lt;span&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;1
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;即将 &lt;code&gt;%temp_21 + 1&lt;&#x2F;code&gt; 的值放入 &lt;code&gt;%temp_22&lt;&#x2F;code&gt; 中。&lt;&#x2F;p&gt;
&lt;p&gt;对于浮点数，用 &lt;code&gt;fadd&lt;&#x2F;code&gt; 代替 &lt;code&gt;add&lt;&#x2F;code&gt;。&lt;&#x2F;p&gt;
&lt;h4 id=&quot;bi-jiao&quot;&gt;比较&lt;&#x2F;h4&gt;
&lt;p&gt;使用 &lt;code&gt;icmp&lt;&#x2F;code&gt; 与比较类型：&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;llvm&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-llvm &quot;&gt;&lt;code class=&quot;language-llvm&quot; data-lang=&quot;llvm&quot;&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;%temp_2&lt;&#x2F;span&gt;&lt;span&gt; = &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;icmp slt i32 &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;%temp_1&lt;&#x2F;span&gt;&lt;span&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;10
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;其中 &lt;code&gt;slt&lt;&#x2F;code&gt; 是“Signed Less Than”，即&lt;code&gt;&amp;lt;&lt;&#x2F;code&gt;。&lt;&#x2F;p&gt;
&lt;p&gt;浮点相应的有 &lt;code&gt;fcmp&lt;&#x2F;code&gt; 、&lt;code&gt;olt&lt;&#x2F;code&gt;等。&lt;&#x2F;p&gt;
&lt;h4 id=&quot;tiao-zhuan&quot;&gt;跳转&lt;&#x2F;h4&gt;
&lt;p&gt;使用 &lt;code&gt;br&lt;&#x2F;code&gt; 进行跳转：&lt;&#x2F;p&gt;
&lt;h5 id=&quot;wu-tiao-jian&quot;&gt;无条件&lt;&#x2F;h5&gt;
&lt;pre data-lang=&quot;llvm&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-llvm &quot;&gt;&lt;code class=&quot;language-llvm&quot; data-lang=&quot;llvm&quot;&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;br label &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;%label1
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;h5 id=&quot;you-tiao-jian&quot;&gt;有条件&lt;&#x2F;h5&gt;
&lt;pre data-lang=&quot;llvm&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-llvm &quot;&gt;&lt;code class=&quot;language-llvm&quot; data-lang=&quot;llvm&quot;&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;br i1 &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;%condition&lt;&#x2F;span&gt;&lt;span&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;label &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;%condition_true&lt;&#x2F;span&gt;&lt;span&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;label &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;%condition_false
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;有这些个东西就够了。&lt;&#x2F;p&gt;
&lt;p&gt;然后我们就可以进行代码生成了。&lt;&#x2F;p&gt;
&lt;p&gt;例如变量声明：&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;c&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-c &quot;&gt;&lt;code class=&quot;language-c&quot; data-lang=&quot;c&quot;&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;static void &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;generate_code&lt;&#x2F;span&gt;&lt;span&gt;(DeclareStatement *&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;node&lt;&#x2F;span&gt;&lt;span&gt;) {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;printf&lt;&#x2F;span&gt;&lt;span&gt;(&amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;%%%s&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;_&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;%zu&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt; = alloca &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;%s&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;\n&lt;&#x2F;span&gt;&lt;span&gt;&amp;quot;, node-&amp;gt;variable-&amp;gt;name, node-&amp;gt;variable-&amp;gt;namespace_id, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;type_name&lt;&#x2F;span&gt;&lt;span&gt;(node-&amp;gt;variable));
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;&#x2F;&#x2F; 带初始化，则再生成一个赋值语句
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;if &lt;&#x2F;span&gt;&lt;span&gt;(node-&amp;gt;initial != &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;NULL&lt;&#x2F;span&gt;&lt;span&gt;) {
&lt;&#x2F;span&gt;&lt;span&gt;        ((Statement *) (node-&amp;gt;initial))-&amp;gt;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;generate_code&lt;&#x2F;span&gt;&lt;span&gt;((Statement *) (node-&amp;gt;initial));
&lt;&#x2F;span&gt;&lt;span&gt;    }
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;赋值：&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;c&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-c &quot;&gt;&lt;code class=&quot;language-c&quot; data-lang=&quot;c&quot;&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;static void &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;generate_code&lt;&#x2F;span&gt;&lt;span&gt;(AssignStatement *&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;node&lt;&#x2F;span&gt;&lt;span&gt;) {
&lt;&#x2F;span&gt;&lt;span&gt;    ((LValue *) (node-&amp;gt;lhs))-&amp;gt;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;generate_lvalue_code&lt;&#x2F;span&gt;&lt;span&gt;((LValue *) (node-&amp;gt;lhs));
&lt;&#x2F;span&gt;&lt;span&gt;    node-&amp;gt;rhs-&amp;gt;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;generate_rvalue_code&lt;&#x2F;span&gt;&lt;span&gt;(node-&amp;gt;rhs);
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;char &lt;&#x2F;span&gt;&lt;span&gt;*rvalue_ir = node-&amp;gt;rhs-&amp;gt;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;rvalue_ir&lt;&#x2F;span&gt;&lt;span&gt;(node-&amp;gt;rhs);
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;char &lt;&#x2F;span&gt;&lt;span&gt;*lvalue_ir = node-&amp;gt;lhs-&amp;gt;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;lvalue_ir&lt;&#x2F;span&gt;&lt;span&gt;(node-&amp;gt;lhs);
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;printf&lt;&#x2F;span&gt;&lt;span&gt;(&amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;store &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;%s %s&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;%s&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;* &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;%s&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;\n&lt;&#x2F;span&gt;&lt;span&gt;&amp;quot;,
&lt;&#x2F;span&gt;&lt;span&gt;           &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;type_string&lt;&#x2F;span&gt;&lt;span&gt;(((RValue *) (node-&amp;gt;lhs))-&amp;gt;type),
&lt;&#x2F;span&gt;&lt;span&gt;           rvalue_ir,
&lt;&#x2F;span&gt;&lt;span&gt;           &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;type_string&lt;&#x2F;span&gt;&lt;span&gt;(((RValue *) (node-&amp;gt;lhs))-&amp;gt;type),
&lt;&#x2F;span&gt;&lt;span&gt;           lvalue_ir);
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;free&lt;&#x2F;span&gt;&lt;span&gt;(rvalue_ir);
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;free&lt;&#x2F;span&gt;&lt;span&gt;(lvalue_ir);
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;对expression来说，左值右值要分开，以普通变量为例：&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;c&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-c &quot;&gt;&lt;code class=&quot;language-c&quot; data-lang=&quot;c&quot;&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;&#x2F;&#x2F; 右值需从变量读取到寄存器才能使用
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;static void &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;generate_rvalue_code&lt;&#x2F;span&gt;&lt;span&gt;(VariableReference *&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;rValue&lt;&#x2F;span&gt;&lt;span&gt;) {
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;char &lt;&#x2F;span&gt;&lt;span&gt;*rvalue_ir_string = ((RValue *) rValue)-&amp;gt;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;rvalue_ir&lt;&#x2F;span&gt;&lt;span&gt;((RValue*) rValue);
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;char &lt;&#x2F;span&gt;&lt;span&gt;*lvalue_ir_string = ((LValue*) rValue)-&amp;gt;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;lvalue_ir&lt;&#x2F;span&gt;&lt;span&gt;((LValue *) rValue);
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;printf&lt;&#x2F;span&gt;&lt;span&gt;(&amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;%s&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt; = load &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;%s&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;%s&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;* &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;%s&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;\n&lt;&#x2F;span&gt;&lt;span&gt;&amp;quot;,
&lt;&#x2F;span&gt;&lt;span&gt;           rvalue_ir_string,
&lt;&#x2F;span&gt;&lt;span&gt;           &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;type_name&lt;&#x2F;span&gt;&lt;span&gt;(rValue-&amp;gt;variable),
&lt;&#x2F;span&gt;&lt;span&gt;           &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;type_name&lt;&#x2F;span&gt;&lt;span&gt;(rValue-&amp;gt;variable),
&lt;&#x2F;span&gt;&lt;span&gt;           lvalue_ir_string);
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;free&lt;&#x2F;span&gt;&lt;span&gt;(rvalue_ir_string);
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;free&lt;&#x2F;span&gt;&lt;span&gt;(lvalue_ir_string);
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;&#x2F;&#x2F; 左值无需读取出来
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;static void &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;generate_lvalue_code&lt;&#x2F;span&gt;&lt;span&gt;(VariableReference *&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;lValue&lt;&#x2F;span&gt;&lt;span&gt;) {
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;&#x2F;&#x2F; 做左值时ir中的变量名
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;static char &lt;&#x2F;span&gt;&lt;span&gt;*&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;lvalue_ir&lt;&#x2F;span&gt;&lt;span&gt;(VariableReference *&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;lValue&lt;&#x2F;span&gt;&lt;span&gt;) {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;char &lt;&#x2F;span&gt;&lt;span&gt;*result = &lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;malloc&lt;&#x2F;span&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;128&lt;&#x2F;span&gt;&lt;span&gt;);
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;sprintf&lt;&#x2F;span&gt;&lt;span&gt;(result, &amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;%%%s&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;_&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;%zu&lt;&#x2F;span&gt;&lt;span&gt;&amp;quot;, lValue-&amp;gt;variable-&amp;gt;name, lValue-&amp;gt;variable-&amp;gt;namespace_id);
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;return&lt;&#x2F;span&gt;&lt;span&gt; result;
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;&#x2F;&#x2F; 做右值时ir中的变量名
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;static char &lt;&#x2F;span&gt;&lt;span&gt;*&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;rvalue_ir&lt;&#x2F;span&gt;&lt;span&gt;(VariableReference *&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;rValue&lt;&#x2F;span&gt;&lt;span&gt;) {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;char &lt;&#x2F;span&gt;&lt;span&gt;*result = &lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;malloc&lt;&#x2F;span&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;128&lt;&#x2F;span&gt;&lt;span&gt;);
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;sprintf&lt;&#x2F;span&gt;&lt;span&gt;(result, &amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;%%&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;temp_&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;%zu&lt;&#x2F;span&gt;&lt;span&gt;&amp;quot;, rValue-&amp;gt;temp_register_id);
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;return&lt;&#x2F;span&gt;&lt;span&gt; result;
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;其他代码如何生成可以由读者自己想出来，对我的实现感兴趣的话请自行&lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;longfangsong&#x2F;toylang&#x2F;tree&#x2F;deprecated&quot;&gt;阅读代码&lt;&#x2F;a&gt;。&lt;&#x2F;p&gt;
&lt;h2 id=&quot;can-kao-zi-liao&quot;&gt;参考资料&lt;&#x2F;h2&gt;
&lt;h3 id=&quot;bian-yi-yuan-li&quot;&gt;编译原理&lt;&#x2F;h3&gt;
&lt;p&gt;龙虎鲸三连：&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;《编译原理》——“龙书”&lt;&#x2F;li&gt;
&lt;li&gt;《现代编译原理：Ｃ语言描述》——“虎书”&lt;&#x2F;li&gt;
&lt;li&gt;《高级编译器设计与实现》——“鲸书”&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;h3 id=&quot;can-kao-ci-fa-wen-fa&quot;&gt;参考词法 &amp;amp; 文法&lt;&#x2F;h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http:&#x2F;&#x2F;www.lysator.liu.se&#x2F;c&#x2F;ANSI-C-grammar-l.html&quot;&gt;C语言的词法&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a href=&quot;http:&#x2F;&#x2F;www.lysator.liu.se&#x2F;c&#x2F;ANSI-C-grammar-y.html&quot;&gt;C语言的文法&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;h3 id=&quot;llvm-ir&quot;&gt;LLVM IR&lt;&#x2F;h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;llvm.org&#x2F;&quot;&gt;llvm 官方网站&lt;&#x2F;a&gt;，尤其是其&lt;a href=&quot;https:&#x2F;&#x2F;llvm.org&#x2F;docs&#x2F;LangRef.html&quot;&gt;语言参考&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;mapping-high-level-constructs-to-llvm-ir.readthedocs.io&#x2F;&quot;&gt;mapping high level constructs to llvm ir&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;div class=&quot;footnote-definition&quot; id=&quot;1&quot;&gt;&lt;sup class=&quot;footnote-definition-label&quot;&gt;1&lt;&#x2F;sup&gt;
&lt;p&gt;代码中将会使用C语言的面向对象编程，见用&lt;a href=&quot;https:&#x2F;&#x2F;longfangsong.github.io&#x2F;build-a-compiler-in-the-easiest-way&#x2F;.&quot;&gt;纯C实现面向对象编程&lt;&#x2F;a&gt;。这东西用多了就有一种C语言远比C++好用的感觉（Linus一点都没说错）。&lt;&#x2F;p&gt;
&lt;&#x2F;div&gt;
&lt;div class=&quot;footnote-definition&quot; id=&quot;2&quot;&gt;&lt;sup class=&quot;footnote-definition-label&quot;&gt;2&lt;&#x2F;sup&gt;
&lt;p&gt;其实在构造AST里我偷偷摸摸做了一丁点语义分析。&lt;&#x2F;p&gt;
&lt;&#x2F;div&gt;
&lt;div class=&quot;footnote-definition&quot; id=&quot;3&quot;&gt;&lt;sup class=&quot;footnote-definition-label&quot;&gt;3&lt;&#x2F;sup&gt;
&lt;p&gt;其实是因为我懒。&lt;&#x2F;p&gt;
&lt;&#x2F;div&gt;
</content>
        
    </entry>
    <entry xml:lang="zh">
        <title>代数结构 cheatsheet</title>
        <published>2019-04-09T00:00:00+00:00</published>
        <updated>2019-04-09T00:00:00+00:00</updated>
        <author>
          <name>Unknown</name>
        </author>
        <link rel="alternate" href="https://longfangsong.github.io/algebraic-structures/" type="text/html"/>
        <id>https://longfangsong.github.io/algebraic-structures/</id>
        
        <content type="html">&lt;h2 id=&quot;yun-suan&quot;&gt;运算&lt;&#x2F;h2&gt;
&lt;h3 id=&quot;er-yuan-yun-suan&quot;&gt;二元运算&lt;&#x2F;h3&gt;
&lt;blockquote&gt;
&lt;p&gt;给定集合$A$，二元函数$F: A \times A \rightarrow A$称为集合A上的&lt;strong&gt;二元运算&lt;&#x2F;strong&gt;。&lt;&#x2F;p&gt;
&lt;&#x2F;blockquote&gt;
&lt;p&gt;本文中的二元运算使用 $\circ$ 、$\diamond$ &lt;sup class=&quot;footnote-reference&quot;&gt;&lt;a href=&quot;#1&quot;&gt;1&lt;&#x2F;a&gt;&lt;&#x2F;sup&gt;表示，同时，集合$A$中的元素用 $a$ ，$b$ ，$c$ 等表示。&lt;&#x2F;p&gt;
&lt;h3 id=&quot;可能使集合具有的特殊元素&quot;&gt;&lt;a class=&quot;headerlink&quot; href=&quot;#可能使集合具有的特殊元素&quot; title=&quot;可能使集合具有的特殊元素&quot;&gt;&lt;&#x2F;a&gt;可能使集合具有的特殊元素&lt;&#x2F;h3&gt;&lt;h4 id=&quot;幺元-单位元-（identity-element-neutral-element）&quot;&gt;&lt;a class=&quot;headerlink&quot; href=&quot;#幺元-单位元-（identity-element-neutral-element）&quot; title=&quot;幺元&#x2F;单位元 （identity element&#x2F;neutral element）&quot;&gt;&lt;&#x2F;a&gt;幺元&#x2F;单位元 （identity element&#x2F;neutral element）&lt;&#x2F;h4&gt;&lt;p&gt;若对 $A$ 中每个元素 $a$&lt;&#x2F;p&gt;
&lt;script type=&quot;math&#x2F;tex; mode=display&quot;&gt;
i\ \circ\ a = a&lt;&#x2F;script&gt;&lt;p&gt;则 $i$ 是 $\circ$ 在 $A​$ 上的左幺元。&lt;&#x2F;p&gt;
&lt;p&gt;若对 $A$ 中每个元素 $a$&lt;&#x2F;p&gt;
&lt;script type=&quot;math&#x2F;tex; mode=display&quot;&gt;
a\ \circ\ i = a&lt;&#x2F;script&gt;&lt;p&gt;则 $i$ 是 $\circ$ 在 $A​$ 上的右幺元。&lt;&#x2F;p&gt;
&lt;p&gt;幺元 = 左幺元 &amp;amp; 右幺元。&lt;&#x2F;p&gt;
&lt;h4 id=&quot;逆元-（inverse-element）&quot;&gt;&lt;a class=&quot;headerlink&quot; href=&quot;#逆元-（inverse-element）&quot; title=&quot;逆元 （inverse element）&quot;&gt;&lt;&#x2F;a&gt;逆元 （inverse element）&lt;&#x2F;h4&gt;&lt;p&gt;在已经存在幺元 $i​$ 时，&lt;&#x2F;p&gt;
&lt;p&gt;若&lt;&#x2F;p&gt;
&lt;script type=&quot;math&#x2F;tex; mode=display&quot;&gt;
a\ \circ\ b = i&lt;&#x2F;script&gt;&lt;p&gt;则 $a$ 是 $b$ 在 $\circ$ 上的左逆元，同时 $b$ 也是 $a$ 在 $\circ$ 下的右逆元。&lt;&#x2F;p&gt;
&lt;p&gt;逆元 = 左逆元 &amp;amp; 右逆元&lt;&#x2F;p&gt;
&lt;h4 id=&quot;零元（zero-element）&quot;&gt;&lt;a class=&quot;headerlink&quot; href=&quot;#零元（zero-element）&quot; title=&quot;零元（zero element）&quot;&gt;&lt;&#x2F;a&gt;零元（zero element）&lt;&#x2F;h4&gt;&lt;p&gt;若对 $A​$ 中每个元素 $a​$&lt;&#x2F;p&gt;
&lt;script type=&quot;math&#x2F;tex; mode=display&quot;&gt;
z\ \circ\ a = z&lt;&#x2F;script&gt;&lt;p&gt;则 $z$ 是 $\circ$ 在 $A$ 上的左零元。&lt;&#x2F;p&gt;
&lt;p&gt;若对 $A​$ 中每个元素 $a​$&lt;&#x2F;p&gt;
&lt;script type=&quot;math&#x2F;tex; mode=display&quot;&gt;
a\ \circ\ z = z&lt;&#x2F;script&gt;&lt;p&gt;则 $z​$ 是 $\circ​$ 在 $A​$ 上的右零元。&lt;&#x2F;p&gt;
&lt;p&gt;零元 = 左零元 &amp;amp; 右零元&lt;&#x2F;p&gt;
&lt;h4 id=&quot;零因子（Zero-divisor）&quot;&gt;&lt;a class=&quot;headerlink&quot; href=&quot;#零因子（Zero-divisor）&quot; title=&quot;零因子（Zero divisor）&quot;&gt;&lt;&#x2F;a&gt;零因子（Zero divisor）&lt;&#x2F;h4&gt;&lt;p&gt;在已经存在零元 $z$ 时：&lt;&#x2F;p&gt;
&lt;p&gt;若对 $A​$ 中存在不是零元的元素 $b​$&lt;&#x2F;p&gt;
&lt;script type=&quot;math&#x2F;tex; mode=display&quot;&gt;
a\ \circ\ b = z&lt;&#x2F;script&gt;&lt;p&gt;则 $a$ 是 $\circ$ 在 $A$ 上的左零因子。&lt;&#x2F;p&gt;
&lt;p&gt;若对 $A$ 中存在不是零元的元素 $b$&lt;&#x2F;p&gt;
&lt;script type=&quot;math&#x2F;tex; mode=display&quot;&gt;
b\ \circ\ a = z&lt;&#x2F;script&gt;&lt;p&gt;则 $a$ 是 $\circ$ 在 $A$ 上的右零因子。&lt;&#x2F;p&gt;
&lt;p&gt;零因子 = 左零因子 &amp;amp; 右零因子（也有说法是 零因子 = 左零因子 | 右零因子）&lt;&#x2F;p&gt;
&lt;h3 id=&quot;可能具有的性质&quot;&gt;&lt;a class=&quot;headerlink&quot; href=&quot;#可能具有的性质&quot; title=&quot;可能具有的性质&quot;&gt;&lt;&#x2F;a&gt;可能具有的性质&lt;&#x2F;h3&gt;&lt;h4 id=&quot;交换律&quot;&gt;&lt;a class=&quot;headerlink&quot; href=&quot;#交换律&quot; title=&quot;交换律&quot;&gt;&lt;&#x2F;a&gt;交换律&lt;&#x2F;h4&gt;&lt;p&gt;若对 $A$ 中任意元素 $a$ 、$b​$&lt;&#x2F;p&gt;
&lt;p&gt;$a\ \circ\ b = b\ \circ\ a​$&lt;&#x2F;p&gt;
&lt;h4 id=&quot;结合律&quot;&gt;&lt;a class=&quot;headerlink&quot; href=&quot;#结合律&quot; title=&quot;结合律&quot;&gt;&lt;&#x2F;a&gt;结合律&lt;&#x2F;h4&gt;&lt;p&gt;若对 $A$ 中任意元素 $a$ 、$b$&lt;&#x2F;p&gt;
&lt;p&gt;$(a\ \circ\ b)\ \circ\ c =a\ \circ\ (b\ \circ\ c) $&lt;&#x2F;p&gt;
&lt;h4 id=&quot;分配率&quot;&gt;&lt;a class=&quot;headerlink&quot; href=&quot;#分配率&quot; title=&quot;分配率&quot;&gt;&lt;&#x2F;a&gt;分配率&lt;&#x2F;h4&gt;&lt;p&gt;若对 $A$ 中任意元素 $a$ 、$b$、$c$&lt;&#x2F;p&gt;
&lt;p&gt;若&lt;&#x2F;p&gt;
&lt;script type=&quot;math&#x2F;tex; mode=display&quot;&gt;
a\ \circ\ (b\ \diamond\ c) = a\ \circ\ b\ \diamond\ a\ \circ\ b&lt;&#x2F;script&gt;&lt;p&gt;称 $\circ$ 对 $\diamond$ 具有左分配率。&lt;&#x2F;p&gt;
&lt;p&gt;若&lt;&#x2F;p&gt;
&lt;script type=&quot;math&#x2F;tex; mode=display&quot;&gt;
(b\ \diamond\ c) \circ\ a = b\ \circ\ a\ \diamond\ c\ \circ\ a&lt;&#x2F;script&gt;&lt;p&gt;称 $\circ$ 对 $\diamond​$ 具有右分配率。&lt;&#x2F;p&gt;
&lt;p&gt;分配率 = 左分配率 &amp;amp; 右分配率&lt;&#x2F;p&gt;
&lt;h4 id=&quot;幂等率&quot;&gt;&lt;a class=&quot;headerlink&quot; href=&quot;#幂等率&quot; title=&quot;幂等率&quot;&gt;&lt;&#x2F;a&gt;幂等率&lt;&#x2F;h4&gt;&lt;p&gt;对 $A$ 中每个元素 $a$&lt;&#x2F;p&gt;
&lt;script type=&quot;math&#x2F;tex; mode=display&quot;&gt;
a\ \circ\ a = a&lt;&#x2F;script&gt;&lt;h4 id=&quot;幂幺率&quot;&gt;&lt;a class=&quot;headerlink&quot; href=&quot;#幂幺率&quot; title=&quot;幂幺率&quot;&gt;&lt;&#x2F;a&gt;幂幺率&lt;&#x2F;h4&gt;&lt;p&gt;对 $A$ 中每个元素 $a​$&lt;&#x2F;p&gt;
&lt;script type=&quot;math&#x2F;tex; mode=display&quot;&gt;
a\ \circ\ a = i&lt;&#x2F;script&gt;&lt;h4 id=&quot;&quot;&gt;&lt;a class=&quot;headerlink&quot; href=&quot;#&quot; title=&quot; &quot;&gt;&lt;&#x2F;a&gt; &lt;&#x2F;h4&gt;&lt;p&gt;其中 $i$ 为幺元。&lt;&#x2F;p&gt;
&lt;h4 id=&quot;幂零率&quot;&gt;&lt;a class=&quot;headerlink&quot; href=&quot;#幂零率&quot; title=&quot;幂零率&quot;&gt;&lt;&#x2F;a&gt;幂零率&lt;&#x2F;h4&gt;&lt;p&gt;对 $A$ 中每个元素 $a$&lt;&#x2F;p&gt;
&lt;script type=&quot;math&#x2F;tex; mode=display&quot;&gt;
a\ \circ\ a = z&lt;&#x2F;script&gt;&lt;h4 id=&quot;-1&quot;&gt;&lt;a class=&quot;headerlink&quot; href=&quot;#-1&quot; title=&quot; &quot;&gt;&lt;&#x2F;a&gt; &lt;&#x2F;h4&gt;&lt;p&gt;其中 $z$ 为零元。&lt;&#x2F;p&gt;
&lt;h4 id=&quot;吸收率&quot;&gt;&lt;a class=&quot;headerlink&quot; href=&quot;#吸收率&quot; title=&quot;吸收率&quot;&gt;&lt;&#x2F;a&gt;吸收率&lt;&#x2F;h4&gt;&lt;p&gt;对 $A$ 中每个 $a$ 、$b​$&lt;&#x2F;p&gt;
&lt;script type=&quot;math&#x2F;tex; mode=display&quot;&gt;
a\ \circ\ (a\ \diamond\ b) = a\ \diamond\ (a\ \circ\ b) = a&lt;&#x2F;script&gt;&lt;p&gt;则这两个运算服从吸收率，两种运算被称为对偶对。&lt;&#x2F;p&gt;
&lt;h2 id=&quot;序&quot;&gt;&lt;a class=&quot;headerlink&quot; href=&quot;#序&quot; title=&quot;序&quot;&gt;&lt;&#x2F;a&gt;序&lt;&#x2F;h2&gt;&lt;h3 id=&quot;偏序关系&quot;&gt;&lt;a class=&quot;headerlink&quot; href=&quot;#偏序关系&quot; title=&quot;偏序关系&quot;&gt;&lt;&#x2F;a&gt;偏序关系&lt;&#x2F;h3&gt;&lt;p&gt;待补充……&lt;&#x2F;p&gt;
&lt;h3 id=&quot;全序关系&quot;&gt;&lt;a class=&quot;headerlink&quot; href=&quot;#全序关系&quot; title=&quot;全序关系&quot;&gt;&lt;&#x2F;a&gt;全序关系&lt;&#x2F;h3&gt;&lt;p&gt;待补充……&lt;&#x2F;p&gt;
&lt;h3 id=&quot;上-下界&quot;&gt;&lt;a class=&quot;headerlink&quot; href=&quot;#上-下界&quot; title=&quot;上&#x2F;下界&quot;&gt;&lt;&#x2F;a&gt;上&#x2F;下界&lt;&#x2F;h3&gt;&lt;p&gt;待补充……&lt;&#x2F;p&gt;
&lt;h3 id=&quot;上-下确界（全上-下界）&quot;&gt;&lt;a class=&quot;headerlink&quot; href=&quot;#上-下确界（全上-下界）&quot; title=&quot;上&#x2F;下确界（全上&#x2F;下界）&quot;&gt;&lt;&#x2F;a&gt;上&#x2F;下确界（全上&#x2F;下界）&lt;&#x2F;h3&gt;&lt;p&gt;待补充……&lt;&#x2F;p&gt;
&lt;h2 id=&quot;代数结构&quot;&gt;&lt;a class=&quot;headerlink&quot; href=&quot;#代数结构&quot; title=&quot;代数结构&quot;&gt;&lt;&#x2F;a&gt;代数结构&lt;&#x2F;h2&gt;&lt;p&gt;来自维基百科（许多东西没有中文译名……）：&lt;&#x2F;p&gt;
&lt;p&gt;&lt;img alt=&quot;img1&quot; src=&quot;.&#x2F;img1.png&quot;&#x2F;&gt;&lt;&#x2F;p&gt;
&lt;p&gt;&lt;img alt=&quot;Lattice_v4&quot; src=&quot;.&#x2F;Lattice_v4.png&quot;&#x2F;&gt;&lt;&#x2F;p&gt;
&lt;h3 id=&quot;原群（magma-groupoid）&quot;&gt;&lt;a class=&quot;headerlink&quot; href=&quot;#原群（magma-groupoid）&quot; title=&quot;原群（magma&#x2F;groupoid）&quot;&gt;&lt;&#x2F;a&gt;原群（magma&#x2F;groupoid）&lt;&#x2F;h3&gt;&lt;p&gt;有一个集合和一个集合上的二元运算就是原群了。&lt;&#x2F;p&gt;
&lt;h3 id=&quot;ni-qun-quasigroup&quot;&gt;拟群（quasigroup）&lt;&#x2F;h3&gt;
&lt;p&gt;对任意元素 $a$ 和 $b$，有唯一的 $x$ 和 $y$，使得&lt;&#x2F;p&gt;
&lt;p&gt;$$
\displaylines {
a\ \circ\ x = b \\
y\ \circ\ a = b
}
$$&lt;&#x2F;p&gt;
&lt;p&gt;我们可以从此定义出 $\circ$ 的逆运算：&lt;&#x2F;p&gt;
&lt;p&gt;$$
\displaylines {
x = a\ \grave{\circ}\ b\\
y = b\ \acute{\circ}\ a
}
$$&lt;&#x2F;p&gt;
&lt;p&gt;$\grave{\circ}$ 常写作 \ ，常被称为左除。&lt;&#x2F;p&gt;
&lt;p&gt;$\acute{\circ}$ 常写作 &#x2F;，被称为右除。&lt;&#x2F;p&gt;
&lt;h3 id=&quot;半群（semigroup）&quot;&gt;&lt;a class=&quot;headerlink&quot; href=&quot;#半群（semigroup）&quot; title=&quot;半群（semigroup）&quot;&gt;&lt;&#x2F;a&gt;半群（semigroup）&lt;&#x2F;h3&gt;&lt;p&gt;原群 加&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;运算&lt;ul&gt;
&lt;li&gt;结合律&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;h3 id=&quot;幺拟群（圈）（loop）&quot;&gt;&lt;a class=&quot;headerlink&quot; href=&quot;#幺拟群（圈）（loop）&quot; title=&quot;幺拟群（圈）（loop）&quot;&gt;&lt;&#x2F;a&gt;幺拟群（圈）（loop）&lt;&#x2F;h3&gt;&lt;p&gt;拟群 加上：&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;特殊元素&lt;ul&gt;
&lt;li&gt;幺元&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;h3 id=&quot;幺半群（独异点）（monoid）&quot;&gt;&lt;a class=&quot;headerlink&quot; href=&quot;#幺半群（独异点）（monoid）&quot; title=&quot;幺半群（独异点）（monoid）&quot;&gt;&lt;&#x2F;a&gt;幺半群（独异点）（monoid）&lt;&#x2F;h3&gt;&lt;p&gt;半群 加上：&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;特殊元素&lt;ul&gt;
&lt;li&gt;幺元&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;h3 id=&quot;可交换幺半群（阿贝尔幺半群）&quot;&gt;&lt;a class=&quot;headerlink&quot; href=&quot;#可交换幺半群（阿贝尔幺半群）&quot; title=&quot;可交换幺半群（阿贝尔幺半群）&quot;&gt;&lt;&#x2F;a&gt;可交换幺半群（阿贝尔幺半群）&lt;&#x2F;h3&gt;&lt;p&gt;幺半群 加上：&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;运算&lt;ul&gt;
&lt;li&gt;交换律&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;h3 id=&quot;群（group）&quot;&gt;&lt;a class=&quot;headerlink&quot; href=&quot;#群（group）&quot; title=&quot;群（group）&quot;&gt;&lt;&#x2F;a&gt;群（group）&lt;&#x2F;h3&gt;&lt;p&gt;幺半群 加上：&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;特殊元素&lt;ul&gt;
&lt;li&gt;（对每个元素）逆元&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;h3 id=&quot;可交换群（阿贝尔群）（Abelian-group）&quot;&gt;&lt;a class=&quot;headerlink&quot; href=&quot;#可交换群（阿贝尔群）（Abelian-group）&quot; title=&quot;可交换群（阿贝尔群）（Abelian group）&quot;&gt;&lt;&#x2F;a&gt;可交换群（阿贝尔群）（Abelian group）&lt;&#x2F;h3&gt;&lt;p&gt;群 + 可交换幺半群&lt;&#x2F;p&gt;
&lt;h3 id=&quot;环（ring）&quot;&gt;&lt;a class=&quot;headerlink&quot; href=&quot;#环（ring）&quot; title=&quot;环（ring）&quot;&gt;&lt;&#x2F;a&gt;环（ring）&lt;&#x2F;h3&gt;&lt;p&gt;对一种运算（$\circ$）构成可交换群 + 对另一种运算（$\diamond$）构成半群 + $\circ$ 对$\diamond$有分配率&lt;&#x2F;p&gt;
&lt;h3 id=&quot;幺环&quot;&gt;&lt;a class=&quot;headerlink&quot; href=&quot;#幺环&quot; title=&quot;幺环&quot;&gt;&lt;&#x2F;a&gt;幺环&lt;&#x2F;h3&gt;&lt;p&gt;环 + 其中那个半群是含幺半群&lt;&#x2F;p&gt;
&lt;h3 id=&quot;交换环&quot;&gt;&lt;a class=&quot;headerlink&quot; href=&quot;#交换环&quot; title=&quot;交换环&quot;&gt;&lt;&#x2F;a&gt;交换环&lt;&#x2F;h3&gt;&lt;p&gt;环 + 其中那个半群是交换半群&lt;&#x2F;p&gt;
&lt;h3 id=&quot;无零因子环&quot;&gt;&lt;a class=&quot;headerlink&quot; href=&quot;#无零因子环&quot; title=&quot;无零因子环&quot;&gt;&lt;&#x2F;a&gt;无零因子环&lt;&#x2F;h3&gt;&lt;p&gt;环 + 没有零因子&lt;&#x2F;p&gt;
&lt;h3 id=&quot;整环&quot;&gt;&lt;a class=&quot;headerlink&quot; href=&quot;#整环&quot; title=&quot;整环&quot;&gt;&lt;&#x2F;a&gt;整环&lt;&#x2F;h3&gt;&lt;p&gt;交换环 + 幺环 + 无零因子环&lt;&#x2F;p&gt;
&lt;h3 id=&quot;除环&quot;&gt;&lt;a class=&quot;headerlink&quot; href=&quot;#除环&quot; title=&quot;除环&quot;&gt;&lt;&#x2F;a&gt;除环&lt;&#x2F;h3&gt;&lt;p&gt;所有元素都在 $\circ$ 上有逆元&lt;&#x2F;p&gt;
&lt;h3 id=&quot;域（field）&quot;&gt;&lt;a class=&quot;headerlink&quot; href=&quot;#域（field）&quot; title=&quot;域（field）&quot;&gt;&lt;&#x2F;a&gt;域（field）&lt;&#x2F;h3&gt;&lt;p&gt;交换环 + 除环&lt;&#x2F;p&gt;
&lt;h3 id=&quot;偏序集（partially-ordered-set）&quot;&gt;&lt;a class=&quot;headerlink&quot; href=&quot;#偏序集（partially-ordered-set）&quot; title=&quot;偏序集（partially ordered set）&quot;&gt;&lt;&#x2F;a&gt;偏序集（partially ordered set）&lt;&#x2F;h3&gt;&lt;p&gt;定义了偏序的集合&lt;&#x2F;p&gt;
&lt;h3 id=&quot;ban-ge&quot;&gt;半格&lt;sup class=&quot;footnote-reference&quot;&gt;&lt;a href=&quot;#2&quot;&gt;2&lt;&#x2F;a&gt;&lt;&#x2F;sup&gt;&lt;&#x2F;h3&gt;
&lt;h4 id=&quot;xu-li-lun-zhong-de-ban-ge-de-ding-yi&quot;&gt;序理论中的半格的定义&lt;&#x2F;h4&gt;
&lt;p&gt;偏序集 + (最小上界 | 最大上界)&lt;&#x2F;p&gt;
&lt;h4 id=&quot;chou-xiang-dai-shu-zhong-de-ban-ge-de-ding-yi&quot;&gt;抽象代数中的半格的定义&lt;&#x2F;h4&gt;
&lt;p&gt;集合 加上&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;运算
&lt;ul&gt;
&lt;li&gt;交换律&lt;&#x2F;li&gt;
&lt;li&gt;结合律&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;h3 id=&quot;ge-lattice&quot;&gt;格（Lattice）&lt;&#x2F;h3&gt;
&lt;h4 id=&quot;xu-li-lun-zhong-de-ge-ding-yi&quot;&gt;序理论中的格定义&lt;&#x2F;h4&gt;
&lt;p&gt;偏序集 + 最小上界 + 最大上界&lt;&#x2F;p&gt;
&lt;h4 id=&quot;chou-xiang-dai-shu-zhong-de-ge-ding-yi&quot;&gt;抽象代数中的格定义&lt;&#x2F;h4&gt;
&lt;p&gt;两个定义在同一个集合上，但运算不同的半格，加上&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;两个运算
&lt;ul&gt;
&lt;li&gt;吸收律&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;h3 id=&quot;分配格&quot;&gt;&lt;a class=&quot;headerlink&quot; href=&quot;#分配格&quot; title=&quot;分配格&quot;&gt;&lt;&#x2F;a&gt;分配格&lt;&#x2F;h3&gt;&lt;p&gt;格 加上&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;运算&lt;ul&gt;
&lt;li&gt;分配率&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;h3 id=&quot;完全格&quot;&gt;&lt;a class=&quot;headerlink&quot; href=&quot;#完全格&quot; title=&quot;完全格&quot;&gt;&lt;&#x2F;a&gt;完全格&lt;&#x2F;h3&gt;&lt;p&gt;偏序集 + 所有子集都有上确界和下确界&lt;&#x2F;p&gt;
&lt;h3 id=&quot;有界格&quot;&gt;&lt;a class=&quot;headerlink&quot; href=&quot;#有界格&quot; title=&quot;有界格&quot;&gt;&lt;&#x2F;a&gt;有界格&lt;&#x2F;h3&gt;&lt;p&gt;格 加上&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;有全下界和全上界&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;h3 id=&quot;有补格&quot;&gt;&lt;a class=&quot;headerlink&quot; href=&quot;#有补格&quot; title=&quot;有补格&quot;&gt;&lt;&#x2F;a&gt;有补格&lt;&#x2F;h3&gt;&lt;p&gt;有界格 加上&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;对任意元素均有补元&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;h4 id=&quot;补元&quot;&gt;&lt;a class=&quot;headerlink&quot; href=&quot;#补元&quot; title=&quot;补元&quot;&gt;&lt;&#x2F;a&gt;补元&lt;&#x2F;h4&gt;&lt;script type=&quot;math&#x2F;tex; mode=display&quot;&gt;
a\ \wedge\ b=0&lt;&#x2F;script&gt;&lt;p&gt;且&lt;&#x2F;p&gt;
&lt;script type=&quot;math&#x2F;tex; mode=display&quot;&gt;
a\ \vee\ b = 1&lt;&#x2F;script&gt;&lt;p&gt;则 $b$ 是 $a$ 的补元。&lt;&#x2F;p&gt;
&lt;h3 id=&quot;海廷代数&quot;&gt;&lt;a class=&quot;headerlink&quot; href=&quot;#海廷代数&quot; title=&quot;海廷代数&quot;&gt;&lt;&#x2F;a&gt;海廷代数&lt;&#x2F;h3&gt;&lt;p&gt;有界格 加上&lt;&#x2F;p&gt;
&lt;p&gt;对于所有 $a$ 和 $b$，集合中存在最大的 $x$，使得$a \wedge x \leq b$。&lt;&#x2F;p&gt;
&lt;p&gt;其中 $x$ 称为 $a$ 对 $b$ 的相对伪补元。&lt;&#x2F;p&gt;
&lt;h3 id=&quot;完全海廷代数&quot;&gt;&lt;a class=&quot;headerlink&quot; href=&quot;#完全海廷代数&quot; title=&quot;完全海廷代数&quot;&gt;&lt;&#x2F;a&gt;完全海廷代数&lt;&#x2F;h3&gt;&lt;p&gt;海廷代数 + 完全格&lt;&#x2F;p&gt;
&lt;h3 id=&quot;布尔代数&quot;&gt;&lt;a class=&quot;headerlink&quot; href=&quot;#布尔代数&quot; title=&quot;布尔代数&quot;&gt;&lt;&#x2F;a&gt;布尔代数&lt;&#x2F;h3&gt;&lt;p&gt;有补格 + 分配格&lt;&#x2F;p&gt;
&lt;p&gt;或&lt;&#x2F;p&gt;
&lt;p&gt;海廷代数 将 相对伪补元改为真正的补元。&lt;&#x2F;p&gt;
&lt;h3 id=&quot;完全布尔代数&quot;&gt;&lt;a class=&quot;headerlink&quot; href=&quot;#完全布尔代数&quot; title=&quot;完全布尔代数&quot;&gt;&lt;&#x2F;a&gt;完全布尔代数&lt;&#x2F;h3&gt;&lt;p&gt;布尔代数 + 完全格&lt;&#x2F;p&gt;
&lt;h3 id=&quot;逻辑代数&quot;&gt;&lt;a class=&quot;headerlink&quot; href=&quot;#逻辑代数&quot; title=&quot;逻辑代数&quot;&gt;&lt;&#x2F;a&gt;逻辑代数&lt;&#x2F;h3&gt;&lt;p&gt;布尔代数 + 二元（集合中元素只有两个）&lt;&#x2F;p&gt;
&lt;div class=&quot;footnote-definition&quot; id=&quot;1&quot;&gt;&lt;sup class=&quot;footnote-definition-label&quot;&gt;1&lt;&#x2F;sup&gt;
&lt;p&gt;各种材料常常用常见的乘号和加号代表运算，个人并不喜欢这样做，”不同”的东西应该用”不同”的记号。&lt;&#x2F;p&gt;
&lt;&#x2F;div&gt;
&lt;div class=&quot;footnote-definition&quot; id=&quot;2&quot;&gt;&lt;sup class=&quot;footnote-definition-label&quot;&gt;2&lt;&#x2F;sup&gt;
&lt;p&gt;（半）格在群论和序理论中代表两个不同的东西，英文名称都叫Lattice，中文名称都叫格。数学家起名字的水平和我五五开。&lt;&#x2F;p&gt;
&lt;&#x2F;div&gt;
</content>
        
    </entry>
    <entry xml:lang="zh">
        <title>Flexbox 布局 cheatsheet</title>
        <published>2018-04-09T22:20:50+00:00</published>
        <updated>2018-04-09T22:20:50+00:00</updated>
        <author>
          <name>Unknown</name>
        </author>
        <link rel="alternate" href="https://longfangsong.github.io/flex-layout/" type="text/html"/>
        <id>https://longfangsong.github.io/flex-layout/</id>
        
        <content type="html">&lt;p&gt;Flexbox 是现代 web 页面布局的一大利器，但是相关属性众多，本人每次使用都要查文档，而且查了多次（≥20）居然一点都没记住。&lt;&#x2F;p&gt;
&lt;p&gt;所以我就写了这个 cheatsheet，不是因为写了就记住了，而是从自己写的文档里翻东西比较快……&lt;&#x2F;p&gt;
&lt;h2 id=&quot;display-flex&quot;&gt;&lt;code&gt;display: flex;&lt;&#x2F;code&gt;&lt;&#x2F;h2&gt;
&lt;p&gt;在某个元素上设置，这个元素内部使用 Flexbox 布局。&lt;&#x2F;p&gt;
&lt;h2 id=&quot;flex-direction&quot;&gt;&lt;code&gt;flex-direction&lt;&#x2F;code&gt;&lt;&#x2F;h2&gt;
&lt;p&gt;主轴方向，取值如下：&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;row&lt;&#x2F;code&gt;&lt;&#x2F;li&gt;
&lt;li&gt;&lt;code&gt;row-reverse&lt;&#x2F;code&gt;&lt;&#x2F;li&gt;
&lt;li&gt;&lt;code&gt;column&lt;&#x2F;code&gt;&lt;&#x2F;li&gt;
&lt;li&gt;&lt;code&gt;column-reverse&lt;&#x2F;code&gt;&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;h2 id=&quot;justify-content&quot;&gt;&lt;code&gt;justify-content&lt;&#x2F;code&gt;&lt;&#x2F;h2&gt;
&lt;p&gt;控制主轴方向上元素的排列，取值如下：&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;center&lt;&#x2F;code&gt;&lt;&#x2F;li&gt;
&lt;li&gt;&lt;code&gt;start&lt;&#x2F;code&gt;&lt;&#x2F;li&gt;
&lt;li&gt;&lt;code&gt;flex-start&lt;&#x2F;code&gt;&lt;&#x2F;li&gt;
&lt;li&gt;&lt;code&gt;end&lt;&#x2F;code&gt;&lt;&#x2F;li&gt;
&lt;li&gt;&lt;code&gt;flex-end&lt;&#x2F;code&gt;&lt;&#x2F;li&gt;
&lt;li&gt;&lt;code&gt;space-between&lt;&#x2F;code&gt;&lt;&#x2F;li&gt;
&lt;li&gt;&lt;code&gt;space-around&lt;&#x2F;code&gt;&lt;&#x2F;li&gt;
&lt;li&gt;&lt;code&gt;space-evenly&lt;&#x2F;code&gt;&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;&lt;code&gt;start&lt;&#x2F;code&gt;&#x2F;&lt;code&gt;flex-start&lt;&#x2F;code&gt; 和 &lt;code&gt;end&lt;&#x2F;code&gt;&#x2F;&lt;code&gt;flex-end&lt;&#x2F;code&gt; 之间的差别在于是否只对 flex 元素生效。&lt;&#x2F;p&gt;
&lt;h2 id=&quot;align-items&quot;&gt;&lt;code&gt;align-items&lt;&#x2F;code&gt;&lt;&#x2F;h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;stretch&lt;&#x2F;code&gt;&lt;&#x2F;li&gt;
&lt;li&gt;&lt;code&gt;flex-start&lt;&#x2F;code&gt;&lt;&#x2F;li&gt;
&lt;li&gt;&lt;code&gt;flex-end&lt;&#x2F;code&gt;&lt;&#x2F;li&gt;
&lt;li&gt;&lt;code&gt;center&lt;&#x2F;code&gt;&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;h2 id=&quot;flex&quot;&gt;&lt;code&gt;flex&lt;&#x2F;code&gt;&lt;&#x2F;h2&gt;
&lt;pre data-lang=&quot;css&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-css &quot;&gt;&lt;code class=&quot;language-css&quot; data-lang=&quot;css&quot;&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;flex: 数字
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;代表元素在flexbox中占的比例。&lt;&#x2F;p&gt;
</content>
        
    </entry>
</feed>
