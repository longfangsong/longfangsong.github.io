<?xml version="1.0" encoding="UTF-8"?>
<feed xmlns="http://www.w3.org/2005/Atom" xml:lang="zh">
	<title>Blog</title>
	<subtitle>生命是灰色的，而理论之树常青</subtitle>
	<link href="https://longfangsong.github.io/atom.xml" rel="self" type="application/atom+xml"/>
  <link href="https://longfangsong.github.io"/>
	<generator uri="https://www.getzola.org/">Zola</generator>
	<updated>2021-07-22T10:55:33.427+00:00</updated>
	<id>https://longfangsong.github.io/atom.xml</id>
	<entry xml:lang="zh">
		<title>自动机理论 • 有限状态机</title>
		<published>2021-07-22T10:55:33.427+00:00</published>
		<updated>2021-07-22T10:55:33.427+00:00</updated>
		<link href="https://longfangsong.github.io/automata-2/" type="text/html"/>
		<id>https://longfangsong.github.io/automata-2/</id>
		<content type="html">&lt;h2 id=&quot;que-ding-xing-you-xian-zhuang-tai-ji-deterministic-finite-automata-dfa&quot;&gt;确定性有限状态机（Deterministic Finite Automata, DFA）&lt;&#x2F;h2&gt;
&lt;p&gt;DFA包含以下要素：&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;一个有限大小的状态集合，常记为 $Q$。&lt;&#x2F;li&gt;
&lt;li&gt;一个有限大小的输入符号集合，常记为 $\Sigma$。&lt;&#x2F;li&gt;
&lt;li&gt;一个状态转换函数，其参数为一个状态（设为 $B$）和一个输入符号（设为 $a$），返回一个状态（设为 $C$），表现了状态机在状态 $B$ 时，若接收到输入 $a$，则应该转到状态 $C$，常记为 $\delta$，如 $C = \delta(B, a)$。&lt;&#x2F;li&gt;
&lt;li&gt;一个开始状态，常记为 $q_0$，$q_0 \in Q$&lt;&#x2F;li&gt;
&lt;li&gt;一个终止或者接受状态的集合，常记为 $F$，$F \subseteq Q$。&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;DFA 常常用如上五种要素的元组表示，记为 $A = (Q, \Sigma, \delta, q_0, F)$&lt;&#x2F;p&gt;
</content>
	</entry>
	<entry xml:lang="zh">
		<title>自动机理论 • 基本概念</title>
		<published>2021-07-22T08:13:38.757+00:00</published>
		<updated>2021-07-22T08:13:38.757+00:00</updated>
		<link href="https://longfangsong.github.io/automata-1/" type="text/html"/>
		<id>https://longfangsong.github.io/automata-1/</id>
		<content type="html">&lt;h2 id=&quot;zi-mu-biao-alphabet&quot;&gt;字母表（Alphabet）&lt;&#x2F;h2&gt;
&lt;p&gt;字母表是一个&lt;strong&gt;有限&lt;&#x2F;strong&gt;、&lt;strong&gt;非空&lt;&#x2F;strong&gt;的符号集合，常用 $\Sigma$ 表示。&lt;&#x2F;p&gt;
&lt;h3 id=&quot;zi-mu-biao-de-mi-power&quot;&gt;字母表的幂（Power）&lt;&#x2F;h3&gt;
&lt;p&gt;某个字母表 $\Sigma$ 的 $k$ 次幂就是由该字母表中的字母组成的，长度为 $k$ 的所有串组成的集合，记作 $\Sigma^k$。&lt;&#x2F;p&gt;
&lt;h2 id=&quot;zi-mu-biao-de-kleene-bi-bao-ke-lai-ni-xing-hao-kleene-star&quot;&gt;字母表的 Kleene 闭包（克莱尼星号， Kleene star）&lt;&#x2F;h2&gt;
&lt;blockquote&gt;
&lt;p&gt;Kleene 星号，或称 Kleene 闭包，德语称 Kleensche Hülle，在数学上是一种适用于字符串或符号及字元的集合的一元运算。 —— Wikipedia&lt;&#x2F;p&gt;
&lt;&#x2F;blockquote&gt;
&lt;p&gt;某个字母表 $\Sigma$ 在进行 Kleene 星号运算后的结果就是这个字母表可以表示的所有字符串（包含空串）组成的集合，记作 $\Sigma^*$。&lt;&#x2F;p&gt;
&lt;p&gt;将其中的空串去掉之后的集合记作 $\Sigma^+$。&lt;&#x2F;p&gt;
&lt;p&gt;我们有：&lt;&#x2F;p&gt;
&lt;p&gt;$$
\Sigma^+ = \bigcup^{+\infty}_1 \Sigma^k
$$&lt;&#x2F;p&gt;
&lt;p&gt;$$
\Sigma^* = \bigcup^{+\infty}_0 \Sigma^k = \Sigma^+ \cup \{\epsilon\}
$$&lt;&#x2F;p&gt;
&lt;h2 id=&quot;chuan-string&quot;&gt;串（String）&lt;&#x2F;h2&gt;
&lt;p&gt;串是一个由从某个字母表中选取的符号组成的序列。&lt;&#x2F;p&gt;
&lt;p&gt;空串是一个没有符号的串，常常用 $\epsilon$ 表示。&lt;&#x2F;p&gt;
&lt;h3 id=&quot;chuan-de-chang-du&quot;&gt;串的长度&lt;&#x2F;h3&gt;
&lt;p&gt;串的长度是指串中符号&lt;strong&gt;位置&lt;&#x2F;strong&gt;&lt;sup class=&quot;footnote-reference&quot;&gt;&lt;a href=&quot;#1&quot;&gt;1&lt;&#x2F;a&gt;&lt;&#x2F;sup&gt;的数量。&lt;&#x2F;p&gt;
&lt;h3 id=&quot;chuan-de-pin-jie-concatenation&quot;&gt;串的拼接（Concatenation）&lt;&#x2F;h3&gt;
&lt;p&gt;设有两个串 $x = a_1a_2\cdots a_n$ 和 $y = b_1b_2\cdots b_m$，则
$$
xy = a_1a_2\cdots a_nb_1b_2\cdots b_m
$$&lt;&#x2F;p&gt;
&lt;h2 id=&quot;yu-yan-language&quot;&gt;语言（Language）&lt;&#x2F;h2&gt;
&lt;p&gt;对于某个字母表 $\Sigma$，一个语言指其 Kleene 闭包的一个子集。&lt;&#x2F;p&gt;
&lt;h2 id=&quot;wen-ti-problem&quot;&gt;问题 （Problem）&lt;&#x2F;h2&gt;
&lt;p&gt;在自动机理论中，一个&lt;em&gt;问题&lt;&#x2F;em&gt;是一个判定一个给定的串是否属于某个语言的问题（question）。&lt;&#x2F;p&gt;
&lt;div class=&quot;footnote-definition&quot; id=&quot;1&quot;&gt;&lt;sup class=&quot;footnote-definition-label&quot;&gt;1&lt;&#x2F;sup&gt;
&lt;p&gt;符号位置数量不等于符号数量，比如串 &amp;quot;101010&amp;quot; 中的符号位置数量为 6，但符号数量（只有 0 和 1 ）为 2。&lt;&#x2F;p&gt;
&lt;&#x2F;div&gt;
</content>
	</entry>
	<entry xml:lang="zh">
		<title>重新开始学数学 • 数理逻辑（3）</title>
		<published>2021-07-06T06:02:46.315+00:00</published>
		<updated>2021-07-06T06:02:46.315+00:00</updated>
		<link href="https://longfangsong.github.io/restart-math-logic-3/" type="text/html"/>
		<id>https://longfangsong.github.io/restart-math-logic-3/</id>
		<content type="html">&lt;h2 id=&quot;model-structure-jie-gou-mo-xing&quot;&gt;Model（Structure、结构、模型）&lt;&#x2F;h2&gt;
&lt;h3 id=&quot;yong-tu&quot;&gt;用途&lt;&#x2F;h3&gt;
&lt;p&gt;Model 的主要作用是可以在给定一个 Model 的情况下，给一个谓词逻辑表达式求值。&lt;&#x2F;p&gt;
&lt;h3 id=&quot;qian-zhi-ding-yi&quot;&gt;前置定义&lt;&#x2F;h3&gt;
&lt;h4 id=&quot;han-shu-fu-hao-function-symbol&quot;&gt;函数符号（function symbol）&lt;&#x2F;h4&gt;
&lt;blockquote&gt;
&lt;p&gt;A logical symbol that may be applied to an object term to produce another object term.&lt;&#x2F;p&gt;
&lt;&#x2F;blockquote&gt;
&lt;p&gt;按我理解来说就是一个可以应用在某个 term&lt;sup class=&quot;footnote-reference&quot;&gt;&lt;a href=&quot;#1&quot;&gt;1&lt;&#x2F;a&gt;&lt;&#x2F;sup&gt; 上生成另一个 term 的一个逻辑符号。&lt;&#x2F;p&gt;
&lt;p&gt;函数符号是一个&lt;strong&gt;符号&lt;&#x2F;strong&gt;，他可以代表，但并不等同于某一个具体函数。&lt;&#x2F;p&gt;
&lt;h4 id=&quot;wei-ci-fu-hao-predicate-symbol&quot;&gt;谓词符号（predicate symbol）&lt;&#x2F;h4&gt;
&lt;blockquote&gt;
&lt;p&gt;A notation for some concrete predicate or relation.&lt;&#x2F;p&gt;
&lt;&#x2F;blockquote&gt;
&lt;p&gt;就是代表 predicate 的&lt;strong&gt;符号&lt;&#x2F;strong&gt;。&lt;&#x2F;p&gt;
&lt;h3 id=&quot;ding-yi&quot;&gt;定义&lt;&#x2F;h3&gt;
&lt;p&gt;设有函数符号集合 $F$ 和谓词符号集合 $P$，一个 Model $M$ 包含：&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;一个包含了所有具体值的集合，称为 $A$&lt;&#x2F;li&gt;
&lt;li&gt;对 $F$ 中每个函数符号，一个（每个参数的）定义域和值域均是 $A$ 的具体函数&lt;sup class=&quot;footnote-reference&quot;&gt;&lt;a href=&quot;#2&quot;&gt;2&lt;&#x2F;a&gt;&lt;&#x2F;sup&gt;&lt;&#x2F;li&gt;
&lt;li&gt;对 $P$ 中每个谓词符号，$A$ 上的一个具体谓词（或者说由这个谓词定义的关系）&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;h3 id=&quot;li&quot;&gt;例&lt;&#x2F;h3&gt;
&lt;p&gt;这里有一个函数符号集合 $F = \{ i: () \rightarrow Value \}$，&lt;&#x2F;p&gt;
&lt;p&gt;一个谓词符号集合 $P = \{ R: (Value, Value) \rightarrow bool, F: (Value) \rightarrow bool\}$&lt;&#x2F;p&gt;
&lt;p&gt;可以利用以上两个集合，加上一个状态集合 $A$，来建立状态机的 model，比如：&lt;&#x2F;p&gt;
&lt;div class=&quot;mermaid&quot;&gt;
stateDiagram-v2
    [*] --&amp;gt; a
    a --&amp;gt; a
    a --&amp;gt; b
    b --&amp;gt; c
    a --&amp;gt; c
    c --&amp;gt; c
    b --&amp;gt; [*]
    c --&amp;gt; [*]
&lt;&#x2F;div&gt;
&lt;p&gt;对以上这一个状态机，对应的模型 M 就是：&lt;&#x2F;p&gt;
&lt;p&gt;$$
\displaylines {
M.A = \{a, b, c\} \\
M.i = a \\
M.R = \{(a, a), (a, b), (b, c), (a, c), (c, c)\} \\
M.F = \{b, c\} \\
}
$$ &lt;&#x2F;p&gt;
&lt;p&gt;我们来给以下表达式求值：&lt;&#x2F;p&gt;
&lt;p&gt;$$
\forall x \exists y R(x, y)
$$&lt;&#x2F;p&gt;
&lt;p&gt;这个表达式意思是从某个状态出去一定能到达其他状态，显然是对的。&lt;&#x2F;p&gt;
&lt;div class=&quot;footnote-definition&quot; id=&quot;1&quot;&gt;&lt;sup class=&quot;footnote-definition-label&quot;&gt;1&lt;&#x2F;sup&gt;
&lt;p&gt;表示论域内元素的正规表达式。&lt;&#x2F;p&gt;
&lt;&#x2F;div&gt;
&lt;div class=&quot;footnote-definition&quot; id=&quot;2&quot;&gt;&lt;sup class=&quot;footnote-definition-label&quot;&gt;2&lt;&#x2F;sup&gt;
&lt;p&gt;这帮子数学家老喜欢把无参函数和值等价起来，所以书里面这条对有参和无参函数是分开的……我不觉得这么搞很好，函数就是函数，所以就揉在一起了。当然也可以完全分开，即有常量符号但没有无参函数。&lt;&#x2F;p&gt;
&lt;&#x2F;div&gt;
</content>
	</entry>
	<entry xml:lang="zh">
		<title>自动逻辑综合原理 • 组合逻辑与 LUT 的最简单的综合</title>
		<published>2021-04-25T16:09:46.815+00:00</published>
		<updated>2021-04-25T16:09:46.815+00:00</updated>
		<link href="https://longfangsong.github.io/fpga-sys-1/" type="text/html"/>
		<id>https://longfangsong.github.io/fpga-sys-1/</id>
		<content type="html">&lt;h2 id=&quot;lut&quot;&gt;LUT&lt;&#x2F;h2&gt;
&lt;blockquote&gt;
&lt;p&gt;一切皆查表。 ——我自己说的&lt;&#x2F;p&gt;
&lt;&#x2F;blockquote&gt;
&lt;p&gt;由于 FPGA 的基本结构是基于 Look Up Table 的，因此 FPGA 里实现组合逻辑的方式非常简单粗暴，就是把真值表非常暴力的存下来然后匹配。&lt;&#x2F;p&gt;
&lt;p&gt;比如说最简单的与逻辑：&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;verilog&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-verilog &quot;&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;&lt;span&gt;assign C = A &amp;amp; B;
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;其真值表：&lt;&#x2F;p&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;&lt;&#x2F;th&gt;&lt;th&gt;0&lt;&#x2F;th&gt;&lt;th&gt;1&lt;&#x2F;th&gt;&lt;&#x2F;tr&gt;&lt;&#x2F;thead&gt;&lt;tbody&gt;
&lt;tr&gt;&lt;td&gt;0&lt;&#x2F;td&gt;&lt;td&gt;0&lt;&#x2F;td&gt;&lt;td&gt;0&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;1&lt;&#x2F;td&gt;&lt;td&gt;0&lt;&#x2F;td&gt;&lt;td&gt;1&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;&#x2F;tbody&gt;&lt;&#x2F;table&gt;
&lt;p&gt;那么我们就可以用一小块存储器存下这张表：&lt;&#x2F;p&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;地址&lt;&#x2F;th&gt;&lt;th&gt;值&lt;&#x2F;th&gt;&lt;&#x2F;tr&gt;&lt;&#x2F;thead&gt;&lt;tbody&gt;
&lt;tr&gt;&lt;td&gt;00&lt;&#x2F;td&gt;&lt;td&gt;0&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;01&lt;&#x2F;td&gt;&lt;td&gt;0&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;10&lt;&#x2F;td&gt;&lt;td&gt;0&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;11&lt;&#x2F;td&gt;&lt;td&gt;1&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;&#x2F;tbody&gt;&lt;&#x2F;table&gt;
&lt;p&gt;这个存储器此时就是一个 LUT，输入 A 和 B 就能输出对应逻辑函数的值。&lt;&#x2F;p&gt;
&lt;p&gt;更多变量和更复杂的式子也是同理。&lt;&#x2F;p&gt;
&lt;h2 id=&quot;shi-jian&quot;&gt;实践&lt;&#x2F;h2&gt;
&lt;p&gt;我们来用最简单粗暴的方式实现一个支持简单组合逻辑电路综合的简单综合器。&lt;&#x2F;p&gt;
&lt;p&gt;为了方便快草猛的实现出一个能动的程序，我们将要综合的逻辑函数限制在 4 个以下的输入和单个输出，这样就能使用单个 LUT4 综合出可以动的成果。&lt;&#x2F;p&gt;
&lt;p&gt;注意实际的综合器实现方式肯定不是这样暴力解出真值表然后就硬带，肯定是有更先进的方案的。&lt;&#x2F;p&gt;
&lt;h3 id=&quot;mu-biao-wen-jian-ge-shi&quot;&gt;目标文件格式&lt;&#x2F;h3&gt;
&lt;p&gt;为了方便上硬件，我们综合到的目标是 &lt;code&gt;nextpnr-ecp5&lt;&#x2F;code&gt; 中使用的 json 文件。&lt;&#x2F;p&gt;
&lt;p&gt;经过仔细阅读 &lt;code&gt;yosys&lt;&#x2F;code&gt; 综合出来的 json 文件以及反复实验，我们可以确定这个 json 最小需要写出如下内容：&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;json&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-json &quot;&gt;&lt;code class=&quot;language-json&quot; data-lang=&quot;json&quot;&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;    &amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;creator&lt;&#x2F;span&gt;&lt;span&gt;&amp;quot;: &amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;&amp;lt;综合器名称和版本，其实目测可以不写&amp;gt;&lt;&#x2F;span&gt;&lt;span&gt;&amp;quot;,
&lt;&#x2F;span&gt;&lt;span&gt;    &amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;modules&lt;&#x2F;span&gt;&lt;span&gt;&amp;quot;: {
&lt;&#x2F;span&gt;&lt;span&gt;        &amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;Module1&lt;&#x2F;span&gt;&lt;span&gt;&amp;quot;: {&lt;&#x2F;span&gt;&lt;span style=&quot;background-color:#bf616a;color:#2b303b;&quot;&gt;&amp;lt;内容&amp;gt;&lt;&#x2F;span&gt;&lt;span&gt;},
&lt;&#x2F;span&gt;&lt;span&gt;        &amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;Module2&lt;&#x2F;span&gt;&lt;span&gt;&amp;quot;: {&lt;&#x2F;span&gt;&lt;span style=&quot;background-color:#bf616a;color:#2b303b;&quot;&gt;&amp;lt;内容&amp;gt;&lt;&#x2F;span&gt;&lt;span&gt;},
&lt;&#x2F;span&gt;&lt;span&gt;    }
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;其中 module 的内容：&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;json&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-json &quot;&gt;&lt;code class=&quot;language-json&quot; data-lang=&quot;json&quot;&gt;&lt;span&gt;&amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;ports&lt;&#x2F;span&gt;&lt;span&gt;&amp;quot;: {
&lt;&#x2F;span&gt;&lt;span&gt;    &amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;&amp;lt;对外端口名称&amp;gt;&lt;&#x2F;span&gt;&lt;span&gt;&amp;quot;: {
&lt;&#x2F;span&gt;&lt;span&gt;        &amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;direction&lt;&#x2F;span&gt;&lt;span&gt;&amp;quot;: &amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;&amp;lt;input&#x2F;output&amp;gt;&lt;&#x2F;span&gt;&lt;span&gt;&amp;quot;,
&lt;&#x2F;span&gt;&lt;span&gt;        &amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;bits&lt;&#x2F;span&gt;&lt;span&gt;&amp;quot;: [&lt;&#x2F;span&gt;&lt;span style=&quot;background-color:#bf616a;color:#2b303b;&quot;&gt;&amp;lt;对应的线网的第&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;1&lt;&#x2F;span&gt;&lt;span style=&quot;background-color:#bf616a;color:#2b303b;&quot;&gt;个bit的id&amp;gt;&lt;&#x2F;span&gt;&lt;span&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;background-color:#bf616a;color:#2b303b;&quot;&gt;&amp;lt;对应的线网的第&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;2&lt;&#x2F;span&gt;&lt;span style=&quot;background-color:#bf616a;color:#2b303b;&quot;&gt;个bit的id&amp;gt;&lt;&#x2F;span&gt;&lt;span&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;background-color:#bf616a;color:#2b303b;&quot;&gt;...&lt;&#x2F;span&gt;&lt;span&gt;]
&lt;&#x2F;span&gt;&lt;span&gt;    },
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;background-color:#bf616a;color:#2b303b;&quot;&gt;...&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;},
&lt;&#x2F;span&gt;&lt;span&gt;&amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;cells&lt;&#x2F;span&gt;&lt;span&gt;&amp;quot;: {
&lt;&#x2F;span&gt;&lt;span&gt;    &amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;&amp;lt;子组件名称&amp;gt;&lt;&#x2F;span&gt;&lt;span&gt;&amp;quot;: {
&lt;&#x2F;span&gt;&lt;span&gt;        &amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;type&lt;&#x2F;span&gt;&lt;span&gt;&amp;quot;: &amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;&amp;lt;子组件类型&amp;gt;&lt;&#x2F;span&gt;&lt;span&gt;&amp;quot;,
&lt;&#x2F;span&gt;&lt;span&gt;        &amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;parameters&lt;&#x2F;span&gt;&lt;span&gt;&amp;quot;: {
&lt;&#x2F;span&gt;&lt;span&gt;            &amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;&amp;lt;子组件参数名1&amp;gt;&lt;&#x2F;span&gt;&lt;span&gt;&amp;quot;: &amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;&amp;lt;子组件参数值1&amp;gt;&lt;&#x2F;span&gt;&lt;span&gt;&amp;quot;,
&lt;&#x2F;span&gt;&lt;span&gt;            &lt;&#x2F;span&gt;&lt;span style=&quot;background-color:#bf616a;color:#2b303b;&quot;&gt;...&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;        },
&lt;&#x2F;span&gt;&lt;span&gt;        &amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;port_directions&lt;&#x2F;span&gt;&lt;span&gt;&amp;quot;: {
&lt;&#x2F;span&gt;&lt;span&gt;            &amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;&amp;lt;子组件端口名1&amp;gt;&lt;&#x2F;span&gt;&lt;span&gt;&amp;quot;: &amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;input&#x2F;output&lt;&#x2F;span&gt;&lt;span&gt;&amp;quot;,
&lt;&#x2F;span&gt;&lt;span&gt;            &lt;&#x2F;span&gt;&lt;span style=&quot;background-color:#bf616a;color:#2b303b;&quot;&gt;...&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;        },
&lt;&#x2F;span&gt;&lt;span&gt;        &amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;connections&lt;&#x2F;span&gt;&lt;span&gt;&amp;quot;: {
&lt;&#x2F;span&gt;&lt;span&gt;            &amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;&amp;lt;子组件端口名1&amp;gt;&lt;&#x2F;span&gt;&lt;span&gt;&amp;quot;: [&lt;&#x2F;span&gt;&lt;span style=&quot;background-color:#bf616a;color:#2b303b;&quot;&gt;&amp;lt;子组件端口&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;1&lt;&#x2F;span&gt;&lt;span style=&quot;background-color:#bf616a;color:#2b303b;&quot;&gt;连接到的线网的第&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;1&lt;&#x2F;span&gt;&lt;span style=&quot;background-color:#bf616a;color:#2b303b;&quot;&gt;个bit的id&amp;gt;&lt;&#x2F;span&gt;&lt;span&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;background-color:#bf616a;color:#2b303b;&quot;&gt;&amp;lt;子组件端口&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;1&lt;&#x2F;span&gt;&lt;span style=&quot;background-color:#bf616a;color:#2b303b;&quot;&gt;连接到的线网的第&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;2&lt;&#x2F;span&gt;&lt;span style=&quot;background-color:#bf616a;color:#2b303b;&quot;&gt;个bit的id&amp;gt;&lt;&#x2F;span&gt;&lt;span&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;background-color:#bf616a;color:#2b303b;&quot;&gt;...&lt;&#x2F;span&gt;&lt;span&gt;],
&lt;&#x2F;span&gt;&lt;span&gt;            &lt;&#x2F;span&gt;&lt;span style=&quot;background-color:#bf616a;color:#2b303b;&quot;&gt;...&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;        }
&lt;&#x2F;span&gt;&lt;span&gt;    }
&lt;&#x2F;span&gt;&lt;span&gt;},
&lt;&#x2F;span&gt;&lt;span&gt;&amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;netnames&lt;&#x2F;span&gt;&lt;span&gt;&amp;quot;: {
&lt;&#x2F;span&gt;&lt;span&gt;    &amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;&amp;lt;线网名称&amp;gt;&lt;&#x2F;span&gt;&lt;span&gt;&amp;quot;: {
&lt;&#x2F;span&gt;&lt;span&gt;        &amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;bits&lt;&#x2F;span&gt;&lt;span&gt;&amp;quot;: [&lt;&#x2F;span&gt;&lt;span style=&quot;background-color:#bf616a;color:#2b303b;&quot;&gt;&amp;lt;对应的线网的第&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;1&lt;&#x2F;span&gt;&lt;span style=&quot;background-color:#bf616a;color:#2b303b;&quot;&gt;个bit的id&amp;gt;&lt;&#x2F;span&gt;&lt;span&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;background-color:#bf616a;color:#2b303b;&quot;&gt;&amp;lt;对应的线网的第&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;2&lt;&#x2F;span&gt;&lt;span style=&quot;background-color:#bf616a;color:#2b303b;&quot;&gt;个bit的id&amp;gt;&lt;&#x2F;span&gt;&lt;span&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;background-color:#bf616a;color:#2b303b;&quot;&gt;...&lt;&#x2F;span&gt;&lt;span&gt;]
&lt;&#x2F;span&gt;&lt;span&gt;    },
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;h3 id=&quot;parser&quot;&gt;parser&lt;&#x2F;h3&gt;
&lt;p&gt;略，见我以前有关 parser combinator 的文章。&lt;&#x2F;p&gt;
&lt;p&gt;总之把这样子的输入：&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span&gt;module Top(a: bit, b: bit) -&amp;gt; bit {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;return&lt;&#x2F;span&gt;&lt;span&gt; a &amp;amp; b;
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;parse 成这样的结构：&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;&#x2F;&#x2F; Bracket、逻辑函数的实现同普通编程语言，略
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;pub enum &lt;&#x2F;span&gt;&lt;span&gt;Expression {
&lt;&#x2F;span&gt;&lt;span&gt;    Name(String),
&lt;&#x2F;span&gt;&lt;span&gt;    Bracket(Bracket),
&lt;&#x2F;span&gt;&lt;span&gt;    Not(Not),
&lt;&#x2F;span&gt;&lt;span&gt;    Or(Or),
&lt;&#x2F;span&gt;&lt;span&gt;    And(And),
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;pub struct &lt;&#x2F;span&gt;&lt;span&gt;Return(pub Expression);
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;pub struct &lt;&#x2F;span&gt;&lt;span&gt;Port {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;pub &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;name&lt;&#x2F;span&gt;&lt;span&gt;: String,
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;pub struct &lt;&#x2F;span&gt;&lt;span&gt;Module {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;pub &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;name&lt;&#x2F;span&gt;&lt;span&gt;: String,
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;pub &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;input&lt;&#x2F;span&gt;&lt;span&gt;: Vec&amp;lt;Port&amp;gt;,
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;&#x2F;&#x2F; todo: output type
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;pub &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;output&lt;&#x2F;span&gt;&lt;span&gt;: Vec&amp;lt;()&amp;gt;,
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;&#x2F;&#x2F; todo: `Statement` instead of `Return`
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;pub &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;statements&lt;&#x2F;span&gt;&lt;span&gt;: Vec&amp;lt;Return&amp;gt;,
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;然后将表达式编译成如下的 LUT4:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;pub struct &lt;&#x2F;span&gt;&lt;span&gt;LUT4 {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;pub &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;name&lt;&#x2F;span&gt;&lt;span&gt;: String,
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;pub &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;initial_value&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;u16&lt;&#x2F;span&gt;&lt;span&gt;,
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;pub &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;input_connections&lt;&#x2F;span&gt;&lt;span&gt;: [&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;usize&lt;&#x2F;span&gt;&lt;span&gt;; 4],
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;pub &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;output_connections&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;usize&lt;&#x2F;span&gt;&lt;span&gt;,
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;编译过程如下，代码太丑不好意思拿出来看我就放伪代码了：&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;pub fn &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;compile_expression&lt;&#x2F;span&gt;&lt;span&gt;(
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;expression&lt;&#x2F;span&gt;&lt;span&gt;: frontend::Expression,
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;context&lt;&#x2F;span&gt;&lt;span&gt;: &amp;amp;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;mut&lt;&#x2F;span&gt;&lt;span&gt; Context,
&lt;&#x2F;span&gt;&lt;span&gt;) -&amp;gt; Result&amp;lt;LUT4, ()&amp;gt; {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;&#x2F;&#x2F; generate initial_value
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;let mut&lt;&#x2F;span&gt;&lt;span&gt; initial_value = &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;0&lt;&#x2F;span&gt;&lt;span&gt;;
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;let mut&lt;&#x2F;span&gt;&lt;span&gt; variables = expression.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;variables&lt;&#x2F;span&gt;&lt;span&gt;();
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;while&lt;&#x2F;span&gt;&lt;span&gt; variables.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;len&lt;&#x2F;span&gt;&lt;span&gt;() &amp;lt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;4 &lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;        variables.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;push&lt;&#x2F;span&gt;&lt;span&gt;(format!(&amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;dummy_&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;{}&lt;&#x2F;span&gt;&lt;span&gt;&amp;quot;, variables.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;len&lt;&#x2F;span&gt;&lt;span&gt;()));
&lt;&#x2F;span&gt;&lt;span&gt;    }
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;for&lt;&#x2F;span&gt;&lt;span&gt; i, (a, b, c, d) in &lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;tagged_cartesian_product&lt;&#x2F;span&gt;&lt;span&gt;(a: (&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;0&lt;&#x2F;span&gt;&lt;span&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;1&lt;&#x2F;span&gt;&lt;span&gt;), b: (&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;0&lt;&#x2F;span&gt;&lt;span&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;1&lt;&#x2F;span&gt;&lt;span&gt;), c: (&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;0&lt;&#x2F;span&gt;&lt;span&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;1&lt;&#x2F;span&gt;&lt;span&gt;), d: (&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;0&lt;&#x2F;span&gt;&lt;span&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;1&lt;&#x2F;span&gt;&lt;span&gt;)).&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;enumerate&lt;&#x2F;span&gt;&lt;span&gt;() {
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; result = expression.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;evaluate&lt;&#x2F;span&gt;&lt;span&gt;(a, b, c, d);
&lt;&#x2F;span&gt;&lt;span&gt;        initial_value |= result &amp;lt;&amp;lt; i;
&lt;&#x2F;span&gt;&lt;span&gt;    }
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;&#x2F;&#x2F; generate input connections
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;let mut&lt;&#x2F;span&gt;&lt;span&gt; connections = [&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;0&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;usize&lt;&#x2F;span&gt;&lt;span&gt;; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;4&lt;&#x2F;span&gt;&lt;span&gt;];
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;for &lt;&#x2F;span&gt;&lt;span&gt;(index, variable) in variables.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;enumerate&lt;&#x2F;span&gt;&lt;span&gt;() {
&lt;&#x2F;span&gt;&lt;span&gt;        connections[index] = *context.wires.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;get&lt;&#x2F;span&gt;&lt;span&gt;(*variable).&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;unwrap&lt;&#x2F;span&gt;&lt;span&gt;();
&lt;&#x2F;span&gt;&lt;span&gt;    }
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; id = context.next_id++;
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; name = format!(&amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;port&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;{}&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;_LUT4&lt;&#x2F;span&gt;&lt;span&gt;&amp;quot;, id);
&lt;&#x2F;span&gt;&lt;span&gt;    context.wires.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;insert&lt;&#x2F;span&gt;&lt;span&gt;(format!(&amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;port&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;{}&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;_LUT4_Z&lt;&#x2F;span&gt;&lt;span&gt;&amp;quot;, id), id);
&lt;&#x2F;span&gt;&lt;span&gt;    Ok(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;LUT4 &lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;        name,
&lt;&#x2F;span&gt;&lt;span&gt;        initial_value,
&lt;&#x2F;span&gt;&lt;span&gt;        input_connections: connections,
&lt;&#x2F;span&gt;&lt;span&gt;        output_connections: id,
&lt;&#x2F;span&gt;&lt;span&gt;    })
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;总之就是暴力把所有可能带入 expression 求出真值表，进而算出 LUT4 的初始值，再次提醒这不是生产环境下的做法。&lt;&#x2F;p&gt;
&lt;p&gt;然后就是生成 JSON，这里只展示从 LUT4 生成 &lt;code&gt;Cell&lt;&#x2F;code&gt; 的代码：&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;pub struct &lt;&#x2F;span&gt;&lt;span&gt;Cell {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;name&lt;&#x2F;span&gt;&lt;span&gt;: String,
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;component_type&lt;&#x2F;span&gt;&lt;span&gt;: String,
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;parameters&lt;&#x2F;span&gt;&lt;span&gt;: HashMap&amp;lt;String, String&amp;gt;,
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;port_directions&lt;&#x2F;span&gt;&lt;span&gt;: HashMap&amp;lt;String, PortDirection&amp;gt;,
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;connections&lt;&#x2F;span&gt;&lt;span&gt;: HashMap&amp;lt;String, Vec&amp;lt;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;usize&lt;&#x2F;span&gt;&lt;span&gt;&amp;gt;&amp;gt;,
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;impl &lt;&#x2F;span&gt;&lt;span&gt;From&amp;lt;LUT4&amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;for &lt;&#x2F;span&gt;&lt;span&gt;Cell {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;from&lt;&#x2F;span&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;lut&lt;&#x2F;span&gt;&lt;span&gt;: LUT4) -&amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;Self &lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; port_directions = {
&lt;&#x2F;span&gt;&lt;span&gt;            &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;let mut&lt;&#x2F;span&gt;&lt;span&gt; m = HashMap::new();
&lt;&#x2F;span&gt;&lt;span&gt;            m.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;insert&lt;&#x2F;span&gt;&lt;span&gt;(&amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;A&lt;&#x2F;span&gt;&lt;span&gt;&amp;quot;.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;to_string&lt;&#x2F;span&gt;&lt;span&gt;(), PortDirection::Input);
&lt;&#x2F;span&gt;&lt;span&gt;            m.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;insert&lt;&#x2F;span&gt;&lt;span&gt;(&amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;B&lt;&#x2F;span&gt;&lt;span&gt;&amp;quot;.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;to_string&lt;&#x2F;span&gt;&lt;span&gt;(), PortDirection::Input);
&lt;&#x2F;span&gt;&lt;span&gt;            m.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;insert&lt;&#x2F;span&gt;&lt;span&gt;(&amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;C&lt;&#x2F;span&gt;&lt;span&gt;&amp;quot;.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;to_string&lt;&#x2F;span&gt;&lt;span&gt;(), PortDirection::Input);
&lt;&#x2F;span&gt;&lt;span&gt;            m.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;insert&lt;&#x2F;span&gt;&lt;span&gt;(&amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;D&lt;&#x2F;span&gt;&lt;span&gt;&amp;quot;.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;to_string&lt;&#x2F;span&gt;&lt;span&gt;(), PortDirection::Input);
&lt;&#x2F;span&gt;&lt;span&gt;            m.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;insert&lt;&#x2F;span&gt;&lt;span&gt;(&amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;Z&lt;&#x2F;span&gt;&lt;span&gt;&amp;quot;.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;to_string&lt;&#x2F;span&gt;&lt;span&gt;(), PortDirection::Output);
&lt;&#x2F;span&gt;&lt;span&gt;            m
&lt;&#x2F;span&gt;&lt;span&gt;        };
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; parameters = {
&lt;&#x2F;span&gt;&lt;span&gt;            &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;let mut&lt;&#x2F;span&gt;&lt;span&gt; m = HashMap::new();
&lt;&#x2F;span&gt;&lt;span&gt;            m.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;insert&lt;&#x2F;span&gt;&lt;span&gt;(&amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;INIT&lt;&#x2F;span&gt;&lt;span&gt;&amp;quot;.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;to_string&lt;&#x2F;span&gt;&lt;span&gt;(), format!(&amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;{:16b}&lt;&#x2F;span&gt;&lt;span&gt;&amp;quot;, lut.initial_value));
&lt;&#x2F;span&gt;&lt;span&gt;            m
&lt;&#x2F;span&gt;&lt;span&gt;        };
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; c = [&amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;A&lt;&#x2F;span&gt;&lt;span&gt;&amp;quot;, &amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;B&lt;&#x2F;span&gt;&lt;span&gt;&amp;quot;, &amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;C&lt;&#x2F;span&gt;&lt;span&gt;&amp;quot;, &amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;D&lt;&#x2F;span&gt;&lt;span&gt;&amp;quot;]
&lt;&#x2F;span&gt;&lt;span&gt;            .&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;iter&lt;&#x2F;span&gt;&lt;span&gt;()
&lt;&#x2F;span&gt;&lt;span&gt;            .&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;zip&lt;&#x2F;span&gt;&lt;span&gt;(lut.input_connections.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;iter&lt;&#x2F;span&gt;&lt;span&gt;())
&lt;&#x2F;span&gt;&lt;span&gt;            .&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;chain&lt;&#x2F;span&gt;&lt;span&gt;([&amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;Z&lt;&#x2F;span&gt;&lt;span&gt;&amp;quot;].&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;iter&lt;&#x2F;span&gt;&lt;span&gt;().&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;zip&lt;&#x2F;span&gt;&lt;span&gt;(iter::once(&amp;amp;lut.output_connections)));
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;let mut&lt;&#x2F;span&gt;&lt;span&gt; connections = HashMap::new();
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;for &lt;&#x2F;span&gt;&lt;span&gt;(name, &amp;amp;id) in c {
&lt;&#x2F;span&gt;&lt;span&gt;            connections.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;insert&lt;&#x2F;span&gt;&lt;span&gt;(name.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;to_string&lt;&#x2F;span&gt;&lt;span&gt;(), vec![id]);
&lt;&#x2F;span&gt;&lt;span&gt;        }
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;Self &lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;            name: lut.name,
&lt;&#x2F;span&gt;&lt;span&gt;            component_type: &amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;LUT4&lt;&#x2F;span&gt;&lt;span&gt;&amp;quot;.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;to_string&lt;&#x2F;span&gt;&lt;span&gt;(),
&lt;&#x2F;span&gt;&lt;span&gt;            parameters,
&lt;&#x2F;span&gt;&lt;span&gt;            port_directions,
&lt;&#x2F;span&gt;&lt;span&gt;            connections,
&lt;&#x2F;span&gt;&lt;span&gt;        }
&lt;&#x2F;span&gt;&lt;span&gt;    }
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;其他部分的实现略，唯一要注意的点就是这里 Serde 的实现有些怪异，需要自己搞，具体见代码（等我写的好一点就开源），重点就是要活用 &lt;code&gt;collect_map&lt;&#x2F;code&gt; 和 &lt;code&gt;serialize_map&lt;&#x2F;code&gt; 就是了。&lt;&#x2F;p&gt;
&lt;h3 id=&quot;run-yi-xia-shi-shi&quot;&gt;Run 一下试试！&lt;&#x2F;h3&gt;
&lt;p&gt;我们用我们的程序综合上面提到的代码，可以得到：&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;json&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-json &quot;&gt;&lt;code class=&quot;language-json&quot; data-lang=&quot;json&quot;&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;    &amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;creator&lt;&#x2F;span&gt;&lt;span&gt;&amp;quot;: &amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;Rosys 0.1&lt;&#x2F;span&gt;&lt;span&gt;&amp;quot;,
&lt;&#x2F;span&gt;&lt;span&gt;    &amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;modules&lt;&#x2F;span&gt;&lt;span&gt;&amp;quot;: {
&lt;&#x2F;span&gt;&lt;span&gt;        &amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;Top&lt;&#x2F;span&gt;&lt;span&gt;&amp;quot;: {
&lt;&#x2F;span&gt;&lt;span&gt;            &amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;ports&lt;&#x2F;span&gt;&lt;span&gt;&amp;quot;: {
&lt;&#x2F;span&gt;&lt;span&gt;                &amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;a&lt;&#x2F;span&gt;&lt;span&gt;&amp;quot;: {
&lt;&#x2F;span&gt;&lt;span&gt;                    &amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;direction&lt;&#x2F;span&gt;&lt;span&gt;&amp;quot;: &amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;input&lt;&#x2F;span&gt;&lt;span&gt;&amp;quot;,
&lt;&#x2F;span&gt;&lt;span&gt;                    &amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;bits&lt;&#x2F;span&gt;&lt;span&gt;&amp;quot;: [&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;2&lt;&#x2F;span&gt;&lt;span&gt;]
&lt;&#x2F;span&gt;&lt;span&gt;                },
&lt;&#x2F;span&gt;&lt;span&gt;                &amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;b&lt;&#x2F;span&gt;&lt;span&gt;&amp;quot;: {
&lt;&#x2F;span&gt;&lt;span&gt;                    &amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;direction&lt;&#x2F;span&gt;&lt;span&gt;&amp;quot;: &amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;input&lt;&#x2F;span&gt;&lt;span&gt;&amp;quot;,
&lt;&#x2F;span&gt;&lt;span&gt;                    &amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;bits&lt;&#x2F;span&gt;&lt;span&gt;&amp;quot;: [&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;3&lt;&#x2F;span&gt;&lt;span&gt;]
&lt;&#x2F;span&gt;&lt;span&gt;                },
&lt;&#x2F;span&gt;&lt;span&gt;                &amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;port4_LUT4_Z&lt;&#x2F;span&gt;&lt;span&gt;&amp;quot;: {
&lt;&#x2F;span&gt;&lt;span&gt;                    &amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;direction&lt;&#x2F;span&gt;&lt;span&gt;&amp;quot;: &amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;output&lt;&#x2F;span&gt;&lt;span&gt;&amp;quot;,
&lt;&#x2F;span&gt;&lt;span&gt;                    &amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;bits&lt;&#x2F;span&gt;&lt;span&gt;&amp;quot;: [&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;4&lt;&#x2F;span&gt;&lt;span&gt;]
&lt;&#x2F;span&gt;&lt;span&gt;                }
&lt;&#x2F;span&gt;&lt;span&gt;            },
&lt;&#x2F;span&gt;&lt;span&gt;            &amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;cells&lt;&#x2F;span&gt;&lt;span&gt;&amp;quot;: {
&lt;&#x2F;span&gt;&lt;span&gt;                &amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;port4_LUT4&lt;&#x2F;span&gt;&lt;span&gt;&amp;quot;: {
&lt;&#x2F;span&gt;&lt;span&gt;                    &amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;type&lt;&#x2F;span&gt;&lt;span&gt;&amp;quot;: &amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;LUT4&lt;&#x2F;span&gt;&lt;span&gt;&amp;quot;,
&lt;&#x2F;span&gt;&lt;span&gt;                    &amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;parameters&lt;&#x2F;span&gt;&lt;span&gt;&amp;quot;: {
&lt;&#x2F;span&gt;&lt;span&gt;                        &amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;INIT&lt;&#x2F;span&gt;&lt;span&gt;&amp;quot;: &amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;1000100010001000&lt;&#x2F;span&gt;&lt;span&gt;&amp;quot;
&lt;&#x2F;span&gt;&lt;span&gt;                    },
&lt;&#x2F;span&gt;&lt;span&gt;                    &amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;port_directions&lt;&#x2F;span&gt;&lt;span&gt;&amp;quot;: {
&lt;&#x2F;span&gt;&lt;span&gt;                        &amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;A&lt;&#x2F;span&gt;&lt;span&gt;&amp;quot;: &amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;input&lt;&#x2F;span&gt;&lt;span&gt;&amp;quot;,
&lt;&#x2F;span&gt;&lt;span&gt;                        &amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;Z&lt;&#x2F;span&gt;&lt;span&gt;&amp;quot;: &amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;output&lt;&#x2F;span&gt;&lt;span&gt;&amp;quot;,
&lt;&#x2F;span&gt;&lt;span&gt;                        &amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;C&lt;&#x2F;span&gt;&lt;span&gt;&amp;quot;: &amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;input&lt;&#x2F;span&gt;&lt;span&gt;&amp;quot;,
&lt;&#x2F;span&gt;&lt;span&gt;                        &amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;B&lt;&#x2F;span&gt;&lt;span&gt;&amp;quot;: &amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;input&lt;&#x2F;span&gt;&lt;span&gt;&amp;quot;,
&lt;&#x2F;span&gt;&lt;span&gt;                        &amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;D&lt;&#x2F;span&gt;&lt;span&gt;&amp;quot;: &amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;input&lt;&#x2F;span&gt;&lt;span&gt;&amp;quot;
&lt;&#x2F;span&gt;&lt;span&gt;                    },
&lt;&#x2F;span&gt;&lt;span&gt;                    &amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;connections&lt;&#x2F;span&gt;&lt;span&gt;&amp;quot;: {
&lt;&#x2F;span&gt;&lt;span&gt;                        &amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;Z&lt;&#x2F;span&gt;&lt;span&gt;&amp;quot;: [&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;4&lt;&#x2F;span&gt;&lt;span&gt;],
&lt;&#x2F;span&gt;&lt;span&gt;                        &amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;A&lt;&#x2F;span&gt;&lt;span&gt;&amp;quot;: [&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;2&lt;&#x2F;span&gt;&lt;span&gt;],
&lt;&#x2F;span&gt;&lt;span&gt;                        &amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;D&lt;&#x2F;span&gt;&lt;span&gt;&amp;quot;: [&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;0&lt;&#x2F;span&gt;&lt;span&gt;],
&lt;&#x2F;span&gt;&lt;span&gt;                        &amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;B&lt;&#x2F;span&gt;&lt;span&gt;&amp;quot;: [&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;3&lt;&#x2F;span&gt;&lt;span&gt;],
&lt;&#x2F;span&gt;&lt;span&gt;                        &amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;C&lt;&#x2F;span&gt;&lt;span&gt;&amp;quot;: [&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;0&lt;&#x2F;span&gt;&lt;span&gt;]
&lt;&#x2F;span&gt;&lt;span&gt;                    }
&lt;&#x2F;span&gt;&lt;span&gt;                }
&lt;&#x2F;span&gt;&lt;span&gt;            },
&lt;&#x2F;span&gt;&lt;span&gt;            &amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;netnames&lt;&#x2F;span&gt;&lt;span&gt;&amp;quot;: {
&lt;&#x2F;span&gt;&lt;span&gt;                &amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;a&lt;&#x2F;span&gt;&lt;span&gt;&amp;quot;: {
&lt;&#x2F;span&gt;&lt;span&gt;                    &amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;bits&lt;&#x2F;span&gt;&lt;span&gt;&amp;quot;: [&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;2&lt;&#x2F;span&gt;&lt;span&gt;]
&lt;&#x2F;span&gt;&lt;span&gt;                },
&lt;&#x2F;span&gt;&lt;span&gt;                &amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;b&lt;&#x2F;span&gt;&lt;span&gt;&amp;quot;: {
&lt;&#x2F;span&gt;&lt;span&gt;                    &amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;bits&lt;&#x2F;span&gt;&lt;span&gt;&amp;quot;: [&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;3&lt;&#x2F;span&gt;&lt;span&gt;]
&lt;&#x2F;span&gt;&lt;span&gt;                },
&lt;&#x2F;span&gt;&lt;span&gt;                &amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;port4_LUT4_Z&lt;&#x2F;span&gt;&lt;span&gt;&amp;quot;: {
&lt;&#x2F;span&gt;&lt;span&gt;                    &amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;bits&lt;&#x2F;span&gt;&lt;span&gt;&amp;quot;: [&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;4&lt;&#x2F;span&gt;&lt;span&gt;]
&lt;&#x2F;span&gt;&lt;span&gt;                }
&lt;&#x2F;span&gt;&lt;span&gt;            }
&lt;&#x2F;span&gt;&lt;span&gt;        }
&lt;&#x2F;span&gt;&lt;span&gt;    }
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;然后居然就可以用 &lt;code&gt;nextpnr-ecp5&lt;&#x2F;code&gt; 搓出 &lt;code&gt;config&lt;&#x2F;code&gt; 文件，然后用 &lt;code&gt;ecppack&lt;&#x2F;code&gt; 做出 bit，然后把它烧录进 FPGA 里居然就可以用了。&lt;&#x2F;p&gt;
&lt;p&gt;我们居然这么容易就写出了一个能动的综合器。
接下来将会介绍更多逻辑综合的相关内容，预定会写更复杂逻辑函数的综合和时序逻辑电路的综合。&lt;&#x2F;p&gt;
</content>
	</entry>
	<entry xml:lang="zh">
		<title>macOS 用户也要玩 FPGA！</title>
		<published>2021-04-24T16:53:12.045+00:00</published>
		<updated>2021-04-24T16:53:12.045+00:00</updated>
		<link href="https://longfangsong.github.io/macos-fpga/" type="text/html"/>
		<id>https://longfangsong.github.io/macos-fpga/</id>
		<content type="html">&lt;p&gt;冲着能用开源工具链入了一块 iCESugar-Pro，本来想着如果 macOS 环境搞不定就下官方的虚拟机，结果居然给我配成了。&lt;&#x2F;p&gt;
&lt;h2 id=&quot;ise-vivado-quartus-de-que-dian&quot;&gt;ISE&#x2F;Vivado&#x2F;Quartus 的缺点&lt;&#x2F;h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;收费&lt;&#x2F;p&gt;
&lt;p&gt;我没钱。&lt;del&gt;我用盗版，我让国外资本主义巨头亏麻了，我骄傲。&lt;&#x2F;del&gt;&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;限定系统&lt;&#x2F;p&gt;
&lt;p&gt;首先，没有一个有 macOS 支持，其次 Linux 支持也不甚完整（Ubuntu 装 ISE 能强行装上，但基本跑不起来，官方支持列表里好像只有红帽，也许 centos 可以但我真的不是很喜欢这个发行版），基本上只有 Windows 能用……&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;命令行支持烂（IDE 还丑）&lt;&#x2F;p&gt;
&lt;p&gt;我就是想用 Vim&#x2F;VSCode 写 Verilog&#x2F;Chisel 然后用 Makefile 编译和下载啊！！！
谁想用那些个难看的不得了又卡交互逻辑又奇怪的 IDE 啊！！！
虽说技术上这几个设计工具都有命令行接口，但是资料和例子就基本没有了，好不容易看到一个官方的文档然后打开一看拿几千个选项甩你一脸……&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;对学习自动综合原理等没有帮助&lt;&#x2F;p&gt;
&lt;p&gt;看不了代码，学习，学个屁。
不过说实话我是希望有书能讲讲这个的……光看代码还是太痛苦了。&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;h2 id=&quot;kai-yuan-gong-ju-lian&quot;&gt;开源工具链&lt;&#x2F;h2&gt;
&lt;h3 id=&quot;claire-wolf-de-chuan-qi&quot;&gt;&lt;a href=&quot;http:&#x2F;&#x2F;www.clifford.at&#x2F;&quot;&gt;Claire Wolf&lt;&#x2F;a&gt; 的传奇&lt;&#x2F;h3&gt;
&lt;p&gt;这个人就是开源硬件世界里的 Richard Stallman&lt;sup class=&quot;footnote-reference&quot;&gt;&lt;a href=&quot;#1&quot;&gt;1&lt;&#x2F;a&gt;&lt;&#x2F;sup&gt;。&lt;&#x2F;p&gt;
&lt;p&gt;这个人 2012 年几乎单枪匹马做出了开源 Verilog 逻辑综合工具 &lt;a href=&quot;http:&#x2F;&#x2F;www.clifford.at&#x2F;yosys&#x2F;&quot;&gt;Yosys&lt;&#x2F;a&gt;。&lt;&#x2F;p&gt;
&lt;p&gt;2015 年（也是几乎单枪匹马）做出了开源 RISC-V 核 &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;cliffordwolf&#x2F;picorv32&quot;&gt;picorv32&lt;&#x2F;a&gt;。&lt;&#x2F;p&gt;
&lt;p&gt;同年开始 &lt;a href=&quot;http:&#x2F;&#x2F;www.clifford.at&#x2F;icestorm&#x2F;&quot;&gt;icestorm&lt;&#x2F;a&gt; 项目，开始针对 Lattice FPGA 整合整条开源工具链。&lt;&#x2F;p&gt;
&lt;p&gt;2018 年，开始 FPGA 布局布线工具项目 &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;YosysHQ&#x2F;nextpnr&quot;&gt;nextpnr&lt;&#x2F;a&gt;。&lt;&#x2F;p&gt;
&lt;p&gt;总之一句话，开源 FPGA 界的基础软件基本上是这个人一个人打的基础。&lt;&#x2F;p&gt;
&lt;p&gt;看完这个人的经历之后我只想用一个表情包表达我的心情：&lt;&#x2F;p&gt;
&lt;p&gt;我也能，像他一样吗.jpg （不会 PS 所以表情包请自行脑补 😄）&lt;&#x2F;p&gt;
&lt;p&gt;说了那么多我们还是看看这些工具怎么用吧，毕竟我现在也就只能用用这些工具了，离去开发这些东西还太远😭。&lt;&#x2F;p&gt;
&lt;h3 id=&quot;yosys-zong-he-gong-ju&quot;&gt;Yosys 综合工具&lt;&#x2F;h3&gt;
&lt;p&gt;虽然说 &lt;code&gt;brew&lt;&#x2F;code&gt; 可以装上，但是那个版本太老了，和其他工具（比如 &lt;code&gt;nextpnr&lt;&#x2F;code&gt;）配合使用会出问题。&lt;&#x2F;p&gt;
&lt;h4 id=&quot;clone-dai-ma&quot;&gt;clone 代码&lt;&#x2F;h4&gt;
&lt;pre data-lang=&quot;sh&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-sh &quot;&gt;&lt;code class=&quot;language-sh&quot; data-lang=&quot;sh&quot;&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;git&lt;&#x2F;span&gt;&lt;span&gt; clone https:&#x2F;&#x2F;github.com&#x2F;YosysHQ&#x2F;yosys.git
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;h4 id=&quot;zhuang-yi-lai&quot;&gt;装依赖&lt;&#x2F;h4&gt;
&lt;p&gt;&lt;code&gt;yosys&lt;&#x2F;code&gt; 提供了 &lt;code&gt;Brewfile&lt;&#x2F;code&gt;，像官方说的：&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;sh&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-sh &quot;&gt;&lt;code class=&quot;language-sh&quot; data-lang=&quot;sh&quot;&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;brew&lt;&#x2F;span&gt;&lt;span&gt; tap Homebrew&#x2F;bundle &amp;amp;&amp;amp; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;brew&lt;&#x2F;span&gt;&lt;span&gt; bundle
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;就好了&lt;sup class=&quot;footnote-reference&quot;&gt;&lt;a href=&quot;#2&quot;&gt;2&lt;&#x2F;a&gt;&lt;&#x2F;sup&gt;。&lt;&#x2F;p&gt;
&lt;h4 id=&quot;make&quot;&gt;make&lt;&#x2F;h4&gt;
&lt;pre data-lang=&quot;sh&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-sh &quot;&gt;&lt;code class=&quot;language-sh&quot; data-lang=&quot;sh&quot;&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;make -j&lt;&#x2F;span&gt;&lt;span&gt;$&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;(nproc)
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;make&lt;&#x2F;span&gt;&lt;span&gt; install
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;h4 id=&quot;shi-yong&quot;&gt;使用&lt;&#x2F;h4&gt;
&lt;p&gt;&lt;code&gt;yosys&lt;&#x2F;code&gt; 可以通过 &lt;code&gt;-p&lt;&#x2F;code&gt; 参数接受一个 “综合脚本”，或者通过 &lt;code&gt;-s&lt;&#x2F;code&gt; 接受综合脚本文件，或者不加任何参数的话可以直接 &lt;code&gt;yosys&lt;&#x2F;code&gt; 一个命令直接 REPL 执行，目前我已知的脚本命令有：&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;read_verilog&lt;&#x2F;code&gt;&lt;&#x2F;p&gt;
&lt;p&gt;用于读取 verilog 文件。&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;synth_ecp5&lt;&#x2F;code&gt;&lt;&#x2F;p&gt;
&lt;p&gt;用于实际综合，传入 &lt;code&gt;-json&lt;&#x2F;code&gt; 来获取 json 格式的输出。&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;例如：&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;sh&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-sh &quot;&gt;&lt;code class=&quot;language-sh&quot; data-lang=&quot;sh&quot;&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;yosys -p &lt;&#x2F;span&gt;&lt;span&gt;&amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;read_verilog blink.v; read_verilog rst_gen.v; synth_ecp5 -json main.json&lt;&#x2F;span&gt;&lt;span&gt;&amp;quot;
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;或者也可以写成：&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;sh&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-sh &quot;&gt;&lt;code class=&quot;language-sh&quot; data-lang=&quot;sh&quot;&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;yosys -p &lt;&#x2F;span&gt;&lt;span&gt;&amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;synth_ecp5 -json main.json&lt;&#x2F;span&gt;&lt;span&gt;&amp;quot; blink.v rst_gen.v
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;h3 id=&quot;nextpnr-bu-ju-bu-xian-gong-ju&quot;&gt;nextpnr 布局布线工具&lt;&#x2F;h3&gt;
&lt;h4 id=&quot;clone-dai-ma-1&quot;&gt;clone 代码&lt;&#x2F;h4&gt;
&lt;pre data-lang=&quot;sh&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-sh &quot;&gt;&lt;code class=&quot;language-sh&quot; data-lang=&quot;sh&quot;&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;git&lt;&#x2F;span&gt;&lt;span&gt; clone https:&#x2F;&#x2F;github.com&#x2F;YosysHQ&#x2F;nextpnr.git
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;h4 id=&quot;an-zhuang-trellis-zu-jian-yu-gong-ju-ku&quot;&gt;安装 Trellis 组件与工具库&lt;&#x2F;h4&gt;
&lt;p&gt;Trellis 组件库与工具库为 nextpnr 提供了 Lattice ECP5 的组件库以及用于生成 bitstream 的 &lt;code&gt;ecppack&lt;&#x2F;code&gt; 工具。&lt;&#x2F;p&gt;
&lt;h5 id=&quot;clone-dai-ma-2&quot;&gt;clone 代码&lt;&#x2F;h5&gt;
&lt;pre data-lang=&quot;sh&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-sh &quot;&gt;&lt;code class=&quot;language-sh&quot; data-lang=&quot;sh&quot;&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;git&lt;&#x2F;span&gt;&lt;span&gt; clone&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt; --recursive&lt;&#x2F;span&gt;&lt;span&gt; https:&#x2F;&#x2F;github.com&#x2F;YosysHQ&#x2F;prjtrellis
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;h5 id=&quot;make-1&quot;&gt;make&lt;&#x2F;h5&gt;
&lt;pre data-lang=&quot;sh&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-sh &quot;&gt;&lt;code class=&quot;language-sh&quot; data-lang=&quot;sh&quot;&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;cd&lt;&#x2F;span&gt;&lt;span&gt; libtrellis
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;# 就算 sudo 了也不能装在 &#x2F;usr 里，直接跟着 brew 装 &#x2F;usr&#x2F;local 里就行
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;cmake -DCMAKE_INSTALL_PREFIX&lt;&#x2F;span&gt;&lt;span&gt;=&#x2F;usr&#x2F;local .
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;make -j&lt;&#x2F;span&gt;&lt;span&gt;$&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;(nproc)
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;sudo&lt;&#x2F;span&gt;&lt;span&gt; make install
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;h4 id=&quot;make-2&quot;&gt;make&lt;&#x2F;h4&gt;
&lt;p&gt;在克隆下来的 &lt;code&gt;nextpnr&lt;&#x2F;code&gt; 仓库下：&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;sh&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-sh &quot;&gt;&lt;code class=&quot;language-sh&quot; data-lang=&quot;sh&quot;&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;cmake&lt;&#x2F;span&gt;&lt;span&gt; .&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt; -DARCH&lt;&#x2F;span&gt;&lt;span&gt;=ecp5&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt; -DTRELLIS_INSTALL_PREFIX&lt;&#x2F;span&gt;&lt;span&gt;=&#x2F;usr&#x2F;local
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;make -j&lt;&#x2F;span&gt;&lt;span&gt;$&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;(nproc)
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;sudo&lt;&#x2F;span&gt;&lt;span&gt; make install
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;h4 id=&quot;shi-yong-1&quot;&gt;使用&lt;&#x2F;h4&gt;
&lt;pre data-lang=&quot;sh&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-sh &quot;&gt;&lt;code class=&quot;language-sh&quot; data-lang=&quot;sh&quot;&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;nextpnr-ecp5&lt;&#x2F;span&gt;&lt;span&gt; --&amp;lt;型号&amp;gt; --package &amp;lt;封装&amp;gt; --json &amp;lt;刚刚综合出来的 JSON&amp;gt; --lpf &amp;lt;引脚分配文件&amp;gt; --textcfg &amp;lt;输出到 config 文件&amp;gt;
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;iCESugar-Pro 上的 FPGA 型号是 &lt;code&gt;25k&lt;&#x2F;code&gt;，封装方式是 &lt;code&gt;CABGA256&lt;&#x2F;code&gt;。&lt;&#x2F;p&gt;
&lt;h5 id=&quot;lpf-wen-jian&quot;&gt;LPF 文件&lt;&#x2F;h5&gt;
&lt;p&gt;主要使用下面几个命令：&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;LOCATE&lt;&#x2F;code&gt;&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;lpf&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-lpf &quot;&gt;&lt;code class=&quot;language-lpf&quot; data-lang=&quot;lpf&quot;&gt;&lt;span&gt;LOCATE COMP &amp;quot;&amp;lt;代码内名称&amp;gt;&amp;quot; SITE &amp;quot;&amp;lt;硬件手册上的编号&amp;gt;&amp;quot;;
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;例如：&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;lpf&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-lpf &quot;&gt;&lt;code class=&quot;language-lpf&quot; data-lang=&quot;lpf&quot;&gt;&lt;span&gt;LOCATE COMP &amp;quot;clk&amp;quot; SITE &amp;quot;A1&amp;quot;;
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;h3 id=&quot;ecppack-bitstream-sheng-cheng-qi&quot;&gt;ecppack bitstream 生成器&lt;&#x2F;h3&gt;
&lt;p&gt;&lt;code&gt;ecppack&lt;&#x2F;code&gt; 是 Trellis 组件与工具库的一部分，前面已经安装好了。&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;sh&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-sh &quot;&gt;&lt;code class=&quot;language-sh&quot; data-lang=&quot;sh&quot;&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;ecppack &lt;&#x2F;span&gt;&lt;span&gt;&amp;lt;config 文件&amp;gt; --bit &amp;lt;目标 .bit 文件&amp;gt;
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;h3 id=&quot;xia-zai&quot;&gt;下载&lt;&#x2F;h3&gt;
&lt;p&gt;iCESugar-Pro 连到电脑上就一U盘，可以直接拖！拽！下！载！作者太 tmd 良心了！！！&lt;&#x2F;p&gt;
&lt;div class=&quot;footnote-definition&quot; id=&quot;1&quot;&gt;&lt;sup class=&quot;footnote-definition-label&quot;&gt;1&lt;&#x2F;sup&gt;
&lt;p&gt;比 RMS nb 的是，Claire Wolf 是一位 MTF，政治正确的一匹。&lt;&#x2F;p&gt;
&lt;&#x2F;div&gt;
&lt;div class=&quot;footnote-definition&quot; id=&quot;2&quot;&gt;&lt;sup class=&quot;footnote-definition-label&quot;&gt;2&lt;&#x2F;sup&gt;
&lt;p&gt;在 GFW 内约耗时一个世纪。&lt;&#x2F;p&gt;
&lt;&#x2F;div&gt;
</content>
	</entry>
	<entry xml:lang="zh">
		<title>RoCC RISC-V 扩展方案</title>
		<published>2021-04-19T15:45:33.706+00:00</published>
		<updated>2021-04-19T15:45:33.706+00:00</updated>
		<link href="https://longfangsong.github.io/riscv-rocc/" type="text/html"/>
		<id>https://longfangsong.github.io/riscv-rocc/</id>
		<content type="html">&lt;p&gt;RoCC 是通过向 RISC-V 处理器添加扩展的半官方&lt;sup class=&quot;footnote-reference&quot;&gt;&lt;a href=&quot;#1&quot;&gt;1&lt;&#x2F;a&gt;&lt;&#x2F;sup&gt;方案，最早用于 BSD 的 Rocket-core。&lt;&#x2F;p&gt;
&lt;h2 id=&quot;rocc-gui-ding-de-kuo-zhan-zhi-ling&quot;&gt;RoCC 规定的扩展指令&lt;&#x2F;h2&gt;
&lt;p&gt;RoCC 使用了 RISCV 标准中预留的所有四个扩展槽位，并规定了如下指令格式：&lt;&#x2F;p&gt;
&lt;p&gt;&lt;img src=&quot;.&#x2F;rocc-inst.png&quot; alt=&quot;RoCC inst&quot; &#x2F;&gt;&lt;&#x2F;p&gt;
&lt;p&gt;其中 &lt;code&gt;xd&lt;&#x2F;code&gt;、&lt;code&gt;xs1&lt;&#x2F;code&gt;、&lt;code&gt;xs2&lt;&#x2F;code&gt; 分别表示对应的寄存器是否被使用到了。&lt;&#x2F;p&gt;
&lt;h2 id=&quot;rocc-he-cpu-zhi-jian-de-jiao-hu&quot;&gt;RoCC 和 CPU 之间的交互&lt;&#x2F;h2&gt;
&lt;p&gt;RoCC 主要通过如下接口和 CPU 进行交互：&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;CPU 通过 &lt;code&gt;Cmd&lt;&#x2F;code&gt; 接口将指令和相关寄存器的值发送给 RoCC 加速器&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;RoCC 加速器通过 &lt;code&gt;Resp&lt;&#x2F;code&gt; 接口将计算结果（要写入的寄存器号和值）返回到 CPU&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;RoCC 通过 &lt;code&gt;busy&lt;&#x2F;code&gt; 标记加速器是否处于忙状态&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;RoCC 自身也可以访问内存、引发中断等&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;div class=&quot;footnote-definition&quot; id=&quot;1&quot;&gt;&lt;sup class=&quot;footnote-definition-label&quot;&gt;1&lt;&#x2F;sup&gt;
&lt;p&gt;指由 RISC-V 亲爹 BSD 研发。&lt;&#x2F;p&gt;
&lt;&#x2F;div&gt;
</content>
	</entry>
	<entry xml:lang="zh">
		<title>内联汇编 cheatsheet</title>
		<published>2021-04-18T07:34:52.996+00:00</published>
		<updated>2021-04-18T07:34:52.996+00:00</updated>
		<link href="https://longfangsong.github.io/inline-asm-cheatsheet/" type="text/html"/>
		<id>https://longfangsong.github.io/inline-asm-cheatsheet/</id>
		<content type="html">&lt;h2 id=&quot;ji-ben-yu-fa-mo-ban&quot;&gt;基本语法模版&lt;&#x2F;h2&gt;
&lt;pre data-lang=&quot;c&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-c &quot;&gt;&lt;code class=&quot;language-c&quot; data-lang=&quot;c&quot;&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;asm&lt;&#x2F;span&gt;&lt;span&gt;(
&lt;&#x2F;span&gt;&lt;span&gt;    &amp;lt;代码&amp;gt;:
&lt;&#x2F;span&gt;&lt;span&gt;    &amp;lt;输出到哪些变量&amp;gt;:
&lt;&#x2F;span&gt;&lt;span&gt;    &amp;lt;从哪些变量输入&amp;gt;:
&lt;&#x2F;span&gt;&lt;span&gt;    &amp;lt;副作用会影响什么&amp;gt;
&lt;&#x2F;span&gt;&lt;span&gt;)
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;其中每个值如果有多个的话都是用逗号分隔。&lt;&#x2F;p&gt;
&lt;h3 id=&quot;shu-ru-shu-chu-bian-liang&quot;&gt;输入输出变量&lt;&#x2F;h3&gt;
&lt;p&gt;输入输出变量的常用格式为：&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;c&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-c &quot;&gt;&lt;code class=&quot;language-c&quot; data-lang=&quot;c&quot;&gt;&lt;span&gt;&amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;&amp;lt;修饰符&amp;gt;&amp;lt;约束&amp;gt;&lt;&#x2F;span&gt;&lt;span&gt;&amp;quot;(&amp;lt;变量&amp;gt;)
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;h4 id=&quot;yue-shu&quot;&gt;约束&lt;&#x2F;h4&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;r&lt;&#x2F;code&gt;
指代某个通用寄存器&lt;&#x2F;li&gt;
&lt;li&gt;&lt;code&gt;m&lt;&#x2F;code&gt;
指代某个变量的内存地址, 后面的括号填入的是变量本身而非变量地址&lt;&#x2F;li&gt;
&lt;li&gt;&lt;code&gt;i&lt;&#x2F;code&gt;
指代某个立即数&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;h4 id=&quot;xiu-shi-fu&quot;&gt;修饰符&lt;&#x2F;h4&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;=&lt;&#x2F;code&gt;
指这个变量&#x2F;寄存器被写入了，一般所有输出变量都会带上这个。&lt;&#x2F;li&gt;
&lt;li&gt;&lt;code&gt;+&lt;&#x2F;code&gt;
指这个变量&#x2F;寄存器被读取和写入了&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;h3 id=&quot;fu-zuo-yong-hui-ying-xiang-shi-yao&quot;&gt;副作用会影响什么&lt;&#x2F;h3&gt;
&lt;p&gt;这里一般就填一些标记寄存器和 &lt;code&gt;memory&lt;&#x2F;code&gt;。&lt;&#x2F;p&gt;
</content>
	</entry>
	<entry xml:lang="zh">
		<title>Hack RISC-V 指令集</title>
		<published>2021-04-17T07:34:52.996+00:00</published>
		<updated>2021-04-17T07:34:52.996+00:00</updated>
		<link href="https://longfangsong.github.io/hack-riscv-isa/" type="text/html"/>
		<id>https://longfangsong.github.io/hack-riscv-isa/</id>
		<content type="html">&lt;h2 id=&quot;huan-jing&quot;&gt;环境&lt;&#x2F;h2&gt;
&lt;p&gt;本文假设用户使用基于 debian 的 Linux 系统，有 &lt;code&gt;su&lt;&#x2F;code&gt; 或者 &lt;code&gt;sudo&lt;&#x2F;code&gt; 的能力&lt;sup class=&quot;footnote-reference&quot;&gt;&lt;a href=&quot;#1&quot;&gt;1&lt;&#x2F;a&gt;&lt;&#x2F;sup&gt;，并且用的文件系统是区分大小写&lt;sup class=&quot;footnote-reference&quot;&gt;&lt;a href=&quot;#2&quot;&gt;2&lt;&#x2F;a&gt;&lt;&#x2F;sup&gt;的。&lt;&#x2F;p&gt;
&lt;p&gt;然后请事先安装 &lt;code&gt;git&lt;&#x2F;code&gt; 以及任意文本编辑器。&lt;&#x2F;p&gt;
&lt;h2 id=&quot;gnu-bian-yi-gong-ju-lian&quot;&gt;GNU 编译工具链&lt;&#x2F;h2&gt;
&lt;h3 id=&quot;clone-dai-ma&quot;&gt;clone 代码&lt;&#x2F;h3&gt;
&lt;pre data-lang=&quot;sh&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-sh &quot;&gt;&lt;code class=&quot;language-sh&quot; data-lang=&quot;sh&quot;&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;git&lt;&#x2F;span&gt;&lt;span&gt; clone https:&#x2F;&#x2F;github.com&#x2F;riscv&#x2F;riscv-gnu-toolchain
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;然后进入 clone 到的文件夹中。&lt;&#x2F;p&gt;
&lt;h3 id=&quot;zhuang-yi-lai&quot;&gt;装依赖&lt;&#x2F;h3&gt;
&lt;pre data-lang=&quot;sh&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-sh &quot;&gt;&lt;code class=&quot;language-sh&quot; data-lang=&quot;sh&quot;&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;apt-get&lt;&#x2F;span&gt;&lt;span&gt; install autoconf automake autotools-dev curl python3 libmpc-dev libmpfr-dev libgmp-dev gawk build-essential bison flex texinfo gperf libtool patchutils bc zlib1g-dev libexpat-dev
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;h3 id=&quot;zhun-bei-yao-an-zhuang-dao-de-wei-zhi&quot;&gt;准备要安装到的位置&lt;&#x2F;h3&gt;
&lt;p&gt;比如要把工具链装到 &lt;code&gt;&#x2F;opt&#x2F;riscv&lt;&#x2F;code&gt; 下的话：&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;sh&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-sh &quot;&gt;&lt;code class=&quot;language-sh&quot; data-lang=&quot;sh&quot;&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;mkdir&lt;&#x2F;span&gt;&lt;span&gt; &#x2F;opt&#x2F;riscv
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;chmod&lt;&#x2F;span&gt;&lt;span&gt; 777 &#x2F;opt&#x2F;riscv &lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;# just use 777, who cares about bad guys?
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;h3 id=&quot;configure&quot;&gt;&lt;code&gt;configure&lt;&#x2F;code&gt;&lt;&#x2F;h3&gt;
&lt;pre data-lang=&quot;sh&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-sh &quot;&gt;&lt;code class=&quot;language-sh&quot; data-lang=&quot;sh&quot;&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;.&#x2F;configure --prefix&lt;&#x2F;span&gt;&lt;span&gt;=&#x2F;opt&#x2F;riscv&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt; --enable-multilib
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;h3 id=&quot;make&quot;&gt;&lt;code&gt;make&lt;&#x2F;code&gt;&lt;&#x2F;h3&gt;
&lt;pre data-lang=&quot;sh&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-sh &quot;&gt;&lt;code class=&quot;language-sh&quot; data-lang=&quot;sh&quot;&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;make
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;One eternity later ...&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;sh&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-sh &quot;&gt;&lt;code class=&quot;language-sh&quot; data-lang=&quot;sh&quot;&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;make&lt;&#x2F;span&gt;&lt;span&gt; linux
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Two eternities later ...&lt;&#x2F;p&gt;
&lt;p&gt;注意每次 &lt;code&gt;make&lt;&#x2F;code&gt; 的时候都会下载对应的 &lt;code&gt;submodule&lt;&#x2F;code&gt;，请保证有正常的网络环境。&lt;&#x2F;p&gt;
&lt;p&gt;然后 &lt;code&gt;&#x2F;opt&#x2F;riscv&lt;&#x2F;code&gt; 里就有编译器、lib 等等了。&lt;&#x2F;p&gt;
&lt;h3 id=&quot;tian-jia-zi-ding-yi-zhi-ling&quot;&gt;添加自定义指令&lt;&#x2F;h3&gt;
&lt;p&gt;编辑 &lt;code&gt;riscv-binutils&#x2F;opcodes&#x2F;riscv-opc.c&lt;&#x2F;code&gt;，在 &lt;code&gt;riscv_opcodes&lt;&#x2F;code&gt; 中加入新的指令:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;c&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-c &quot;&gt;&lt;code class=&quot;language-c&quot; data-lang=&quot;c&quot;&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;    &amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;&amp;lt;指令名称&amp;gt;&lt;&#x2F;span&gt;&lt;span&gt;&amp;quot;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;0&lt;&#x2F;span&gt;&lt;span&gt;, &amp;lt;指令类型&amp;gt;, &amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;&amp;lt;操作数&amp;gt;&lt;&#x2F;span&gt;&lt;span&gt;&amp;quot;, 
&lt;&#x2F;span&gt;&lt;span&gt;    &amp;lt;匹配&amp;gt;, &amp;lt;掩码&amp;gt;, match_opcode, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;0
&lt;&#x2F;span&gt;&lt;span&gt;},
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;代表使用时形如：&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;asm&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-asm &quot;&gt;&lt;code class=&quot;language-asm&quot; data-lang=&quot;asm&quot;&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;&amp;lt;指令名称&amp;gt; &amp;lt;操作数&amp;gt;
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;的一条汇编指令。&lt;&#x2F;p&gt;
&lt;h4 id=&quot;zhi-ling-lei-xing&quot;&gt;指令类型&lt;&#x2F;h4&gt;
&lt;p&gt;建议无脑给 &lt;code&gt;INSN_CLASS_I&lt;&#x2F;code&gt;, 因为 &lt;code&gt;I&lt;&#x2F;code&gt; 在所有情况下都是支持的，无需在编译时手动开启各个指令集。&lt;&#x2F;p&gt;
&lt;p&gt;暂时不清楚是否支持在 &lt;code&gt;include&#x2F;opcode&#x2F;riscv.h&lt;&#x2F;code&gt; 中的 &lt;code&gt;riscv_insn_class&lt;&#x2F;code&gt; 中添加自己的指令集名称，然后在这里使用。&lt;&#x2F;p&gt;
&lt;h4 id=&quot;cao-zuo-shu&quot;&gt;操作数&lt;&#x2F;h4&gt;
&lt;p&gt;这我一直没找到一个说明的文档，只有根据已经写好的部分和代码（代码在 &lt;code&gt;riscv-binutils&#x2F;gas&#x2F;config&#x2F;tc-riscv.c&lt;&#x2F;code&gt;）推了&lt;sup class=&quot;footnote-reference&quot;&gt;&lt;a href=&quot;#3&quot;&gt;3&lt;&#x2F;a&gt;&lt;&#x2F;sup&gt;：&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;d&lt;&#x2F;code&gt;
代表目标寄存器&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;s&lt;&#x2F;code&gt;
代表第一个寄存器操作数&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;t&lt;&#x2F;code&gt;
代表第二个寄存器操作数&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;j&lt;&#x2F;code&gt;
代表一个立即数&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;o(s)&lt;&#x2F;code&gt;
代表用于读取出来的一个地址，格式为寄存器 + 偏移量&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;q(s)&lt;&#x2F;code&gt;
代表用于写入进去的一个地址，格式为寄存器 + 偏移量&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;&amp;lt;&lt;&#x2F;code&gt; 和 &lt;code&gt;&amp;gt;&lt;&#x2F;code&gt;
代表移位的位数&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;h5 id=&quot;ke-zhi-ji-cun-qi&quot;&gt;客制寄存器&lt;&#x2F;h5&gt;
&lt;p&gt;这里假设你希望在内联汇编里手写寄存器而不是让 gcc 为你分配你的客制寄存器，比如你希望添加一个读取矩阵的指令：&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;c&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-c &quot;&gt;&lt;code class=&quot;language-c&quot; data-lang=&quot;c&quot;&gt;&lt;span&gt;{&amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;matload&lt;&#x2F;span&gt;&lt;span&gt;&amp;quot;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;0&lt;&#x2F;span&gt;&lt;span&gt;, INSN_CLASS_I, &amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;Md,o(s)&lt;&#x2F;span&gt;&lt;span&gt;&amp;quot;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;0x100b&lt;&#x2F;span&gt;&lt;span&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;0x707f&lt;&#x2F;span&gt;&lt;span&gt;, match_opcode, INSN_DREF},
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;这里的 &lt;code&gt;Md&lt;&#x2F;code&gt; 代表一个矩阵寄存器。&lt;&#x2F;p&gt;
&lt;p&gt;那么你需要在 gnu 工具链中进行如下修改：&lt;&#x2F;p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;在 &lt;code&gt;riscv-binutils&#x2F;opcodes&#x2F;riscv-opc.c&lt;&#x2F;code&gt; 中的 &lt;code&gt;riscv_fpr_names_abi&lt;&#x2F;code&gt; 下面，添加一个新的数组，保存你的各个寄存器的名字，并在 &lt;code&gt;riscv-binutils&#x2F;include&#x2F;opcode&#x2F;riscv.h&lt;&#x2F;code&gt; 添加相应的声明，例如：&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;c&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-c &quot;&gt;&lt;code class=&quot;language-c&quot; data-lang=&quot;c&quot;&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;&#x2F;&#x2F; riscv.h
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;extern const char &lt;&#x2F;span&gt;&lt;span&gt;*&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;const&lt;&#x2F;span&gt;&lt;span&gt; riscv_mat_names_numeric[&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;8&lt;&#x2F;span&gt;&lt;span&gt;];
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;pre data-lang=&quot;c&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-c &quot;&gt;&lt;code class=&quot;language-c&quot; data-lang=&quot;c&quot;&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;&#x2F;&#x2F; riscv-opc.c
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;const char &lt;&#x2F;span&gt;&lt;span&gt;* &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;const&lt;&#x2F;span&gt;&lt;span&gt; riscv_mat_names_numeric[&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;8&lt;&#x2F;span&gt;&lt;span&gt;] ={&amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;mat0&lt;&#x2F;span&gt;&lt;span&gt;&amp;quot;, &amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;mat1&lt;&#x2F;span&gt;&lt;span&gt;&amp;quot;, &amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;mat2&lt;&#x2F;span&gt;&lt;span&gt;&amp;quot;, &amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;mat3&lt;&#x2F;span&gt;&lt;span&gt;&amp;quot;, &amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;mat4&lt;&#x2F;span&gt;&lt;span&gt;&amp;quot;, &amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;mat5&lt;&#x2F;span&gt;&lt;span&gt;&amp;quot;, &amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;mat6&lt;&#x2F;span&gt;&lt;span&gt;&amp;quot;, &amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;mat7&lt;&#x2F;span&gt;&lt;span&gt;&amp;quot;};
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;在 &lt;code&gt;reg_class&lt;&#x2F;code&gt; （在 &lt;code&gt;riscv-binutils&#x2F;gas&#x2F;config&#x2F;tc-riscv.c&lt;&#x2F;code&gt;）中添加这个客制寄存器集的“名称”：&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;diff&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-diff &quot;&gt;&lt;code class=&quot;language-diff&quot; data-lang=&quot;diff&quot;&gt;&lt;span&gt;enum reg_class
&lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;  RCLASS_GPR,
&lt;&#x2F;span&gt;&lt;span&gt;  RCLASS_FPR,
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;+ RCLASS_MPR,
&lt;&#x2F;span&gt;&lt;span&gt;  RCLASS_MAX,
&lt;&#x2F;span&gt;&lt;span&gt;  RCLASS_CSR
&lt;&#x2F;span&gt;&lt;span&gt;};
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;在同一文件下负责汇编器初始化的 &lt;code&gt;md_begin&lt;&#x2F;code&gt; 函数中注册这个客制寄存器集：&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;c&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-c &quot;&gt;&lt;code class=&quot;language-c&quot; data-lang=&quot;c&quot;&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;hash_reg_names&lt;&#x2F;span&gt;&lt;span&gt;(RCLASS_MPR, riscv_mat_names_numeric, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;8&lt;&#x2F;span&gt;&lt;span&gt;);
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;在同一文件下检查 RISC-V 指令格式的 &lt;code&gt;validate_riscv_insn&lt;&#x2F;code&gt; 函数中个的最大的那个 &lt;code&gt;switch&lt;&#x2F;code&gt; 中添加对这个寄存器参数的检查。&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;在同一文件下负责进行实际汇编到二进制代码的 &lt;code&gt;riscv_ip&lt;&#x2F;code&gt; 函数中添加生成二进制代码的代码。&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
&lt;p&gt;到此你的编译器已经能正常生成二进制代码了，但是如果你还想要用 &lt;code&gt;objdump&lt;&#x2F;code&gt; 之类的反编译工具：&lt;&#x2F;p&gt;
&lt;ol start=&quot;6&quot;&gt;
&lt;li&gt;在 &lt;code&gt;riscv-binutils&#x2F;opcodes&#x2F;riscv-dis.c&lt;&#x2F;code&gt; 中的 &lt;code&gt;print_insn_args&lt;&#x2F;code&gt; 中也添加相关解析代码。&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
&lt;h4 id=&quot;pi-pei-he-yan-ma&quot;&gt;匹配和掩码&lt;&#x2F;h4&gt;
&lt;p&gt;设有一条二进制指令 &lt;code&gt;instruction&lt;&#x2F;code&gt;, 若：&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;c&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-c &quot;&gt;&lt;code class=&quot;language-c&quot; data-lang=&quot;c&quot;&gt;&lt;span&gt;instruction &amp;amp; 掩码 == 匹配
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;则认为 &lt;code&gt;instruction&lt;&#x2F;code&gt; 是这一类的指令。&lt;&#x2F;p&gt;
&lt;h4 id=&quot;zhong-xin-bian-yi&quot;&gt;重新编译&lt;&#x2F;h4&gt;
&lt;p&gt;重新编译工具链需要 &lt;code&gt;make clean&lt;&#x2F;code&gt;，删空安装位置（如 &lt;code&gt;&#x2F;opt&#x2F;riscv&lt;&#x2F;code&gt;），然后重新 &lt;code&gt;make&lt;&#x2F;code&gt;&lt;sup class=&quot;footnote-reference&quot;&gt;&lt;a href=&quot;#4&quot;&gt;4&lt;&#x2F;a&gt;&lt;&#x2F;sup&gt;。&lt;&#x2F;p&gt;
&lt;h3 id=&quot;shi-yong&quot;&gt;使用&lt;&#x2F;h3&gt;
&lt;p&gt;然后就能在汇编里拿 &lt;code&gt;asm&lt;&#x2F;code&gt; 用你刚刚加的指令了。&lt;&#x2F;p&gt;
&lt;p&gt;如果你不是很懂内联汇编&lt;sup class=&quot;footnote-reference&quot;&gt;&lt;a href=&quot;#5&quot;&gt;5&lt;&#x2F;a&gt;&lt;&#x2F;sup&gt;，可以看看我的&lt;a href=&quot;https:&#x2F;&#x2F;longfangsong.github.io&#x2F;inline-asm-cheatsheet&#x2F;&quot;&gt;另一篇文章&lt;&#x2F;a&gt;。&lt;&#x2F;p&gt;
&lt;h2 id=&quot;risc-v-tools&quot;&gt;RISC-V tools&lt;&#x2F;h2&gt;
&lt;p&gt;我们主要使用 RISC-V tools 中的 RISC-V 行为级模拟器 —— spike。&lt;&#x2F;p&gt;
&lt;h3 id=&quot;clone-dai-ma-1&quot;&gt;clone 代码&lt;&#x2F;h3&gt;
&lt;pre data-lang=&quot;sh&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-sh &quot;&gt;&lt;code class=&quot;language-sh&quot; data-lang=&quot;sh&quot;&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;git&lt;&#x2F;span&gt;&lt;span&gt; clone https:&#x2F;&#x2F;github.com&#x2F;riscv&#x2F;riscv-tools.git
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;然后进入 clone 到的文件夹中。&lt;&#x2F;p&gt;
&lt;p&gt;与 GNU 工具链在 &lt;code&gt;make&lt;&#x2F;code&gt; 的时候会自动拿 submodule 不同，tools 这边要手动：&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;sh&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-sh &quot;&gt;&lt;code class=&quot;language-sh&quot; data-lang=&quot;sh&quot;&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;git&lt;&#x2F;span&gt;&lt;span&gt; submodule update&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt; --init --recursive
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;此外建议把我们重点要修改的 &lt;code&gt;riscv-isa-sim&lt;&#x2F;code&gt; 手动更新到 origin master 版本：&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;sh&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-sh &quot;&gt;&lt;code class=&quot;language-sh&quot; data-lang=&quot;sh&quot;&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;cd&lt;&#x2F;span&gt;&lt;span&gt; riscv-isa-sim
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;git&lt;&#x2F;span&gt;&lt;span&gt; pull origin master
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;h3 id=&quot;zhi-ding-an-zhuang-di-zhi&quot;&gt;指定安装地址&lt;&#x2F;h3&gt;
&lt;pre data-lang=&quot;sh&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-sh &quot;&gt;&lt;code class=&quot;language-sh&quot; data-lang=&quot;sh&quot;&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;export &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;RISCV&lt;&#x2F;span&gt;&lt;span&gt;=&amp;lt;安装地址&amp;gt;
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;h3 id=&quot;build&quot;&gt;build&lt;&#x2F;h3&gt;
&lt;p&gt;如果你按照官方说明直接在 clone 到的文件夹中：&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;sh&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-sh &quot;&gt;&lt;code class=&quot;language-sh&quot; data-lang=&quot;sh&quot;&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;.&#x2F;build.sh
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;那你大概率会碰到 riscv-test submodule 里的关于 &lt;code&gt;tohost&lt;&#x2F;code&gt; 和 &lt;code&gt;fromhost&lt;&#x2F;code&gt; 重复定义的错误，可以采用&lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;riscv&#x2F;riscv-tests&#x2F;issues&#x2F;286#issuecomment-801002149&quot;&gt;这里提到&lt;&#x2F;a&gt;的方法修复&lt;sup class=&quot;footnote-reference&quot;&gt;&lt;a href=&quot;#6&quot;&gt;6&lt;&#x2F;a&gt;&lt;&#x2F;sup&gt;：&lt;&#x2F;p&gt;
&lt;p&gt;修改 &lt;code&gt;.&#x2F;riscv-tests&#x2F;isa&#x2F;Makefile&lt;&#x2F;code&gt; 中的编译选项：&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;diff&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-diff &quot;&gt;&lt;code class=&quot;language-diff&quot; data-lang=&quot;diff&quot;&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;-RISCV_GCC_OPTS ?= -static -mcmodel=medany -fvisibility=hidden -nostdlib -nostartfiles
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;+RISCV_GCC_OPTS ?= -static -mcmodel=medany -fvisibility=hidden -nostdlib -nostartfiles -fcommon
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;h3 id=&quot;tian-jia-zi-ding-yi-zhi-ling-ji&quot;&gt;添加自定义指令集&lt;&#x2F;h3&gt;
&lt;p&gt;在 Spike 模拟器中添加客制指令集非常方便，只需要在 &lt;code&gt;.&#x2F;riscv-isa-sim&#x2F;customext&#x2F;&lt;&#x2F;code&gt; 中添加一个实现扩展指令集行为的文件，
其中有一个类实现了 &lt;code&gt;extension_t&lt;&#x2F;code&gt;，然后用 &lt;code&gt;REGISTER_EXTENSION&lt;&#x2F;code&gt; 宏将其注册到模拟器即可。&lt;&#x2F;p&gt;
&lt;p&gt;&lt;code&gt;extension_t&lt;&#x2F;code&gt; 要求一个 &lt;code&gt;name&lt;&#x2F;code&gt;，一个拿所有指令的 &lt;code&gt;get_instructions&lt;&#x2F;code&gt;，一个拿所有反汇编指令的 &lt;code&gt;get_disasms&lt;&#x2F;code&gt;。&lt;&#x2F;p&gt;
&lt;h2 id=&quot;gem5-mo-ni-qi&quot;&gt;gem5 模拟器&lt;&#x2F;h2&gt;
&lt;h3 id=&quot;clone-dai-ma-2&quot;&gt;clone 代码&lt;&#x2F;h3&gt;
&lt;pre data-lang=&quot;sh&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-sh &quot;&gt;&lt;code class=&quot;language-sh&quot; data-lang=&quot;sh&quot;&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;git&lt;&#x2F;span&gt;&lt;span&gt; clone https:&#x2F;&#x2F;gem5.googlesource.com&#x2F;public&#x2F;gem5
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;h3 id=&quot;zhuang-yi-lai-1&quot;&gt;装依赖&lt;&#x2F;h3&gt;
&lt;pre data-lang=&quot;sh&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-sh &quot;&gt;&lt;code class=&quot;language-sh&quot; data-lang=&quot;sh&quot;&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;sudo&lt;&#x2F;span&gt;&lt;span&gt; apt install build-essential git m4 scons zlib1g zlib1g-dev \
&lt;&#x2F;span&gt;&lt;span&gt;    libprotobuf-dev protobuf-compiler libprotoc-dev libgoogle-perftools-dev \
&lt;&#x2F;span&gt;&lt;span&gt;    python3-dev python3-six python libboost-all-dev pkg-config
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;h3 id=&quot;build-1&quot;&gt;build&lt;&#x2F;h3&gt;
&lt;p&gt;在 clone 到的文件夹中：&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;sh&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-sh &quot;&gt;&lt;code class=&quot;language-sh&quot; data-lang=&quot;sh&quot;&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;&#x2F;usr&#x2F;bin&#x2F;env&lt;&#x2F;span&gt;&lt;span&gt; python3 $(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;which&lt;&#x2F;span&gt;&lt;span&gt; scons) build&#x2F;RISCV&#x2F;gem5.opt&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt; -j &lt;&#x2F;span&gt;&lt;span&gt;&amp;lt;CPU核数&amp;gt;
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;如果你想要在你的程序中加 &lt;code&gt;checkpoint&lt;&#x2F;code&gt;、重置统计数据等，需要构建 &lt;code&gt;libm5&lt;&#x2F;code&gt;：&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;sh&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-sh &quot;&gt;&lt;code class=&quot;language-sh&quot; data-lang=&quot;sh&quot;&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;&#x2F;usr&#x2F;bin&#x2F;env&lt;&#x2F;span&gt;&lt;span&gt; python3 $(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;which&lt;&#x2F;span&gt;&lt;span&gt; scons)&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt; -C&lt;&#x2F;span&gt;&lt;span&gt; util&#x2F;m5 build&#x2F;riscv&#x2F;out&#x2F;m5
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;h3 id=&quot;shi-yong-1&quot;&gt;使用&lt;&#x2F;h3&gt;
&lt;p&gt;如果你编写的程序中使用了 &lt;code&gt;libm5&lt;&#x2F;code&gt; 中的功能，需要包含 &lt;code&gt;gem5&#x2F;m5ops.h&lt;&#x2F;code&gt; 并在链接时链接 &lt;code&gt;libm5.a&lt;&#x2F;code&gt;：&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;sh&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-sh &quot;&gt;&lt;code class=&quot;language-sh&quot; data-lang=&quot;sh&quot;&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;riscv64-linux-gnu-gcc -static -I&lt;&#x2F;span&gt;&lt;span&gt;&#x2F;home&#x2F;longfangsong&#x2F;workspace&#x2F;gem5&#x2F;include&#x2F;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt; -I &lt;&#x2F;span&gt;&lt;span&gt;&amp;lt;gem5 位置&amp;gt;&#x2F;gem5&#x2F;include&#x2F;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt; -static &lt;&#x2F;span&gt;&lt;span&gt;&amp;lt;其他源文件&amp;gt; &amp;lt;gem5 位置&amp;gt;&#x2F;gem5&#x2F;util&#x2F;m5&#x2F;build&#x2F;riscv&#x2F;out&#x2F;libm5.a
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;h4 id=&quot;trick-on-profiling-unspported-isa-set&quot;&gt;Trick on profiling unspported ISA set&lt;&#x2F;h4&gt;
&lt;p&gt;&lt;code&gt;gem5&lt;&#x2F;code&gt; 只支持使用 &lt;code&gt;riscv64-linux-gnu-gcc&lt;&#x2F;code&gt; 生成的二进制文件，而且假定了用户有硬浮点支持，这在想要比较不同指令集时会带来一些不便。&lt;&#x2F;p&gt;
&lt;p&gt;解决方案非常呆但很有效，就是先用 &lt;code&gt;riscv64-unknown-elf-gcc&lt;&#x2F;code&gt; 拿到某个指令集和 abi（如果要用和最终编译到二进制文件时不同的 abi 的话建议通过全局变量传参数和返回值） 下的汇编，然后用 &lt;code&gt;riscv64-linux-gnu-gcc&lt;&#x2F;code&gt; 编译汇编来生成最终的二进制文件以供 &lt;code&gt;gem5&lt;&#x2F;code&gt; 执行。&lt;&#x2F;p&gt;
&lt;p&gt;可能会用到软乘法、软浮点等等的libgcc 中的 polyfill 代码，把这些也拉过来编译就是了&lt;sup class=&quot;footnote-reference&quot;&gt;&lt;a href=&quot;#7&quot;&gt;7&lt;&#x2F;a&gt;&lt;&#x2F;sup&gt;, 目前已知的几份 polyfill 代码的位置都位于 &lt;code&gt;riscv-gnu-toolchain&#x2F;libgcc&lt;&#x2F;code&gt; 下，&lt;code&gt;softfp&lt;&#x2F;code&gt; 就是软浮点，&lt;code&gt;config&#x2F;riscv&lt;&#x2F;code&gt; 就是其他一些东西的 polyfill，比如乘除法，原子操作等等。&lt;&#x2F;p&gt;
&lt;div class=&quot;footnote-definition&quot; id=&quot;1&quot;&gt;&lt;sup class=&quot;footnote-definition-label&quot;&gt;1&lt;&#x2F;sup&gt;
&lt;p&gt;因为 debian 可以在 &lt;code&gt;su&lt;&#x2F;code&gt; 下面做所有的事，&lt;code&gt;sudo&lt;&#x2F;code&gt; 反而要自己装，docker 一打开就是 &lt;code&gt;su&lt;&#x2F;code&gt;，为了复制粘贴方便下面都不会写明要 &lt;code&gt;sudo&lt;&#x2F;code&gt; 的地方，如果有必要的话自己加……&lt;&#x2F;p&gt;
&lt;&#x2F;div&gt;
&lt;div class=&quot;footnote-definition&quot; id=&quot;2&quot;&gt;&lt;sup class=&quot;footnote-definition-label&quot;&gt;2&lt;&#x2F;sup&gt;
&lt;p&gt;这是真的坑。还好正常的 Linux 系统安装器默认的文件系统都是区分大小写的。但用 Docker 挂其他系统的 Volume 就不一定了……&lt;&#x2F;p&gt;
&lt;&#x2F;div&gt;
&lt;div class=&quot;footnote-definition&quot; id=&quot;3&quot;&gt;&lt;sup class=&quot;footnote-definition-label&quot;&gt;3&lt;&#x2F;sup&gt;
&lt;p&gt;没文档就 nm 离谱，有些字母用的也挺离谱。&lt;&#x2F;p&gt;
&lt;&#x2F;div&gt;
&lt;div class=&quot;footnote-definition&quot; id=&quot;4&quot;&gt;&lt;sup class=&quot;footnote-definition-label&quot;&gt;4&lt;&#x2F;sup&gt;
&lt;p&gt;这群开发者写的什么鬼 Makefile 啦。&lt;&#x2F;p&gt;
&lt;&#x2F;div&gt;
&lt;div class=&quot;footnote-definition&quot; id=&quot;5&quot;&gt;&lt;sup class=&quot;footnote-definition-label&quot;&gt;5&lt;&#x2F;sup&gt;
&lt;p&gt;讲道理我也不懂 😭&lt;&#x2F;p&gt;
&lt;&#x2F;div&gt;
&lt;div class=&quot;footnote-definition&quot; id=&quot;6&quot;&gt;&lt;sup class=&quot;footnote-definition-label&quot;&gt;6&lt;&#x2F;sup&gt;
&lt;p&gt;官方维护在干什么东西啊.jpg&lt;&#x2F;p&gt;
&lt;&#x2F;div&gt;
&lt;div class=&quot;footnote-definition&quot; id=&quot;7&quot;&gt;&lt;sup class=&quot;footnote-definition-label&quot;&gt;7&lt;&#x2F;sup&gt;
&lt;p&gt;现在我懂为啥 C++ 大型项目为啥要把依赖也搞到项目的 &lt;code&gt;.&#x2F;third_parties&lt;&#x2F;code&gt; 里面一起编译了，否则这个链接、 abi 什么的是真的麻烦。&lt;&#x2F;p&gt;
&lt;&#x2F;div&gt;
</content>
	</entry>
	<entry xml:lang="zh">
		<title>重新开始学数学 • 数理逻辑（2）</title>
		<published>2021-03-25T09:29:44.051+00:00</published>
		<updated>2021-03-25T09:29:44.051+00:00</updated>
		<link href="https://longfangsong.github.io/restart-math-logic-2/" type="text/html"/>
		<id>https://longfangsong.github.io/restart-math-logic-2/</id>
		<content type="html">&lt;h2 id=&quot;wei-ci-luo-ji&quot;&gt;谓词逻辑&lt;&#x2F;h2&gt;
&lt;h3 id=&quot;wei-ci&quot;&gt;谓词&lt;&#x2F;h3&gt;
&lt;p&gt;就是返回 &lt;code&gt;bool&lt;&#x2F;code&gt; 的函数&lt;&#x2F;p&gt;
&lt;h3 id=&quot;liang-ci&quot;&gt;量词&lt;&#x2F;h3&gt;
&lt;p&gt;就是 $\forall$ 和 $\exists$。&lt;&#x2F;p&gt;
&lt;p&gt;注意量词的优先级比 $\wedge$ 和 $\vee$ 高，例如：$\forall x A \wedge B$ 意思是 $(\forall x A) \wedge B$&lt;&#x2F;p&gt;
&lt;h3 id=&quot;substitution-ti-huan&quot;&gt;substitution（替换）&lt;&#x2F;h3&gt;
&lt;p&gt;设有一个式子 $A$，其中有一个变量 $x$，给定一个项 $t$，用 $t$ 替换所有自由出现的 $x$ 的操作称为一次 substitution，记作：&lt;&#x2F;p&gt;
&lt;p&gt;$$
A[t&#x2F;x]
$$&lt;&#x2F;p&gt;
</content>
	</entry>
	<entry xml:lang="zh">
		<title>重新开始学数学 • 数理逻辑（1）</title>
		<published>2021-01-12T10:01:52.110+00:00</published>
		<updated>2021-01-12T10:01:52.110+00:00</updated>
		<link href="https://longfangsong.github.io/restart-math-logic-1/" type="text/html"/>
		<id>https://longfangsong.github.io/restart-math-logic-1/</id>
		<content type="html">&lt;h2 id=&quot;ming-ti-luo-ji&quot;&gt;命题逻辑&lt;&#x2F;h2&gt;
&lt;p&gt;我们课上学的基本上就是这些了，大部分就是一些 trival 的是个人都能想通的东西，就是各种箭头（？）的用法容易混淆：&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;设有命题 $A$ 和 $B$，$A \rightarrow B$ 指 “$A$ 实质蕴含 $B$” 这样一个命题，即&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;pesudo&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-pesudo &quot;&gt;&lt;code class=&quot;language-pesudo&quot; data-lang=&quot;pesudo&quot;&gt;&lt;span&gt;if A then B
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;设有一堆命题 $A$ 和一个命题 $B$，$A \vdash B$ 指 “$B$ 是 $A$ 的句法后承 ” 这样一个 sequent。&lt;&#x2F;p&gt;
&lt;p&gt;通过使用某些证明手段，从前提 $A$ 能证出 $B$，那么这个 sequent 就 valid，否则就不vaild。
$$
\require{bussproofs}
\begin{prooftree}
\AxiomC{A}
\UnaryInfC{$\vdots$}
\UnaryInfC{B}
\end{prooftree}
$$&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;$ A \dashv \vdash B$：$A \vdash B$ 和 $ B \vdash A$ 都 valid，称为 $A$ 和 $B$ provably equivalent。&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;设有一堆命题 $A$ 和一个命题 $B$，$A \models B$：指 “$B$ 是 $A$ 的语义后承”，即如果 $A$ 中每一个命题都为真，则 $B$ 也为真。&lt;&#x2F;p&gt;
&lt;p&gt;在自然演绎中，$A \models B$ 当且仅当 $ A \vdash B $&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;另外常常会使用 $\top$ 和 $\bot$ 分别代表 &lt;code&gt;true&lt;&#x2F;code&gt; 和 &lt;code&gt;false&lt;&#x2F;code&gt;。&lt;&#x2F;p&gt;
&lt;h3 id=&quot;horn-gong-shi-he-horn-ke-man-zu-xing-wen-ti&quot;&gt;Horn 公式和 Horn 可满足性问题&lt;&#x2F;h3&gt;
&lt;p&gt;设 p 为原子公式，&lt;&#x2F;p&gt;
&lt;p&gt;$$
\displaylines {
P ::= \bot | \top | p \\
A ::= P \mid P \wedge A \\
C ::= A \rightarrow P \\
H ::= C \mid C \wedge H
}
$$&lt;&#x2F;p&gt;
&lt;p&gt;其中 H 就是 Horn 公式，C 就是 Horn 子句&lt;sup class=&quot;footnote-reference&quot;&gt;&lt;a href=&quot;#1&quot;&gt;1&lt;&#x2F;a&gt;&lt;&#x2F;sup&gt;。&lt;&#x2F;p&gt;
&lt;p&gt;Horn 公式的几个例子：&lt;&#x2F;p&gt;
&lt;p&gt;$$
(p \wedge q \wedge s \rightarrow p) \wedge(q \wedge r \rightarrow p) \wedge(p \wedge s \rightarrow s)
$$&lt;&#x2F;p&gt;
&lt;p&gt;$$
(p \wedge q \wedge s \rightarrow \perp) \wedge(q \wedge r \rightarrow p) \wedge(\top \rightarrow s)
$$&lt;&#x2F;p&gt;
&lt;p&gt;$$
(p_{2} \wedge p_{3} \wedge p_{5} \rightarrow p_{13}) \wedge (\top \rightarrow p_{5}) \wedge (p_{5} \wedge p_{11} \rightarrow \perp)
$$&lt;&#x2F;p&gt;
&lt;p&gt;Horn 公式的好处在于，和任意公式是否可满足（即 SAT 问题）是 NP 问题不同，HornSAT 是 P 问题，有这么一个判定算法：&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;horn_satisfiabe&lt;&#x2F;span&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;formula&lt;&#x2F;span&gt;&lt;span&gt;: HornFormula) {
&lt;&#x2F;span&gt;&lt;span&gt;  &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;let mut&lt;&#x2F;span&gt;&lt;span&gt; marked = HashSet::new();
&lt;&#x2F;span&gt;&lt;span&gt;  marked.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;add&lt;&#x2F;span&gt;&lt;span&gt;(⊤);
&lt;&#x2F;span&gt;&lt;span&gt;  &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;while let &lt;&#x2F;span&gt;&lt;span&gt;Some(p) = 
&lt;&#x2F;span&gt;&lt;span&gt;    formula.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;find&lt;&#x2F;span&gt;&lt;span&gt;(|&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;it&lt;&#x2F;span&gt;&lt;span&gt;| !it.rhs.marked &amp;amp;&amp;amp; 
&lt;&#x2F;span&gt;&lt;span&gt;      it.lhs.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;all&lt;&#x2F;span&gt;&lt;span&gt;(|&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;it&lt;&#x2F;span&gt;&lt;span&gt;| marked.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;contains&lt;&#x2F;span&gt;&lt;span&gt;(it))
&lt;&#x2F;span&gt;&lt;span&gt;    ).&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;map&lt;&#x2F;span&gt;&lt;span&gt;(|&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;it&lt;&#x2F;span&gt;&lt;span&gt;| it.rhs) {
&lt;&#x2F;span&gt;&lt;span&gt;    marked.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;add&lt;&#x2F;span&gt;&lt;span&gt;(p);
&lt;&#x2F;span&gt;&lt;span&gt;  }
&lt;&#x2F;span&gt;&lt;span&gt;  &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;return &lt;&#x2F;span&gt;&lt;span&gt;!marked.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;contains&lt;&#x2F;span&gt;&lt;span&gt;(⊥);
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;h3 id=&quot;sat-qiu-jie-qi&quot;&gt;Sat 求解器&lt;&#x2F;h3&gt;
&lt;p&gt;感觉这里书上讲的好复杂……&lt;&#x2F;p&gt;
&lt;p&gt;其实就是自顶而下地考虑一个公式的 parse tree，对公式本身每一个子公式的值，如果能通过上层的值和算符的真值表直接判定就直接判定，比如：&lt;&#x2F;p&gt;
&lt;p&gt;$$
\top = \neg p \wedge q
$$&lt;&#x2F;p&gt;
&lt;p&gt;从上层的 $\top$ 和 $\wedge$ 的性质我们就能得出
$$
\neg p = \top
$$&lt;&#x2F;p&gt;
&lt;p&gt;$$
q = \top
$$&lt;&#x2F;p&gt;
&lt;p&gt;不行的话（比如遇到了类似 $\top = p \vee q$ 的情况）就随便选一个子公式把 $\top$ 和 $\bot$ 都试一遍，如果推出了冲突的结论就回溯，如果全判定完了没冲突就成了。&lt;&#x2F;p&gt;
&lt;div class=&quot;footnote-definition&quot; id=&quot;1&quot;&gt;&lt;sup class=&quot;footnote-definition-label&quot;&gt;1&lt;&#x2F;sup&gt;
&lt;p&gt;“子句” 的定义是原子公式或 “$\neg 原子公式$” 的析取。&lt;&#x2F;p&gt;
&lt;&#x2F;div&gt;
</content>
	</entry>
	<entry xml:lang="zh">
		<title>分布式系统 • 时钟</title>
		<published>2020-12-10T22:42:11.815+00:00</published>
		<updated>2020-12-10T22:42:11.815+00:00</updated>
		<link href="https://longfangsong.github.io/clocks-in-distributed-system/" type="text/html"/>
		<id>https://longfangsong.github.io/clocks-in-distributed-system/</id>
		<content type="html">&lt;h2 id=&quot;wei-shi-yao-zai-fen-bu-shi-xi-tong-zhong-shi-zhong-hen-zhong-yao&quot;&gt;为什么在分布式系统中时钟很重要&lt;&#x2F;h2&gt;
&lt;p&gt;最简单的一个例子：一个读请求和一个修改请求（在外界观察者眼中）先后来到一个系统中的两个不同的节点上（假设所有节点的存储是通过某些“魔法”手段连在一起的），按道理由于读请求先发生，那么他不应当读到写请求写入的数据。但是如果两个节点上的物理时钟出了问题，处理读请求的时钟快了（认为请求到来时的时间戳比较大），而处理写请求的时钟慢了（认为请求到来时的时间戳比较小），此时按照时钟判断出的读写顺序就和实际不同了，这就会带来读写操作进行的顺序和预期不符。&lt;&#x2F;p&gt;
&lt;p&gt;即使是同一个节点上也会遇到时钟由于走的太快而被 NTP 这样的时间同步算法回拨，导致的时间戳不唯一的问题。&lt;&#x2F;p&gt;
&lt;p&gt;可见分布式系统中直接根据物理时钟决定事件发生的先后顺序是不可行的，原因是不同系统中的物理时钟其快慢是无法保证的。&lt;&#x2F;p&gt;
&lt;p&gt;而目前最好的时间校准算法 NTP 也无法很好的保证精度，网络这个东西实在是太不可靠了……&lt;&#x2F;p&gt;
&lt;h2 id=&quot;tso&quot;&gt;TSO&lt;&#x2F;h2&gt;
&lt;p&gt;实际上我们可以确定的一种顺序就是同一节点上事件发生的顺序：&lt;&#x2F;p&gt;
&lt;blockquote&gt;
&lt;p&gt;公理1：在同一节点上有序的两个事件在外界观察者眼中也有序&lt;&#x2F;p&gt;
&lt;&#x2F;blockquote&gt;
&lt;p&gt;那么很简单的一个想法就是：在每次有请求来到系统时，都要经过一个负责分配单调递增的时间戳的节点，给这个请求分配时间戳&lt;&#x2F;p&gt;
&lt;p&gt;但是这样系统里面就出现了这么一个不能扩展的单点，而且这个节点理论上不能宕掉，否则就算是切换新的时间戳分配节点，这个新旧节点之间的时间戳的差异也会造成问题，至少也会引起一个等于“节点之间最大可能物理时间的差距”（通过物理时钟分配时间戳）或者“一个从某种持久化存储中读取数据”（使用累加计数器分配时间戳）的延迟。&lt;&#x2F;p&gt;
&lt;h2 id=&quot;tong-xin-he-luo-ji-shi-zhong&quot;&gt;通信和逻辑时钟&lt;&#x2F;h2&gt;
&lt;p&gt;（两个节点之间的）通信必定有一个发送事件和一个接收事件，分别发生在两个节点上，而无论在任何观察者眼中发送一定先于接收，所以我们可以通过通信来确定一些事件的先后&lt;sup class=&quot;footnote-reference&quot;&gt;&lt;a href=&quot;#1&quot;&gt;1&lt;&#x2F;a&gt;&lt;&#x2F;sup&gt;：&lt;&#x2F;p&gt;
&lt;blockquote&gt;
&lt;p&gt;公理2：对于某个通信，在外界观察者眼中发送先于接收&lt;&#x2F;p&gt;
&lt;&#x2F;blockquote&gt;
&lt;p&gt;结合公理1和公理2，有：&lt;&#x2F;p&gt;
&lt;blockquote&gt;
&lt;p&gt;定理1：对于某个通信，&amp;quot;通信发送之前发生的事件&amp;quot;在外界观察者眼中发生在&amp;quot;通信接收之后发生的事件&amp;quot;之后&lt;&#x2F;p&gt;
&lt;&#x2F;blockquote&gt;
&lt;p&gt;根据这一定理，我们可以通过这个逻辑时间戳建立事件间关于“happens before”的&lt;strong&gt;偏序关系&lt;&#x2F;strong&gt;，即我们可以比较一部分事件的先后关系。&lt;&#x2F;p&gt;
&lt;p&gt;由此 Lamport 创造了 Lamport 逻辑时钟算法：&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;每个节点初始时间戳都为0&lt;&#x2F;li&gt;
&lt;li&gt;每次发生消息交换之外的事件时，本地时间戳 +1&lt;&#x2F;li&gt;
&lt;li&gt;每次发送消息，本地时间戳+1，并带在消息里&lt;&#x2F;li&gt;
&lt;li&gt;每次接收消息，如果消息中的时间戳比本地时间大，那么本地时间戳 = 消息时间戳 + 1，否则正常本地时间戳 + 1‘&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;即每次发生事件，都保证 &lt;code&gt;本地时间戳 = 节点看到过的最大时间戳 + 1&lt;&#x2F;code&gt;&lt;&#x2F;p&gt;
&lt;h3 id=&quot;bao-zheng-liao-shi-yao&quot;&gt;保证了什么&lt;&#x2F;h3&gt;
&lt;p&gt;Lamport逻辑时钟保证了：&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;若系统外部观察者看到事件A在事件B前发生，则系统内部必有 事件A对应的时间戳&amp;lt;事件B对应的时间戳。&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;但反之则不一定成立，即时间戳的大小并不能决定事件的发生顺序。&lt;&#x2F;p&gt;
&lt;h3 id=&quot;quan-xu-hua-gai-jin&quot;&gt;全序化改进&lt;&#x2F;h3&gt;
&lt;p&gt;可以暴力地给每个节点一个编号，把时间戳的定义改为 &lt;code&gt;concat(原本的时间戳, 节点编号)&lt;&#x2F;code&gt;，这样人为地通过时间戳之间的全序关系为事件定出一个全序关系。&lt;&#x2F;p&gt;
&lt;p&gt;虽然这个全序关系和事件在外界观察者眼中的顺序并没有绝对的关系，但是方便了我们进行一些应用。&lt;&#x2F;p&gt;
&lt;h4 id=&quot;ying-yong-lamport-suo&quot;&gt;应用：Lamport 锁&lt;&#x2F;h4&gt;
&lt;p&gt;Lamport锁是一个经典的分布式锁算法，理论上可以在分布式系统中保证某一个资源同一时间只有一个访问者。&lt;&#x2F;p&gt;
&lt;p&gt;算法如下：&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;每个节点维护一个等锁队列&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;当一个节点想要锁上一个资源供自己访问时，发送一个请求锁的消息给所有节点，eg：&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#2b303b;color:#c0c5ce;&quot;&gt;&lt;code&gt;&lt;span&gt;Node A 想要锁上这个资源
&lt;&#x2F;span&gt;&lt;span&gt;—— 发送于 时间戳 T
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;并将这个请求消息放入自己的存储中&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;收到消息后，发送一个确认消息，eg：&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#2b303b;color:#c0c5ce;&quot;&gt;&lt;code&gt;&lt;span&gt;Node B 已收到 Node A 的请求
&lt;&#x2F;span&gt;&lt;span&gt;—— 发送于 时间戳 T&amp;#39;
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;由 Lamport 逻辑时钟算法，T&#x27; &amp;gt; T&lt;&#x2F;p&gt;
&lt;p&gt;并将这个请求消息放入自己的存储中&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;如果某个节点&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;存储里的所有消息中，来自自己的请求的时间戳是最小的&lt;&#x2F;li&gt;
&lt;li&gt;从所有其他节点都收到过，时间戳大于上面说的这个请求的时间戳的消息&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;那么它可以认为自己获取到了这个资源上的锁。&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;当节点用完资源准备释放时，删除自己的储存中所有来自自身的请求消息，然后发送删除自己的锁请求的消息：&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#2b303b;color:#c0c5ce;&quot;&gt;&lt;code&gt;&lt;span&gt;Node A 释放了这个资源
&lt;&#x2F;span&gt;&lt;span&gt;—— 发送于时间戳 XXX
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;其他节点收到后也从自己的存储中删掉所有来自这一节点的请求消息&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;以上就是 Lamport 锁算法。&lt;&#x2F;p&gt;
&lt;h5 id=&quot;tla-proof&quot;&gt;TLA+ Proof&lt;&#x2F;h5&gt;
&lt;p&gt;TODO&lt;&#x2F;p&gt;
&lt;h5 id=&quot;que-xian&quot;&gt;缺陷&lt;&#x2F;h5&gt;
&lt;p&gt;Lamport 锁并没有任何容错机制，无论是网络不通还是节点挂掉，他一概防不出去。&lt;&#x2F;p&gt;
&lt;h2 id=&quot;xiang-liang-shi-zhong&quot;&gt;向量时钟&lt;&#x2F;h2&gt;
&lt;p&gt;向量时钟是对 Lamport 逻辑时钟的一种改进，Lamport 逻辑时钟里面拿到的时间戳……并没有什么卵用，因为凭时间戳的大小并不能确定其他节点上事件的发生顺序，这一情况的根本原因是这里的时间戳只能指示当前节点对&lt;strong&gt;自身&lt;&#x2F;strong&gt;事件推进的认识，而正如我们前面所述，同一节点上的时间戳可以确定出顺序，那么我们是不是能让每个节点上都有所有节点的时间信息？&lt;&#x2F;p&gt;
&lt;p&gt;这就是向量时钟的想法：&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;将原本 Lamport 时钟中每个节点上一个的时间戳改成 为每个节点（包括自己）都设立一个时间戳，这构成了一个时间戳向量&lt;&#x2F;li&gt;
&lt;li&gt;发生事件时更新（+1）时间戳向量中自己对应的那个元素&lt;&#x2F;li&gt;
&lt;li&gt;在发送消息时，发送整个时间戳向量&lt;&#x2F;li&gt;
&lt;li&gt;接收消息时，根据发来的时间戳向量更新自己的时间戳向量（对向量中的每个元素应用 Lamport 时间戳的更新算法）&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;使用向量时钟，我们可以确定部分事件的先后关系：&lt;&#x2F;p&gt;
&lt;p&gt;假设事件 x、y 分别发生在节点 A、B 上：&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;若事件x发生时的时间戳向量（自然是从 A 上取得）中，每个元素全部都小于等于事件  y发生时的时间戳向量的对应元素（从 B 上取得），则 x 早于 y 发生，反之亦然&lt;&#x2F;li&gt;
&lt;li&gt;若两个时间戳向量中的各个元素大小关系各有不同，则不能比较出其发生的先后，可以认为这两个事件是并发发生的。&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;这样，我们可以通过时间戳向量确定很大一部分事件的先后关系。&lt;&#x2F;p&gt;
&lt;h2 id=&quot;hybrid-logical-clocks-hlc&quot;&gt;Hybrid Logical Clocks (HLC)&lt;&#x2F;h2&gt;
&lt;p&gt;向量时钟这样的逻辑时钟虽然让我们能确定一部分事件的先后关系，但是其问题在于只在系统内部有用，而对于系统外部的时间一无所知。这在我们想要知道外部事件的先后顺序或者根据物理时间查询事件时非常不利，而物理时钟又是那么的不可靠。&lt;&#x2F;p&gt;
&lt;p&gt;于是就有了混合时钟这种试图把物理和逻辑时钟结合起来的方案。&lt;&#x2F;p&gt;
&lt;h3 id=&quot;shi-xian&quot;&gt;实现&lt;&#x2F;h3&gt;
&lt;p&gt;容易想到的方法是，每次发送和接收消息时，都在Lamport时间戳的基础上，再多做一个和物理时钟做max的操作，即：&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;发送消息前或者本地发生新的事件，时间戳 = max(时间戳+1, 物理时钟)&lt;&#x2F;li&gt;
&lt;li&gt;接收到消息后，时间戳 = max(本地时间戳+1, 消息时间戳+1, 物理时钟)&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;问题在于这样搞时间戳是可以比物理时间无限制地快下去的，例如所有请求都从某个节点非常快地进入系统，并广播到其他节点，其他节点也对每个事件发送了回复，那就会造成时间戳不断+1，导致时间戳远比物理时间大，此时时间戳相当于退化成了普通的逻辑时钟，让我们失去了对物理时间的感知。&lt;&#x2F;p&gt;
&lt;p&gt;我们可以看出这一实现主要的问题在于大量时间可能会造成时间戳过快的增长而物理时钟赶不上的问题，那我们能不能记录一下物理时钟落后了多少来修正这个问题呢？&lt;&#x2F;p&gt;
&lt;p&gt;这就是 HLC 算法的想法：&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;HLC 时间戳分为两个部分，“物理”部分（常实现为一个变量的高位）和“逻辑”部分（常实现为一个变量的低位）&lt;&#x2F;li&gt;
&lt;li&gt;发送消息前或者本地发生事件
&lt;ul&gt;
&lt;li&gt;若 HLC 时间戳“物理”部分小于现在的物理时钟，证明物理时钟已经赶上了事件发生的速度，此时只需把“物理”部分更新为新的物理时间戳，并将“逻辑”部分清0即可&lt;&#x2F;li&gt;
&lt;li&gt;若 HLC 时间戳“物理”部分大于（物理时钟被回拨时会发生大于的情况）等于现在的物理时钟，证明物理时钟没有赶上了事件发生的速度，此时只需向“逻辑”部分加一即可&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;收到消息后：
&lt;ul&gt;
&lt;li&gt;比较 本地 HLC 时间戳“物理”部分、消息 HLC 时间戳“物理”部分、本地物理时间戳 三者
&lt;ul&gt;
&lt;li&gt;本地 HLC 时间戳“物理”部分和消息“物理”部分相等，同大于本地物理时间戳，证明本地物理时钟既没有赶上本地事件发生的速度，也没有赶上消息发送方上事件发生的速度，那么本地“逻辑”部分的值就可以更新为 &lt;code&gt;max(本地“逻辑”部分, 消息“逻辑”部分) + 1&lt;&#x2F;code&gt;&lt;&#x2F;li&gt;
&lt;li&gt;本地 HLC 时间戳“物理”部分 是其中最大的，说明消息发送方的物理时钟落后于本地物理时钟，但由于 本地物理时间戳 仍然小于 本地 HLC 时间戳的“物理”部分 说明本地物理时间戳没有赶上事件发生的速度，需要向“逻辑”部分加一&lt;&#x2F;li&gt;
&lt;li&gt;消息的 HLC 时间戳“物理”部分 是其中最大的（无论他与本地物理时间戳是否相等），说明本地 HLC 时钟完全落后于消息发送方，那么本地的时间戳就需要直接更新为消息的 HLC 时间戳再在“逻辑”部分加一的结果&lt;&#x2F;li&gt;
&lt;li&gt;本地物理时间戳 是其中最大的，证明物理时钟已经赶上了本地和发送方事件发生的速度，此时只需把“物理”部分更新为新的物理时间戳，并将“逻辑”部分清0即可&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;简单的思考就是： &lt;&#x2F;p&gt;
&lt;ol&gt;
&lt;li&gt;为防止在物理时钟 回拨 或者 精度不足以区别事件先后 时物理时钟无法确定本地事件顺序的问题，增设了一个“逻辑”部分，用来
&lt;ul&gt;
&lt;li&gt;在时钟回拨时让 HLC 时间戳“物理”部分不跟着回拨，而是通过这个逻辑部分确定先后，从而保证时钟的单调性&lt;&#x2F;li&gt;
&lt;li&gt;在物理时钟精度不足时使用逻辑部分确定先后&lt;&#x2F;li&gt;
&lt;li&gt;如果物理时钟比 HLC 时钟“走得快”，就相信物理时钟&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;通信后，保证自己的 HLC 时间戳不比消息的 HLC 时间戳早&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
&lt;h3 id=&quot;bao-zheng-liao-shi-yao-1&quot;&gt;保证了什么&lt;&#x2F;h3&gt;
&lt;ol&gt;
&lt;li&gt;对任何事件x和y，若x发生在y之前，则 x对应的 HLC 时间戳 &amp;lt; y 对应的 HLC 时间戳&lt;&#x2F;li&gt;
&lt;li&gt;HLC 时间戳对应的物理时间和节点实际的物理时间的差有确定的上限，这个上限基本上是 两倍的机器的时间和ntp server时间存在的 误差范围（ntp offset），平时这个 offset 一般都是几个 ms。&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
&lt;h3 id=&quot;tla-proof-1&quot;&gt;TLA+ Proof&lt;&#x2F;h3&gt;
&lt;p&gt;TODO&lt;&#x2F;p&gt;
&lt;div class=&quot;footnote-definition&quot; id=&quot;1&quot;&gt;&lt;sup class=&quot;footnote-definition-label&quot;&gt;1&lt;&#x2F;sup&gt;
&lt;p&gt;有些人将定理1和2确定出的时间顺序关系称为“因果关系”，但是个人并不觉得这是个好名字，因为这些事件之间并不一定存在谁引起谁，借用这个名词可能会产生误解&lt;&#x2F;p&gt;
&lt;&#x2F;div&gt;
</content>
	</entry>
	<entry xml:lang="zh">
		<title>Parsing • LR(0)分析</title>
		<published>2020-05-22T22:56:58.045+00:00</published>
		<updated>2020-05-22T22:56:58.045+00:00</updated>
		<link href="https://longfangsong.github.io/lr0/" type="text/html"/>
		<id>https://longfangsong.github.io/lr0/</id>
		<content type="html">&lt;p&gt;如果你已经理解了&lt;a href=&quot;https:&#x2F;&#x2F;longfangsong.github.io&#x2F;shift-reduce&#x2F;&quot;&gt;移进-归约分析&lt;&#x2F;a&gt;的基本执行流程了，那么你一定会问，我该如何决定某个步骤上应该“移进”还是应该“归约”呢？应该选择哪个推导式来归约呢？如果我们构造的文法和表达式求值一样简单，那手动根据“栈中现有的值”和“下面要输入的值”来判断就可以了，那么如果我们处理的文法比较复杂呢？&lt;&#x2F;p&gt;
&lt;p&gt;举一个经典的表达式文法的例子：&lt;&#x2F;p&gt;
&lt;p&gt;$$
E \rightarrow E+T|T
$$&lt;&#x2F;p&gt;
&lt;p&gt;$$
T \rightarrow T*F|F
$$&lt;&#x2F;p&gt;
&lt;p&gt;$$
F \rightarrow (E) | \textbf{id}
$$&lt;&#x2F;p&gt;
&lt;p&gt;我们来模拟一下匹配字符串 $\textbf{id}*\textbf{id}+(\textbf{id}+\textbf{id})*\textbf{id}$ 的过程，并尝试解释每一步选择移进还是归约的原因。&lt;&#x2F;p&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;符号栈&lt;&#x2F;th&gt;&lt;th&gt;剩余输入&lt;&#x2F;th&gt;&lt;th&gt;动作&lt;&#x2F;th&gt;&lt;th&gt;原因&lt;&#x2F;th&gt;&lt;&#x2F;tr&gt;&lt;&#x2F;thead&gt;&lt;tbody&gt;
&lt;tr&gt;&lt;td&gt;&lt;&#x2F;td&gt;&lt;td&gt;$\textbf{id}*\textbf{id}+(\textbf{id}+\textbf{id})*\textbf{id}$&lt;&#x2F;td&gt;&lt;td&gt;移进 $\textbf{id}$&lt;&#x2F;td&gt;&lt;td&gt;没得选&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;$\textbf{id}$&lt;&#x2F;td&gt;&lt;td&gt;$*\textbf{id}+(\textbf{id}+\textbf{id})*\textbf{id}$&lt;&#x2F;td&gt;&lt;td&gt;栈顶归约为 $F$&lt;&#x2F;td&gt;&lt;td&gt;下一个符号是$*$，而没有包含 $\textbf{id} *$ 的规则，但栈顶可以归约&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;$F$&lt;&#x2F;td&gt;&lt;td&gt;$*\textbf{id}+(\textbf{id}+\textbf{id})*\textbf{id}$&lt;&#x2F;td&gt;&lt;td&gt;栈顶归约为 $T$&lt;&#x2F;td&gt;&lt;td&gt;下一个符号是$*$，而没有包含$F *$ 的规则，但栈顶可以归约&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;$T$&lt;&#x2F;td&gt;&lt;td&gt;$*\textbf{id}+(\textbf{id}+\textbf{id})*\textbf{id}$&lt;&#x2F;td&gt;&lt;td&gt;移进 $*$&lt;&#x2F;td&gt;&lt;td&gt;下一个符号是$*$， 而没有包含 $ T *$ 的规则&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;$T*$&lt;&#x2F;td&gt;&lt;td&gt;$\textbf{id}+(\textbf{id}+\textbf{id})*\textbf{id}$&lt;&#x2F;td&gt;&lt;td&gt;移进 $\textbf{id}$&lt;&#x2F;td&gt;&lt;td&gt;栈顶不能归约，只能移进&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;$T*\textbf{id}$&lt;&#x2F;td&gt;&lt;td&gt;$+(\textbf{id}+\textbf{id})*\textbf{id}$&lt;&#x2F;td&gt;&lt;td&gt;栈顶归约为 $F$&lt;&#x2F;td&gt;&lt;td&gt;下一个符号是$+$，而没有包含 $T *\textbf{id}+$ 或者 $\textbf{id}+$ 的规则，但栈顶可以归约&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;$T*F$&lt;&#x2F;td&gt;&lt;td&gt;$+(\textbf{id}+\textbf{id})*\textbf{id}$&lt;&#x2F;td&gt;&lt;td&gt;栈顶归约为 $T$&lt;&#x2F;td&gt;&lt;td&gt;下一个符号是$+$，而没有包含$T * F+$ 或者 $F+$ 的规则，但栈顶可以归约&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;$T$&lt;&#x2F;td&gt;&lt;td&gt;$+(\textbf{id}+\textbf{id})*\textbf{id}$&lt;&#x2F;td&gt;&lt;td&gt;栈顶归约为 $E$&lt;&#x2F;td&gt;&lt;td&gt;下一个符号是$+$，而没有包含$T+$ 的规则，但栈顶可以归约&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;$E$&lt;&#x2F;td&gt;&lt;td&gt;$+(\textbf{id}+\textbf{id})*\textbf{id}$&lt;&#x2F;td&gt;&lt;td&gt;移进 $+$&lt;&#x2F;td&gt;&lt;td&gt;栈顶不能归约，只能移进&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;$E+$&lt;&#x2F;td&gt;&lt;td&gt;$(\textbf{id}+\textbf{id})*\textbf{id}$&lt;&#x2F;td&gt;&lt;td&gt;移进 $($&lt;&#x2F;td&gt;&lt;td&gt;栈顶不能归约，只能移进&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;$E+($&lt;&#x2F;td&gt;&lt;td&gt;$\textbf{id}+\textbf{id})*\textbf{id}$&lt;&#x2F;td&gt;&lt;td&gt;移进 $\textbf{id}$&lt;&#x2F;td&gt;&lt;td&gt;栈顶不能归约，只能移进&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;$E+(\textbf{id}$&lt;&#x2F;td&gt;&lt;td&gt;$+\textbf{id})*\textbf{id}$&lt;&#x2F;td&gt;&lt;td&gt;栈顶归约为 $F$&lt;&#x2F;td&gt;&lt;td&gt;下一个符号是$+$，而没有包含 $\textbf{id}+$ 的规则，但栈顶可以归约&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;$E+(F$&lt;&#x2F;td&gt;&lt;td&gt;$+\textbf{id})*\textbf{id}$&lt;&#x2F;td&gt;&lt;td&gt;栈顶归约为 $T$&lt;&#x2F;td&gt;&lt;td&gt;下一个符号是$+$，而没有包含 $F+$ 的规则，但栈顶可以归约&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;$E+(T$&lt;&#x2F;td&gt;&lt;td&gt;$+\textbf{id})*\textbf{id}$&lt;&#x2F;td&gt;&lt;td&gt;栈顶归约为 $E$&lt;&#x2F;td&gt;&lt;td&gt;下一个符号是$+$，而没有 包含 $T+$ 的规则，但栈顶可以归约&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;$E+(E$&lt;&#x2F;td&gt;&lt;td&gt;$+\textbf{id})*\textbf{id}$&lt;&#x2F;td&gt;&lt;td&gt;移进&lt;&#x2F;td&gt;&lt;td&gt;栈顶不能归约，只能移进&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;$E+(E+$&lt;&#x2F;td&gt;&lt;td&gt;$\textbf{id})*\textbf{id}$&lt;&#x2F;td&gt;&lt;td&gt;移进&lt;&#x2F;td&gt;&lt;td&gt;栈顶不能归约，只能移进&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;$E+(E+\textbf{id}$&lt;&#x2F;td&gt;&lt;td&gt;$)*\textbf{id}$&lt;&#x2F;td&gt;&lt;td&gt;栈顶归约为 $F$&lt;&#x2F;td&gt;&lt;td&gt;下一个符号是$)$，而没有 包含 $\textbf{id})$ 的规则，但栈顶可以归约&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;$E+(E+F$&lt;&#x2F;td&gt;&lt;td&gt;$)*\textbf{id}$&lt;&#x2F;td&gt;&lt;td&gt;栈顶归约为 $T$&lt;&#x2F;td&gt;&lt;td&gt;下一个符号是$)$，而没有 包含 $F)$ 的规则，但栈顶可以归约&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;$E+(E+T$&lt;&#x2F;td&gt;&lt;td&gt;$)*\textbf{id}$&lt;&#x2F;td&gt;&lt;td&gt;栈顶归约为 $E$&lt;&#x2F;td&gt;&lt;td&gt;下一个符号是$+$，而没有包含 $T)$ 的规则，但栈顶可以归约&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;$E+(E+E$&lt;&#x2F;td&gt;&lt;td&gt;$)*\textbf{id}$&lt;&#x2F;td&gt;&lt;td&gt;移进&lt;&#x2F;td&gt;&lt;td&gt;栈顶不能归约，只能移进&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;$E+(E+E)$&lt;&#x2F;td&gt;&lt;td&gt;$*\textbf{id}$&lt;&#x2F;td&gt;&lt;td&gt;栈顶归约为 $F$&lt;&#x2F;td&gt;&lt;td&gt;下一个符号是$*$，没有包含 $)*$ 的规则，但栈顶可以归约&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;$E+F$&lt;&#x2F;td&gt;&lt;td&gt;$*\textbf{id}$&lt;&#x2F;td&gt;&lt;td&gt;栈顶归约为 $T$&lt;&#x2F;td&gt;&lt;td&gt;下一个符号是$*$，没有包含 $F*$ 的规则，但栈顶可以归约&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;$E+T$&lt;&#x2F;td&gt;&lt;td&gt;$*\textbf{id}$&lt;&#x2F;td&gt;&lt;td&gt;移进&lt;&#x2F;td&gt;&lt;td&gt;这里是tricky的地方，这里考虑到优先级问题必须移进，这样看来**优先移进，不行了再归约可能是处理优先级问题的方案**&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;$E+T*$&lt;&#x2F;td&gt;&lt;td&gt;$\textbf{id}$&lt;&#x2F;td&gt;&lt;td&gt;移进&lt;&#x2F;td&gt;&lt;td&gt;栈顶不能归约，只能移进&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;$E+T*\textbf{id}$&lt;&#x2F;td&gt;&lt;td&gt;&lt;&#x2F;td&gt;&lt;td&gt;栈顶归约为 $F$&lt;&#x2F;td&gt;&lt;td&gt;没有符号了，往死里归约&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;$E+T*F$&lt;&#x2F;td&gt;&lt;td&gt;&lt;&#x2F;td&gt;&lt;td&gt;栈顶归约为 $T$&lt;&#x2F;td&gt;&lt;td&gt;没有符号了，往死里归约&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;$E+T$&lt;&#x2F;td&gt;&lt;td&gt;&lt;&#x2F;td&gt;&lt;td&gt;栈顶归约为 $E$&lt;&#x2F;td&gt;&lt;td&gt;没有符号了，往死里归约&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;$E$&lt;&#x2F;td&gt;&lt;td&gt;&lt;&#x2F;td&gt;&lt;td&gt;接受&lt;&#x2F;td&gt;&lt;td&gt;&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;&#x2F;tbody&gt;&lt;&#x2F;table&gt;
&lt;p&gt;这是一个漫长的过程，在这个过程中我们发现：&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;为了处理运算符的优先级，优先进行移进
&lt;ul&gt;
&lt;li&gt;这和我们编写计算器的方式很像&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;在移进会导致栈中不包含某个可以归约的“前缀”时，必须先归约&lt;&#x2F;li&gt;
&lt;li&gt;在栈中的内容不同时，要考虑的是否可以归约的部分也不一样
&lt;ul&gt;
&lt;li&gt;例如在处理栈为 $T*$ 和 $E+T*$ 时，其实都只要考虑 $T*$ 的部分就可以了&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;那么我们可以看一下有哪些方法解决这些问题。&lt;&#x2F;p&gt;
&lt;h2 id=&quot;lr-0-xiang-zhuang-tai-chan-sheng-shi-zhong-de-cdot-yu-lr-0-zhuang-tai-ji&quot;&gt;LR(0)项、状态、产生式中的 “$\cdot$” 与LR(0) 状态机&lt;&#x2F;h2&gt;
&lt;p&gt;我们从前面的最后一个问题开始着手。&lt;&#x2F;p&gt;
&lt;p&gt;我们看 $E+T*$ 这里，在这种&lt;strong&gt;状态&lt;&#x2F;strong&gt;下，我们能用来归约的产生式只有 $T \rightarrow T*F$ 一个，会归约到栈顶上多了一个 $T$ 的状态。&lt;sup class=&quot;footnote-reference&quot;&gt;&lt;a href=&quot;#0&quot;&gt;1&lt;&#x2F;a&gt;&lt;&#x2F;sup&gt;&lt;&#x2F;p&gt;
&lt;p&gt;而在 $T*$ 这里，在这种&lt;strong&gt;状态&lt;&#x2F;strong&gt;下，我们也能用来归约的产生式只有 $T \rightarrow T*F$ 一个，也只会归约到栈顶上多了一个 $T$ 的状态。&lt;&#x2F;p&gt;
&lt;p&gt;可以看出从“往栈上放一个$T$的角度来看”这两个状态其实是同一个状态。&lt;&#x2F;p&gt;
&lt;h3 id=&quot;lr-0-xiang&quot;&gt;LR(0)项&lt;&#x2F;h3&gt;
&lt;p&gt;我们引入$\cdot$标记来分割生成式匹配过了的部分和还需要匹配的部分，所以现在这个状态可以写成：
$$
T \rightarrow T*\cdot F
$$
也就代表在这个状态下，已经匹配到了$T*$，接下来如果能成功地匹配到一个$F$，就能顺利地归约为栈顶上的一个 $T$。&lt;&#x2F;p&gt;
&lt;p&gt;像这种标记过匹配到的状态的产生式，我们称之为“LR(0)项”，简称“项”。&lt;&#x2F;p&gt;
&lt;h3 id=&quot;xiang-ji-bi-bao&quot;&gt;项集闭包&lt;&#x2F;h3&gt;
&lt;p&gt;我们考虑上面说到的 $T \rightarrow T*\cdot F$，以及另外两个项：
$$
F \rightarrow \cdot(E)
$$
$$
F \rightarrow \cdot \textbf{id}
$$&lt;&#x2F;p&gt;
&lt;p&gt;我们可以看到在 $T \rightarrow T*\cdot F$ 项的对应状态下，上面两个项所代表的状态其实就是 $T \rightarrow T*\cdot F$ 在试图匹配 $F$ 时的“子状态”或“等价状态”。&lt;&#x2F;p&gt;
&lt;p&gt;那么我们就把这两个状态和原先的 $T \rightarrow T*\cdot F$ 放在一个集合里面，称之为“ $T \rightarrow T*\cdot F$ 的项集闭包”，其中 $T \rightarrow T*\cdot F$ 称为闭包的核心。&lt;&#x2F;p&gt;
&lt;p&gt;那么项集闭包有啥用呢？我们仍然举上面文法的例子：&lt;&#x2F;p&gt;
&lt;p&gt;比如现在栈中有$...T*$，我们在 $T \rightarrow T*\cdot F$ 状态，我们看到前面有一个$&#x27;(&#x27;$，此时我们就可以根据这个$&#x27;(&#x27;$ 和项集闭包中的$F \rightarrow \cdot(E)$，转到$F \rightarrow (\cdot E)$ 状态，然后去匹配出一个 $F$，放到栈顶，然后进行 $T$ 的归约。&lt;&#x2F;p&gt;
&lt;p&gt;把所有的项、对应的项集闭包以及状态之间的转换关系列出来，我们就可以建立起一个 LR(0) 状态机：&lt;&#x2F;p&gt;
&lt;p&gt;&lt;img src=&quot;i100.png&quot; alt=&quot;i100&quot; &#x2F;&gt;&lt;&#x2F;p&gt;
&lt;p&gt;可以看到每一个产生式对应的所有项都会出现在这个状态机里面，而每条边上则指示了在栈顶又被压入某个符号时的状态转换。&lt;&#x2F;p&gt;
&lt;p&gt;其中$E&#x27;$是为了标记我们最终匹配到什么而设置的，其实这个例子来讲说到底就是$E$。&lt;&#x2F;p&gt;
&lt;h4 id=&quot;shang-shu-guo-cheng-de-suan-fa-miao-shu&quot;&gt;上述过程的算法描述&lt;&#x2F;h4&gt;
&lt;p&gt;这部分看看就行了，看懂了上面的你可以自己想到这些的。&lt;&#x2F;p&gt;
&lt;p&gt;根据龙书，上面的过程的算法描述为：&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;求每个LR(0)项，直接往所有每个产生式里能插的地方（包括开头和结尾）插入“$\cdot$”即可&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;对开始符号所在的项 $S&#x27;\rightarrow \cdot S$，求其闭包&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;寻找每个我们拿到的闭包在某个输入下转换到的项集（称为$GOTO$函数）&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;求法&lt;&#x2F;p&gt;
&lt;blockquote&gt;
&lt;p&gt;“If $A → α·Bβ$ is in $CLOSURE(I)$ and $B → γ$ is a production, then add the item $B → ·γ$ to $CLOSURE(I)$, if it is not already there. Apply this rule until no more new items can be added to $CLOSURE(I)$.”&lt;&#x2F;p&gt;
&lt;&#x2F;blockquote&gt;
&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;重复上一步，直到不再有新的项集出现为止&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;h3 id=&quot;shi-yong-lr-0-zhuang-tai-ji-jin-xing-pi-pei&quot;&gt;使用 LR(0) 状态机进行匹配&lt;&#x2F;h3&gt;
&lt;p&gt;为了存储一路匹配上来时经过的状态，我们需要在分析表中增设一个状态栈。&lt;&#x2F;p&gt;
&lt;p&gt;我不想再画上面那一百万行的巨大表格了，所以我们这次直接用龙书上的例子：&lt;&#x2F;p&gt;
&lt;p&gt;分析$\textbf{id} * \textbf{id}$：&lt;&#x2F;p&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;状态栈&lt;&#x2F;th&gt;&lt;th&gt;符号栈&lt;&#x2F;th&gt;&lt;th&gt;剩余输入&lt;&#x2F;th&gt;&lt;th&gt;动作&lt;&#x2F;th&gt;&lt;&#x2F;tr&gt;&lt;&#x2F;thead&gt;&lt;tbody&gt;
&lt;tr&gt;&lt;td&gt;$I_0$&lt;&#x2F;td&gt;&lt;td&gt;&lt;&#x2F;td&gt;&lt;td&gt;$\textbf{id} * \textbf{id}$&lt;&#x2F;td&gt;&lt;td&gt;根据状态机的标识，转到$I_5$（即压入状态栈），同时移进 $\textbf{id}$&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;$I_0I_5$&lt;&#x2F;td&gt;&lt;td&gt;$\textbf{id}$&lt;&#x2F;td&gt;&lt;td&gt;$* \textbf{id}$&lt;&#x2F;td&gt;&lt;td&gt;根据状态机的标识，无处可转，进行归约，弹状态栈&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;$I_0$&lt;&#x2F;td&gt;&lt;td&gt;$F$&lt;&#x2F;td&gt;&lt;td&gt;$* \textbf{id}$&lt;&#x2F;td&gt;&lt;td&gt;弹栈后进行下一步状态转移，转到$I_3$&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;$I_0I_3$&lt;&#x2F;td&gt;&lt;td&gt;$F$&lt;&#x2F;td&gt;&lt;td&gt;$* \textbf{id}$&lt;&#x2F;td&gt;&lt;td&gt;根据状态机的标识，无处可转，进行归约，弹状态栈&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;$I_0$&lt;&#x2F;td&gt;&lt;td&gt;$T$&lt;&#x2F;td&gt;&lt;td&gt;$* \textbf{id}$&lt;&#x2F;td&gt;&lt;td&gt;弹栈后进行下一步状态转移，转到$I_2$&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;$I_0I_2$&lt;&#x2F;td&gt;&lt;td&gt;$T$&lt;&#x2F;td&gt;&lt;td&gt;$* \textbf{id}$&lt;&#x2F;td&gt;&lt;td&gt;根据状态机的标识，转到$I_7$，同时移进 $*$&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;$I_0I_2I_7$&lt;&#x2F;td&gt;&lt;td&gt;$T*$&lt;&#x2F;td&gt;&lt;td&gt;$\textbf{id}$&lt;&#x2F;td&gt;&lt;td&gt;根据状态机的标识，转到$I_5$，同时移进 $\textbf{id}$&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;$I_0I_2I_7I_5$&lt;&#x2F;td&gt;&lt;td&gt;$T*\textbf{id}$&lt;&#x2F;td&gt;&lt;td&gt;&lt;&#x2F;td&gt;&lt;td&gt;根据状态机的标识，无处可转，进行归约，弹状态栈&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;$I_0I_2I_7$&lt;&#x2F;td&gt;&lt;td&gt;$T*F$&lt;&#x2F;td&gt;&lt;td&gt;&lt;&#x2F;td&gt;&lt;td&gt;弹栈后进行下一步状态转移，转到$I_{10}$&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;$I_0I_2I_{10}$&lt;&#x2F;td&gt;&lt;td&gt;$T$&lt;&#x2F;td&gt;&lt;td&gt;&lt;&#x2F;td&gt;&lt;td&gt;根据状态机的标识，无处可转，进行归约，弹状态栈&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;$I_0I_2$&lt;&#x2F;td&gt;&lt;td&gt;$E$&lt;&#x2F;td&gt;&lt;td&gt;&lt;&#x2F;td&gt;&lt;td&gt;根据状态机的标识，无处可转，进行归约，弹状态栈&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;$I_0$&lt;&#x2F;td&gt;&lt;td&gt;$E$&lt;&#x2F;td&gt;&lt;td&gt;&lt;&#x2F;td&gt;&lt;td&gt;弹栈后进行下一步状态转移，转到$I_1$&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;$I_0I_1$&lt;&#x2F;td&gt;&lt;td&gt;$E&#x27;$&lt;&#x2F;td&gt;&lt;td&gt;&lt;&#x2F;td&gt;&lt;td&gt;接受&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;&#x2F;tbody&gt;&lt;&#x2F;table&gt;
&lt;p&gt;注意我这里的步骤比龙书上多了些，龙书将“弹栈后进行下一步状态转移”这一步和下面的步骤合并起来写。&lt;&#x2F;p&gt;
&lt;p&gt;其实说实话你可以把这个状态栈用函数（递归）调用的方法消去的。&lt;&#x2F;p&gt;
&lt;h3 id=&quot;chong-tu&quot;&gt;冲突&lt;&#x2F;h3&gt;
&lt;p&gt;看了上面的步骤你会发现，LR(0) 的每个项集闭包中不可以包含：&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;一个项认为已经可以归约了，另一个项认为还需要移进
$$
A \rightarrow a\cdot b
$$
$$
B \rightarrow c \cdot
$$&lt;&#x2F;p&gt;
&lt;p&gt;这称为移进-归约冲突。&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;两个项认为可以归约出不同的东西
$$
A \rightarrow b \cdot
$$
$$
C \rightarrow d \cdot
$$&lt;&#x2F;p&gt;
&lt;p&gt;这称为归约-归约冲突。&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;有此类冲突的不是LR(0)文法，需要用其他分析方法分析。&lt;&#x2F;p&gt;
&lt;div class=&quot;footnote-definition&quot; id=&quot;0&quot;&gt;&lt;sup class=&quot;footnote-definition-label&quot;&gt;1&lt;&#x2F;sup&gt;
&lt;p&gt;这里也可以理解成，匹配完了$E+$ 之后，再递归地（用“干净”的栈帧）匹配后面的以$T*$开头的内容&lt;&#x2F;p&gt;
&lt;&#x2F;div&gt;
</content>
	</entry>
	<entry xml:lang="zh">
		<title>Parsing • 移进-归约分析</title>
		<published>2020-05-22T22:56:58.045+00:00</published>
		<updated>2020-05-22T22:56:58.045+00:00</updated>
		<link href="https://longfangsong.github.io/shift-reduce/" type="text/html"/>
		<id>https://longfangsong.github.io/shift-reduce/</id>
		<content type="html">&lt;p&gt;回忆你很可能在大一大二&lt;sup class=&quot;footnote-reference&quot;&gt;&lt;a href=&quot;#1&quot;&gt;1&lt;&#x2F;a&gt;&lt;&#x2F;sup&gt;写过的运用栈进行表达式求值的程序，我们将其简化到只支持加法和乘法，这里给出一个Rust语言的例子（写的比较随意……），太长不看党可以直接跳过看下面的分析：&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;let mut&lt;&#x2F;span&gt;&lt;span&gt; input = String::new();
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;stdin&lt;&#x2F;span&gt;&lt;span&gt;().&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;read_to_string&lt;&#x2F;span&gt;&lt;span&gt;(&amp;amp;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;mut&lt;&#x2F;span&gt;&lt;span&gt; input).&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;unwrap&lt;&#x2F;span&gt;&lt;span&gt;();
&lt;&#x2F;span&gt;&lt;span&gt;    input = input.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;trim&lt;&#x2F;span&gt;&lt;span&gt;().&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;to_owned&lt;&#x2F;span&gt;&lt;span&gt;();
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;let mut&lt;&#x2F;span&gt;&lt;span&gt; current_number = String::new();
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;let mut&lt;&#x2F;span&gt;&lt;span&gt; stack = Vec::new();
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;for&lt;&#x2F;span&gt;&lt;span&gt; ch in input.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;chars&lt;&#x2F;span&gt;&lt;span&gt;() {
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;match&lt;&#x2F;span&gt;&lt;span&gt; ch {
&lt;&#x2F;span&gt;&lt;span&gt;            &amp;#39;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;0&lt;&#x2F;span&gt;&lt;span&gt;&amp;#39;..=&amp;#39;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;9&lt;&#x2F;span&gt;&lt;span&gt;&amp;#39; =&amp;gt; current_number.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;push&lt;&#x2F;span&gt;&lt;span&gt;(ch),
&lt;&#x2F;span&gt;&lt;span&gt;            &amp;#39;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;+&lt;&#x2F;span&gt;&lt;span&gt;&amp;#39; | &amp;#39;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;*&lt;&#x2F;span&gt;&lt;span&gt;&amp;#39; =&amp;gt; {
&lt;&#x2F;span&gt;&lt;span&gt;                &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;if &lt;&#x2F;span&gt;&lt;span&gt;!current_number.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;is_empty&lt;&#x2F;span&gt;&lt;span&gt;() {
&lt;&#x2F;span&gt;&lt;span&gt;                    stack.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;push&lt;&#x2F;span&gt;&lt;span&gt;(Token::Value(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;i32&lt;&#x2F;span&gt;&lt;span&gt;::from_str(&amp;amp;current_number).&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;unwrap&lt;&#x2F;span&gt;&lt;span&gt;()));
&lt;&#x2F;span&gt;&lt;span&gt;                    current_number = String::new();
&lt;&#x2F;span&gt;&lt;span&gt;                }
&lt;&#x2F;span&gt;&lt;span&gt;                &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; top_op = stack.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;iter&lt;&#x2F;span&gt;&lt;span&gt;().&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;rev&lt;&#x2F;span&gt;&lt;span&gt;()
&lt;&#x2F;span&gt;&lt;span&gt;                    .&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;find_map&lt;&#x2F;span&gt;&lt;span&gt;(|&amp;amp;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;it&lt;&#x2F;span&gt;&lt;span&gt;| &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;if let &lt;&#x2F;span&gt;&lt;span&gt;Token::Op(op) = it { Some(op) } &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;else &lt;&#x2F;span&gt;&lt;span&gt;{ None });
&lt;&#x2F;span&gt;&lt;span&gt;                &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;if&lt;&#x2F;span&gt;&lt;span&gt; top_op.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;is_some&lt;&#x2F;span&gt;&lt;span&gt;() {
&lt;&#x2F;span&gt;&lt;span&gt;                    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;let mut&lt;&#x2F;span&gt;&lt;span&gt; top_op = top_op.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;unwrap&lt;&#x2F;span&gt;&lt;span&gt;();
&lt;&#x2F;span&gt;&lt;span&gt;                    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;&#x2F;&#x2F; 下面的条件实际上是&amp;quot;栈上最后一个操作符优先级大于等于当前读到的操作符&amp;quot;
&lt;&#x2F;span&gt;&lt;span&gt;                    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;while&lt;&#x2F;span&gt;&lt;span&gt; ch == &amp;#39;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;+&lt;&#x2F;span&gt;&lt;span&gt;&amp;#39; || top_op == &amp;#39;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;*&lt;&#x2F;span&gt;&lt;span&gt;&amp;#39; {
&lt;&#x2F;span&gt;&lt;span&gt;                        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; op2 = stack.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;pop&lt;&#x2F;span&gt;&lt;span&gt;().&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;unwrap&lt;&#x2F;span&gt;&lt;span&gt;();
&lt;&#x2F;span&gt;&lt;span&gt;                        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; op = stack.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;pop&lt;&#x2F;span&gt;&lt;span&gt;().&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;unwrap&lt;&#x2F;span&gt;&lt;span&gt;(); &lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;&#x2F;&#x2F; should be equal to top_op
&lt;&#x2F;span&gt;&lt;span&gt;                        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; op1 = stack.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;pop&lt;&#x2F;span&gt;&lt;span&gt;().&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;unwrap&lt;&#x2F;span&gt;&lt;span&gt;();
&lt;&#x2F;span&gt;&lt;span&gt;                        stack.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;push&lt;&#x2F;span&gt;&lt;span&gt;(Token::Value(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;eval&lt;&#x2F;span&gt;&lt;span&gt;(op1, op, op2)));
&lt;&#x2F;span&gt;&lt;span&gt;                        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; next_top_op = stack.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;iter&lt;&#x2F;span&gt;&lt;span&gt;().&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;rev&lt;&#x2F;span&gt;&lt;span&gt;()
&lt;&#x2F;span&gt;&lt;span&gt;                            .&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;find_map&lt;&#x2F;span&gt;&lt;span&gt;(|&amp;amp;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;it&lt;&#x2F;span&gt;&lt;span&gt;| &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;if let &lt;&#x2F;span&gt;&lt;span&gt;Token::Op(op) = it { Some(op) } &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;else &lt;&#x2F;span&gt;&lt;span&gt;{ None });
&lt;&#x2F;span&gt;&lt;span&gt;                        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;if&lt;&#x2F;span&gt;&lt;span&gt; next_top_op.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;is_none&lt;&#x2F;span&gt;&lt;span&gt;() { &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;break&lt;&#x2F;span&gt;&lt;span&gt;; }
&lt;&#x2F;span&gt;&lt;span&gt;                        top_op = next_top_op.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;unwrap&lt;&#x2F;span&gt;&lt;span&gt;()
&lt;&#x2F;span&gt;&lt;span&gt;                    }
&lt;&#x2F;span&gt;&lt;span&gt;                }
&lt;&#x2F;span&gt;&lt;span&gt;                stack.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;push&lt;&#x2F;span&gt;&lt;span&gt;(Token::Op(ch));
&lt;&#x2F;span&gt;&lt;span&gt;            }
&lt;&#x2F;span&gt;&lt;span&gt;            _ =&amp;gt; unreachable!()
&lt;&#x2F;span&gt;&lt;span&gt;        }
&lt;&#x2F;span&gt;&lt;span&gt;    }
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;if &lt;&#x2F;span&gt;&lt;span&gt;!current_number.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;is_empty&lt;&#x2F;span&gt;&lt;span&gt;() {
&lt;&#x2F;span&gt;&lt;span&gt;        stack.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;push&lt;&#x2F;span&gt;&lt;span&gt;(Token::Value(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;i32&lt;&#x2F;span&gt;&lt;span&gt;::from_str(&amp;amp;current_number).&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;unwrap&lt;&#x2F;span&gt;&lt;span&gt;()));
&lt;&#x2F;span&gt;&lt;span&gt;        current_number.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;clear&lt;&#x2F;span&gt;&lt;span&gt;();
&lt;&#x2F;span&gt;&lt;span&gt;    }
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;let mut&lt;&#x2F;span&gt;&lt;span&gt; top_op = stack.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;iter&lt;&#x2F;span&gt;&lt;span&gt;().&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;rev&lt;&#x2F;span&gt;&lt;span&gt;()
&lt;&#x2F;span&gt;&lt;span&gt;        .&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;find_map&lt;&#x2F;span&gt;&lt;span&gt;(|&amp;amp;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;it&lt;&#x2F;span&gt;&lt;span&gt;| &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;if let &lt;&#x2F;span&gt;&lt;span&gt;Token::Op(op) = it { Some(op) } &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;else &lt;&#x2F;span&gt;&lt;span&gt;{ None });
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;while&lt;&#x2F;span&gt;&lt;span&gt; top_op.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;is_some&lt;&#x2F;span&gt;&lt;span&gt;() {
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; op2 = stack.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;pop&lt;&#x2F;span&gt;&lt;span&gt;().&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;unwrap&lt;&#x2F;span&gt;&lt;span&gt;();
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; op = stack.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;pop&lt;&#x2F;span&gt;&lt;span&gt;().&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;unwrap&lt;&#x2F;span&gt;&lt;span&gt;();
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; op1 = stack.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;pop&lt;&#x2F;span&gt;&lt;span&gt;().&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;unwrap&lt;&#x2F;span&gt;&lt;span&gt;();
&lt;&#x2F;span&gt;&lt;span&gt;        stack.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;push&lt;&#x2F;span&gt;&lt;span&gt;(Token::Value(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;eval&lt;&#x2F;span&gt;&lt;span&gt;(op1, op, op2)));
&lt;&#x2F;span&gt;&lt;span&gt;        top_op = stack.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;iter&lt;&#x2F;span&gt;&lt;span&gt;().&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;rev&lt;&#x2F;span&gt;&lt;span&gt;()
&lt;&#x2F;span&gt;&lt;span&gt;            .&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;find_map&lt;&#x2F;span&gt;&lt;span&gt;(|&amp;amp;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;it&lt;&#x2F;span&gt;&lt;span&gt;| &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;if let &lt;&#x2F;span&gt;&lt;span&gt;Token::Op(op) = it { Some(op) } &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;else &lt;&#x2F;span&gt;&lt;span&gt;{ None });
&lt;&#x2F;span&gt;&lt;span&gt;    }
&lt;&#x2F;span&gt;&lt;span&gt;		println!(&amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;{:?}&lt;&#x2F;span&gt;&lt;span&gt;&amp;quot;, stack[&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;0&lt;&#x2F;span&gt;&lt;span&gt;]);
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;我们以表达式$1+2*3+4$的求值来观察这一过程：&lt;&#x2F;p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;输入数字1，压入栈中&lt;&#x2F;p&gt;
&lt;p&gt;&lt;img src=&quot;i1.svg&quot; alt=&quot;i1&quot; &#x2F;&gt;&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;输入操作符&#x27;+&#x27;，压入栈中&lt;&#x2F;p&gt;
&lt;p&gt;&lt;img src=&quot;i2.svg&quot; alt=&quot;i2&quot; &#x2F;&gt;&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;输入数字2，压入栈中&lt;&#x2F;p&gt;
&lt;p&gt;&lt;img src=&quot;i3.svg&quot; alt=&quot;i3&quot; &#x2F;&gt;&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;输入操作符&#x27;*&#x27;，压入栈中&lt;&#x2F;p&gt;
&lt;p&gt;&lt;img src=&quot;i4.svg&quot; alt=&quot;i4&quot; &#x2F;&gt;&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;输入数字3，压入栈中&lt;&#x2F;p&gt;
&lt;p&gt;&lt;img src=&quot;i5.svg&quot; alt=&quot;i5&quot; &#x2F;&gt;&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;输入操作符&#x27;+&#x27;，优先级低于栈中最后一个压入的运算符，先对栈中内容求值，再将&#x27;+&#x27;压入栈中&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&#x27;*&#x27;优先级高于&#x27;+&#x27;，求值&lt;&#x2F;p&gt;
&lt;p&gt;&lt;img src=&quot;i6.svg&quot; alt=&quot;i6&quot; &#x2F;&gt;&lt;&#x2F;p&gt;
&lt;p&gt;&lt;img src=&quot;i7.svg&quot; alt=&quot;i7&quot; &#x2F;&gt;&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;&#x27;+&#x27;优先级等于&#x27;+&#x27;，求值&lt;&#x2F;p&gt;
&lt;p&gt;&lt;img src=&quot;i8.svg&quot; alt=&quot;i8&quot; &#x2F;&gt;&lt;&#x2F;p&gt;
&lt;p&gt;&lt;img src=&quot;i9.svg&quot; alt=&quot;i9&quot; &#x2F;&gt;&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;栈中没有运算符了，压入&#x27;+&#x27;&lt;&#x2F;p&gt;
&lt;p&gt;&lt;img src=&quot;i10.svg&quot; alt=&quot;i10&quot; &#x2F;&gt;&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;看到数字4，压入&lt;&#x2F;p&gt;
&lt;p&gt;&lt;img src=&quot;i11.svg&quot; alt=&quot;i11&quot; &#x2F;&gt;&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;没有输入了，不断求值直到没有更多运算符&lt;&#x2F;p&gt;
&lt;p&gt;&lt;img src=&quot;i12.svg&quot; alt=&quot;i12&quot; &#x2F;&gt;&lt;&#x2F;p&gt;
&lt;p&gt;&lt;img src=&quot;i13.svg&quot; alt=&quot;i13&quot; &#x2F;&gt;&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
&lt;p&gt;这里的11就是我们求得得答案。&lt;&#x2F;p&gt;
&lt;h2 id=&quot;yi-jin-he-gui-yue&quot;&gt;移进和归约&lt;&#x2F;h2&gt;
&lt;p&gt;我们看到，我们上面的分析过程中出现了两种操作：&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;移进：将输入的值或者操作符&lt;strong&gt;压入&lt;&#x2F;strong&gt;栈中&lt;&#x2F;li&gt;
&lt;li&gt;归约：将输入的值和&lt;strong&gt;栈顶&lt;&#x2F;strong&gt;的某几个值经过计算，变为一般来说更少的几个值，&lt;strong&gt;压回&lt;&#x2F;strong&gt;栈中&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;我们可以将“值”、“操作符”推广到“文法元素”，得到了文法分析中的移进和归约&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;移进：将输入的某个token&lt;strong&gt;压入&lt;&#x2F;strong&gt;栈中&lt;&#x2F;li&gt;
&lt;li&gt;归约：将输入的值和&lt;strong&gt;栈顶&lt;&#x2F;strong&gt;的某几个文法元素经过计算，变为一般来说更少的几个文法元素，&lt;strong&gt;压回&lt;&#x2F;strong&gt;栈中&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;那么我们就能将上面的例子推广到更一般的，非数字的场景，以文法&lt;sup class=&quot;footnote-reference&quot;&gt;&lt;a href=&quot;#2&quot;&gt;2&lt;&#x2F;a&gt;&lt;&#x2F;sup&gt;：
$$
Expr \rightarrow id | Expr + Expr | Expr * Expr
$$
和表达式$a+b*c+d$为例（图中的所有蓝色节点均代表$Expr$，其中复杂$Expr$已经画为AST的样子）：&lt;&#x2F;p&gt;
&lt;p&gt;&lt;img src=&quot;i14.svg&quot; alt=&quot;i14&quot; &#x2F;&gt;&lt;&#x2F;p&gt;
&lt;p&gt;通过简单地将上面求值中的数字改为了文法元素（也即AST的节点），我们容易地将表达式求值的方法扩展到了求表达式对应的AST。&lt;&#x2F;p&gt;
&lt;h2 id=&quot;chong-tu&quot;&gt;冲突&lt;&#x2F;h2&gt;
&lt;p&gt;在移进-归约分析过程中，可能会遇到某些情况下，有多种可能使用的行为，例如：&lt;&#x2F;p&gt;
&lt;p&gt;&lt;img src=&quot;i3.svg&quot; alt=&quot;i3&quot; &#x2F;&gt;&lt;&#x2F;p&gt;
&lt;p&gt;此时是否应当将1+2归约为3？这就要等到下一个操作符到来才能决定。&lt;&#x2F;p&gt;
&lt;h3 id=&quot;yi-jin-gui-yue-chong-tu&quot;&gt;移进-归约冲突&lt;&#x2F;h3&gt;
&lt;p&gt;当某个输入可以选择与栈中内容结合，进行归约，也可以选择直接压入栈，后续再进行归约时，就说我们遇到了一个移进-归约冲突。&lt;&#x2F;p&gt;
&lt;p&gt;上述的例子就是一个典型的移进-归约冲突。&lt;&#x2F;p&gt;
&lt;h3 id=&quot;gui-yue-gui-yue-chong-tu&quot;&gt;归约-归约冲突&lt;&#x2F;h3&gt;
&lt;p&gt;当我们遇到了某个输入与栈中内容结合，其结构符合多个产生式时，可以有多种方式进行归约，这时就说我们遇到了一个归约-归约冲突。&lt;&#x2F;p&gt;
&lt;div class=&quot;footnote-definition&quot; id=&quot;1&quot;&gt;&lt;sup class=&quot;footnote-definition-label&quot;&gt;1&lt;&#x2F;sup&gt;
&lt;p&gt;&lt;del&gt;我初三就会写了，你来打我呀&lt;&#x2F;del&gt;（虽然当年写的爆炸丑陋）&lt;&#x2F;p&gt;
&lt;&#x2F;div&gt;
&lt;div class=&quot;footnote-definition&quot; id=&quot;2&quot;&gt;&lt;sup class=&quot;footnote-definition-label&quot;&gt;2&lt;&#x2F;sup&gt;
&lt;p&gt;这里要注意其实可以说归约时用的产生式是$Expr+ \rightarrow Expr*Expr+|Expr+Expr+$，这样就没有了优先级这个概念，但这样就是个上下文有关文法了。&lt;&#x2F;p&gt;
&lt;&#x2F;div&gt;
</content>
	</entry>
	<entry xml:lang="zh">
		<title>Parsing • LL(1)文法的分析，以及First集和Follow集究竟是什么</title>
		<published>2020-05-17T16:37:01.045+00:00</published>
		<updated>2020-05-17T16:37:01.045+00:00</updated>
		<link href="https://longfangsong.github.io/ll1/" type="text/html"/>
		<id>https://longfangsong.github.io/ll1/</id>
		<content type="html">&lt;h2 id=&quot;wei-shi-yao-xu-yao-firstji-he-followji&quot;&gt;为什么需要First集和Follow集&lt;&#x2F;h2&gt;
&lt;p&gt;了解&lt;a href=&quot;https:&#x2F;&#x2F;longfangsong.github.io&#x2F;parsing-combinator&#x2F;&quot;&gt;带回朔的递归下降文法分析方法&lt;&#x2F;a&gt;的同学可能会发现这种分析法由于在文法中每个出现 &lt;code&gt;|&lt;&#x2F;code&gt; 的点上，都会&lt;strong&gt;尝试&lt;&#x2F;strong&gt;这个点上所有可能的生成式，直到有一个匹配成功为止，这种方案虽然保证了对所有文法中的句子，最终都能通过这种方式构建出其语法树，但由于可能存在的大量回朔，效率就会收到影响。&lt;&#x2F;p&gt;
&lt;p&gt;那么我们就要想了，有没有什么方法可以选择出这个点上&lt;strong&gt;唯一&lt;&#x2F;strong&gt;的生成式，来消除所有回朔的可能性，这样效率就能大大提升了。&lt;&#x2F;p&gt;
&lt;p&gt;事实证明，对于一部分文法来说，这么做是可能的。&lt;&#x2F;p&gt;
&lt;h2 id=&quot;ke-yi-xuan-chu-wei-yi-sheng-cheng-shi-de-shi-li&quot;&gt;可以选出唯一生成式的实例&lt;&#x2F;h2&gt;
&lt;p&gt;例如下面一个（消除了左递归的，所有的$|$都拆开了的）文法：
$$
\displaylines {
E \rightarrow T E&#x27; \\
E&#x27; \rightarrow + T E&#x27; \\
E&#x27; \rightarrow \epsilon \\
T \rightarrow F T&#x27; \\
T&#x27; \rightarrow * FT&#x27; \\
T&#x27; \rightarrow \epsilon \\
F \rightarrow (E) \\
F \rightarrow id
}
$$
可以看出，在调用某个（直接或间接）带有&lt;code&gt;|&lt;&#x2F;code&gt;的parse函数，并看到了下一个输入为某个符号时，选用的生成式是：&lt;&#x2F;p&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;parse\输入符号&lt;&#x2F;th&gt;&lt;th&gt;$id$&lt;&#x2F;th&gt;&lt;th&gt;$+$&lt;&#x2F;th&gt;&lt;th&gt;$*$&lt;&#x2F;th&gt;&lt;th&gt;$($&lt;&#x2F;th&gt;&lt;th&gt;$)$&lt;&#x2F;th&gt;&lt;th&gt;输入结束（接受输入）&lt;&#x2F;th&gt;&lt;&#x2F;tr&gt;&lt;&#x2F;thead&gt;&lt;tbody&gt;
&lt;tr&gt;&lt;td&gt;$E$&lt;&#x2F;td&gt;&lt;td&gt;$E\rightarrow TE&#x27;$&lt;&#x2F;td&gt;&lt;td&gt;&lt;&#x2F;td&gt;&lt;td&gt;&lt;&#x2F;td&gt;&lt;td&gt;$E\rightarrow TE&#x27;$&lt;&#x2F;td&gt;&lt;td&gt;&lt;&#x2F;td&gt;&lt;td&gt;&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;$E&#x27;$&lt;&#x2F;td&gt;&lt;td&gt;&lt;&#x2F;td&gt;&lt;td&gt;$E&#x27;\rightarrow +TE&#x27;$&lt;&#x2F;td&gt;&lt;td&gt;&lt;&#x2F;td&gt;&lt;td&gt;&lt;&#x2F;td&gt;&lt;td&gt;$E&#x27;\rightarrow \epsilon$&lt;&#x2F;td&gt;&lt;td&gt;$E&#x27;\rightarrow \epsilon$&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;$T$&lt;&#x2F;td&gt;&lt;td&gt;$T\rightarrow FT&#x27;$&lt;&#x2F;td&gt;&lt;td&gt;&lt;&#x2F;td&gt;&lt;td&gt;&lt;&#x2F;td&gt;&lt;td&gt;$T\rightarrow FT&#x27;$&lt;&#x2F;td&gt;&lt;td&gt;&lt;&#x2F;td&gt;&lt;td&gt;&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;$T&#x27;$&lt;&#x2F;td&gt;&lt;td&gt;&lt;&#x2F;td&gt;&lt;td&gt;$T&#x27;\rightarrow \epsilon$&lt;&#x2F;td&gt;&lt;td&gt;$T&#x27;\rightarrow *FT&#x27;$&lt;&#x2F;td&gt;&lt;td&gt;&lt;&#x2F;td&gt;&lt;td&gt;$T&#x27;\rightarrow \epsilon$&lt;&#x2F;td&gt;&lt;td&gt;$T&#x27;\rightarrow \epsilon$&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;$F$&lt;&#x2F;td&gt;&lt;td&gt;$F\rightarrow id$&lt;&#x2F;td&gt;&lt;td&gt;&lt;&#x2F;td&gt;&lt;td&gt;&lt;&#x2F;td&gt;&lt;td&gt;$F\rightarrow (E)$&lt;&#x2F;td&gt;&lt;td&gt;&lt;&#x2F;td&gt;&lt;td&gt;&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;&#x2F;tbody&gt;&lt;&#x2F;table&gt;
&lt;p&gt;这里生成式的选择（即每个格子中的产生式）正是唯一的。&lt;&#x2F;p&gt;
&lt;p&gt;那么如何求这张表呢？&lt;&#x2F;p&gt;
&lt;p&gt;容易想到的是，对某个产生式：
$$
A \rightarrow BCD...X
$$
检查其能生成的每个句子中的第一个符号，并将该产生式填入$A$对应行中，这些符号的对应的列中即可。&lt;&#x2F;p&gt;
&lt;p&gt;而求出“能生成的每个句子中的第一个符号”的方法是：按顺序检查$B,C,D...X$中的每一个，如果这个符号是$\epsilon$，那么略过这个符号继续往下看就好了（如果后面啥也没有了，那就把$\epsilon$看成是终结符），如果是终结符，那这“第一个符号”就是它了，如果是非终结符，那么递归地往下看这个符号就好了。&lt;&#x2F;p&gt;
&lt;p&gt;取前面例子中的$E \rightarrow T E&#x27;$为例：&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;检查$T$，是非终结符，递归地向下看，有：&lt;&#x2F;p&gt;
&lt;p&gt;$T \rightarrow F T&#x27;$&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;检查$F$，是非终结符，递归地向下看，有：&lt;&#x2F;p&gt;
&lt;p&gt;$F \rightarrow (E)$&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;检查&#x27;$($&#x27;，是终结符，故下一步看到&#x27;$($&#x27;时，可以选择$E \rightarrow T E&#x27;$，填入表$E$行&#x27;$)$&#x27;列中。&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;$F \rightarrow id$&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;检查$id$，是终结符，故下一步看到$id$时，可以选择$E \rightarrow T E&#x27;$，填入表$E$行$id$列中。&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;$F$不会为$\epsilon$，故到此结束&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;$T$不会为$\epsilon$，故到此结束&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;考虑过每个非终结符对应的产生式后，对应的这一行除了最后一列就填好了，非终结符全部考虑过后，这整个表除了最后一列就都填好了。&lt;&#x2F;p&gt;
&lt;p&gt;最后一列的事情暂时按下不表，我们此时已经自己推出了这个First集了。&lt;&#x2F;p&gt;
&lt;h2 id=&quot;firstji&quot;&gt;First集&lt;&#x2F;h2&gt;
&lt;p&gt;到这里，你就已经自己发明出First集的定义与求法了：&lt;&#x2F;p&gt;
&lt;h3 id=&quot;ding-yi&quot;&gt;定义&lt;&#x2F;h3&gt;
&lt;p&gt;龙书的定义里面有一堆数学符号，其实说到底和我上面的定义完全一致。&lt;&#x2F;p&gt;
&lt;blockquote&gt;
&lt;p&gt;Define $FIRST(α)$, where $α$ is any string of grammar symbols, to be the set of terminals that begin strings derived from $α$. If $\alpha \stackrel{*}{\Rightarrow} \epsilon$, then $\epsilon$ is also in $FIRST(α)$.  ——  “Compilers: Principles, Techniques, and Tools, 2&#x2F;e” &lt;&#x2F;p&gt;
&lt;&#x2F;blockquote&gt;
&lt;p&gt;定义$FIRST(α)$，其中$\alpha$是一个语法符号构成的任意串，为一组可以被$\alpha$推导出的终结符串的起始字符的集合。如果$\alpha \stackrel{*}{\Rightarrow} \epsilon$，那$\epsilon$也在$FIRST(α)$中。&lt;&#x2F;p&gt;
&lt;p&gt;这不就是我们上面说的“能生成的每个句子中的第一个符号”按照推导式左侧的非终结符全部并起来的结果吗。&lt;&#x2F;p&gt;
&lt;h3 id=&quot;qiu-fa&quot;&gt;求法&lt;&#x2F;h3&gt;
&lt;p&gt;同理，数学符号……&lt;&#x2F;p&gt;
&lt;blockquote&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;If X is a terminal, then $FIRST(X) = {X}$.&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;If X is a nonterminal and $X → Y_1Y_2 ... Y_k$ is a production for some $k \ge 1$, then place &#x27;a&#x27; in $FIRST(X)$ if for some $i$, &#x27;a&#x27; is in $FIRST(Y_i)$, and $\epsilon$ is in all of $FIRST(Y_1), ..., FIRST(Y_{i – 1})$; that is, $Y_1Y_2...Y_{i-1} \stackrel{*}{\Rightarrow} \epsilon$. &lt;&#x2F;p&gt;
&lt;p&gt;If $\epsilon$ is in $FIRST(Y_j)$ for all $j = 1, 2, ..., k$, then add $\epsilon$ to $FIRST(X)$. &lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;If $X \rightarrow \epsilon$ is a production, then add $\epsilon$ to $FIRST(X)$.&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
&lt;p&gt;—— “Compilers: Principles, Techniques, and Tools, 2&#x2F;e” &lt;&#x2F;p&gt;
&lt;&#x2F;blockquote&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;若X是终结符，则$FIRST(X) = {X}$&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;若X是非终结符：&lt;&#x2F;p&gt;
&lt;p&gt;若$\epsilon$ 在所有 $FIRST(Y_1), ..., FIRST(Y_{i – 1})$ 中，在&#x27;a&#x27; 在 $FIRST(Y_i)$中。则&#x27;a&#x27;也在$FIRST(X)$中。&lt;&#x2F;p&gt;
&lt;p&gt;若对所有$j = 1, 2, ..., k$，$\epsilon$都在$FIRST(Y_j)$中，则$\epsilon$也在$FIRST(X)$中。&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;若有生成式$X\rightarrow \epsilon$，则$\epsilon$也在$FIRST(X)$中。&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
&lt;p&gt;和上面我们自己推出的求法相比也非常相似，不过是按照推导式左侧的非终结符全部并起来的结果。&lt;&#x2F;p&gt;
&lt;p&gt;而这种求法，显然是可以用动态规划法加速的。&lt;&#x2F;p&gt;
&lt;h2 id=&quot;zui-hou-yi-lie&quot;&gt;最后一列&lt;&#x2F;h2&gt;
&lt;p&gt;那这个最后一列怎么处理呢？&lt;&#x2F;p&gt;
&lt;p&gt;也很简单，如果从起始符号开始，在经过数次推导之后，在由某个非终结符作为最右边的非终结符时推导可以使整个文法的分析结束，这个非终结符对应推出$\epsilon$的推导式就能填在最后一列对应的行中。&lt;sup class=&quot;footnote-reference&quot;&gt;&lt;a href=&quot;#1&quot;&gt;1&lt;&#x2F;a&gt;&lt;&#x2F;sup&gt;&lt;&#x2F;p&gt;
&lt;p&gt;那么怎么找出这些“从起始符号开始，在经过数次推导&lt;sup class=&quot;footnote-reference&quot;&gt;&lt;a href=&quot;#2&quot;&gt;2&lt;&#x2F;a&gt;&lt;&#x2F;sup&gt;之后，作为最右边的非终结符时推导可以使整个文法的分析结束”的非终结符号呢？&lt;&#x2F;p&gt;
&lt;p&gt;首先我们可以看开始符号最右边的符号，这个符号一定符合我们的要求，在这里这个符号是$E &#x27;$。&lt;&#x2F;p&gt;
&lt;p&gt;如果对某个符合条件的符号$Z$和另外某个（单个）符号$X$，有产生式$Z\rightarrow YX$或$Z\rightarrow YXW$，其中$W \stackrel{*}{\Rightarrow} \epsilon$，则$X$也符合要求。&lt;&#x2F;p&gt;
&lt;p&gt;从我们的例子上来看，将上面的$Z$可以带入$E&#x27;$和$E$，有：&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;$E\rightarrow TE&#x27;$，而存在$E&#x27; \rightarrow \epsilon$，故$T$也符合要求，但不能推出$\epsilon$&lt;&#x2F;li&gt;
&lt;li&gt;$T \rightarrow* FT&#x27;$，故$T&#x27; $也符合要求，将$T&#x27; \rightarrow \epsilon$填入适当位置&lt;&#x2F;li&gt;
&lt;li&gt;$T \rightarrow* FT&#x27;$，而存在$T&#x27; \rightarrow \epsilon$，故$F$也符合要求，但$F$不能推出$\epsilon$&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;h2 id=&quot;followji&quot;&gt;Follow集&lt;&#x2F;h2&gt;
&lt;h3 id=&quot;ding-yi-1&quot;&gt;定义&lt;&#x2F;h3&gt;
&lt;p&gt;Follow集的定义在我们上面的求法的基础上进行了扩展：&lt;&#x2F;p&gt;
&lt;blockquote&gt;
&lt;p&gt;“Define $FOLLOW(A)$, for nonterminal A, to be the set of terminals $a$ that can appear immediately to the right of A in some sentential form; that is, the set of terminals a such that there exists a derivation of the form $S \stackrel{*}{\Rightarrow} \alpha Aa\beta$, for some $\alpha$ and $\beta$”&lt;&#x2F;p&gt;
&lt;p&gt;——  “Compilers: Principles, Techniques, and Tools, 2&#x2F;e” &lt;&#x2F;p&gt;
&lt;&#x2F;blockquote&gt;
&lt;p&gt;Follow集就是在文法的所有句子中，可能出现在“由非终结符A生成的部分”之后的终结符的集合。而上述例子所求的其实就是这里的“终结符”为“输入结束标记”的特例。&lt;&#x2F;p&gt;
&lt;h3 id=&quot;qiu-fa-1&quot;&gt;求法&lt;&#x2F;h3&gt;
&lt;blockquote&gt;
&lt;ol&gt;
&lt;li&gt;Place $\$$ in $FOLLOW(S)$, where S is the start symbol, and $ is the input right endmarker.&lt;&#x2F;li&gt;
&lt;li&gt;If there is a production $A → αBβ$, then everything in $FIRST(β)$ except $\epsilon$ is in $FOLLOW(B)$.&lt;&#x2F;li&gt;
&lt;li&gt;If there is a production $A → αB$, or a production $A → αBβ$, where $FIRST(β)$ contains $\epsilon$, then everything in $FOLLOW(A)$is in $FOLLOW(B)$.
—— “Compilers: Principles, Techniques, and Tools, 2&#x2F;e”&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
&lt;&#x2F;blockquote&gt;
&lt;ol&gt;
&lt;li&gt;输入结束标记（龙书中称为$\$$）在$FOLLOW(S)$中&lt;&#x2F;li&gt;
&lt;li&gt;若有$A → αBβ$，则 $FIRST(β)$ 中所有不为 $\epsilon$ 的元素都在 $FOLLOW(B)$ 中&lt;&#x2F;li&gt;
&lt;li&gt;若有$A → αB$，或 $A → αBβ$，其中 $FIRST(β)$ 包含 $\epsilon$ 则 $FOLLOW(A)$ 中的所有元素也在 $FOLLOW(B)$ 中。&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
&lt;p&gt;和我们上面的例子唯一差别在于第2条，不过也很好想，$FIRST(β)$就是$\beta$能推出的第一个非终结符的所有可能取值的集合，而$B$与$β$是紧挨着的，$B$的下一个元素就是$\beta$的第一个元素（$\epsilon$除外）。&lt;&#x2F;p&gt;
&lt;h2 id=&quot;zong-jie&quot;&gt;总结&lt;&#x2F;h2&gt;
&lt;p&gt;有了上面讲的填这类表的方法之后，对于填完后每个格子至多只有一个推导式的文法，我们就可以写出完全不含有回朔的自顶向下文法分析器（递归或者非递归均可），这类文法也就是$LL(1)$文法。当然如果将表头中的一个符号变为多个符号的组合，这种方法也可以推广到$LL(N)$文法上。&lt;&#x2F;p&gt;
&lt;p&gt;同时我们也终于明白了$FIRST$集和$FOLLOW$集的求法，这两个集合在之后的移进-规约分析中也有用。&lt;&#x2F;p&gt;
&lt;div class=&quot;footnote-definition&quot; id=&quot;1&quot;&gt;&lt;sup class=&quot;footnote-definition-label&quot;&gt;1&lt;&#x2F;sup&gt;
&lt;p&gt;这里可能要自己感觉一下，如果有人有更好的讲法，请在评论区留言&lt;&#x2F;p&gt;
&lt;&#x2F;div&gt;
&lt;div class=&quot;footnote-definition&quot; id=&quot;2&quot;&gt;&lt;sup class=&quot;footnote-definition-label&quot;&gt;2&lt;&#x2F;sup&gt;
&lt;p&gt;注意这里“数次”含0次，所以起始符号自然符合要求&lt;&#x2F;p&gt;
&lt;&#x2F;div&gt;
</content>
	</entry>
	<entry xml:lang="zh">
		<title>Parsing • 最简单的 Parser 写法——含回朔的递归自顶而下分析</title>
		<published>2020-05-17T16:30:31.045+00:00</published>
		<updated>2020-05-17T16:30:31.045+00:00</updated>
		<link href="https://longfangsong.github.io/parsing-combinator/" type="text/html"/>
		<id>https://longfangsong.github.io/parsing-combinator/</id>
		<content type="html">&lt;p&gt;如果你听了老师上课讲的那一大坨根本没人听得懂的parse方法之后认为自己这辈子都造不出编译器了，那么本文介绍含回朔的递归自顶而下分析法正是你所需要的，这种方式非常容易想到，也非常容易编写，除了文法分析之外，对于词法分析，这个方法也可以一手包办，而且足以应付绝大多数编程语言的构造。&lt;&#x2F;p&gt;
&lt;p&gt;我们先结合一个例子来看一下这玩意怎么使的：&lt;&#x2F;p&gt;
&lt;h2 id=&quot;zhu-yao-si-xiang&quot;&gt;主要思想&lt;&#x2F;h2&gt;
&lt;p&gt;含回朔的递归自顶而下分析法的主要思想是：将每个非终结符（推导式左边）的分析写成一个函数，将右侧的内容组合写在函数体里面，如果这个函数从左向右匹配某段代码字符串成功，就返回存放了对应信息的结构体和剩下的字符串，否则返回Error。&lt;&#x2F;p&gt;
&lt;h2 id=&quot;shi-jian&quot;&gt;实践&lt;&#x2F;h2&gt;
&lt;p&gt;我们要分析的文法是：
$$
\displaylines {
Expression \rightarrow Ident | Constant | InBrackets \mid Expression * Expression | Expression + Expression \\
InBrackets \rightarrow &#x27;(&#x27; Expression&#x27;)&#x27; \\
Ident \rightarrow [a-zA-Z][a-zA-Z0-9]* \\
Constant \rightarrow [0-9]*
}
$$&lt;&#x2F;p&gt;
&lt;p&gt;上面的例子可以写成四个函数&lt;sup class=&quot;footnote-reference&quot;&gt;&lt;a href=&quot;#1&quot;&gt;1&lt;&#x2F;a&gt;&lt;&#x2F;sup&gt;：&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;expression&lt;&#x2F;span&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;code&lt;&#x2F;span&gt;&lt;span&gt;: string) -&amp;gt; (Expresion, string) | Error;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;in_brackets&lt;&#x2F;span&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;code&lt;&#x2F;span&gt;&lt;span&gt;: string) -&amp;gt; (InBrackets, string) | Error;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;ident&lt;&#x2F;span&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;code&lt;&#x2F;span&gt;&lt;span&gt;: string) -&amp;gt; (Ident, string) | Error;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;constant&lt;&#x2F;span&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;code&lt;&#x2F;span&gt;&lt;span&gt;: string) -&amp;gt; (Constant, string) | Error;
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;那么函数体怎么写呢？&lt;&#x2F;p&gt;
&lt;h3 id=&quot;alt-many0he-tag&quot;&gt;&lt;code&gt;alt&lt;&#x2F;code&gt;、&lt;code&gt;many0&lt;&#x2F;code&gt;和&lt;code&gt;tag&lt;&#x2F;code&gt;&lt;&#x2F;h3&gt;
&lt;p&gt;我们首先针对&lt;code&gt;|&lt;&#x2F;code&gt;和&lt;code&gt;*&lt;&#x2F;code&gt;，定义两个函数：&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;&#x2F;&#x2F; 接受一组parser函数和字符串作为参数，返回其中最早成功匹配的parser的匹配结果，相当于|
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;alt&lt;&#x2F;span&gt;&lt;span&gt;&amp;lt;R&amp;gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;parsers&lt;&#x2F;span&gt;&lt;span&gt;: Vec&amp;lt;Fn(string) -&amp;gt; (R, string) &lt;&#x2F;span&gt;&lt;span style=&quot;background-color:#bf616a;color:#2b303b;&quot;&gt;|&lt;&#x2F;span&gt;&lt;span&gt; Error&amp;gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;input&lt;&#x2F;span&gt;&lt;span&gt;: string) -&amp;gt; (R, string) | Error {
&lt;&#x2F;span&gt;&lt;span&gt;	&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;for&lt;&#x2F;span&gt;&lt;span&gt; parser in parsers {
&lt;&#x2F;span&gt;&lt;span&gt;		&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;if &lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;parser&lt;&#x2F;span&gt;&lt;span&gt;(input) != Error {
&lt;&#x2F;span&gt;&lt;span&gt;			&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;return &lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;parser&lt;&#x2F;span&gt;&lt;span&gt;(input)
&lt;&#x2F;span&gt;&lt;span&gt;		}
&lt;&#x2F;span&gt;&lt;span&gt;	}
&lt;&#x2F;span&gt;&lt;span&gt;	&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;return&lt;&#x2F;span&gt;&lt;span&gt; Error
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;&#x2F;&#x2F; 接受一个parser函数，返回其重复匹配0次以上的结果，相当于*
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;many0&lt;&#x2F;span&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;parser&lt;&#x2F;span&gt;&lt;span&gt;: Fn(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;string&lt;&#x2F;span&gt;&lt;span&gt;) -&amp;gt; (&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;R&lt;&#x2F;span&gt;&lt;span&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;string&lt;&#x2F;span&gt;&lt;span&gt;) | Error, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;input&lt;&#x2F;span&gt;&lt;span&gt;: string) -&amp;gt; (Vec&amp;lt;R&amp;gt;, string) | Error {
&lt;&#x2F;span&gt;&lt;span&gt;	result = new Vec();
&lt;&#x2F;span&gt;&lt;span&gt;	&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;while &lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;parser&lt;&#x2F;span&gt;&lt;span&gt;(input) != error {
&lt;&#x2F;span&gt;&lt;span&gt;		r, input = &lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;parser&lt;&#x2F;span&gt;&lt;span&gt;(input)
&lt;&#x2F;span&gt;&lt;span&gt;		result.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;push&lt;&#x2F;span&gt;&lt;span&gt;(r)
&lt;&#x2F;span&gt;&lt;span&gt;	}
&lt;&#x2F;span&gt;&lt;span&gt;	&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;return &lt;&#x2F;span&gt;&lt;span&gt;(result, input)
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;在实现一个&lt;code&gt;tag&lt;&#x2F;code&gt;函数来识别某些指定的字面量&lt;sup class=&quot;footnote-reference&quot;&gt;&lt;a href=&quot;#2&quot;&gt;2&lt;&#x2F;a&gt;&lt;&#x2F;sup&gt;：&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;tag&lt;&#x2F;span&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;tagname&lt;&#x2F;span&gt;&lt;span&gt;: string, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;code&lt;&#x2F;span&gt;&lt;span&gt;: string) -&amp;gt; (string, string) | Error {
&lt;&#x2F;span&gt;&lt;span&gt;	&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;if&lt;&#x2F;span&gt;&lt;span&gt; code.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;starts_with&lt;&#x2F;span&gt;&lt;span&gt;(tagname) {
&lt;&#x2F;span&gt;&lt;span&gt;		&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;return&lt;&#x2F;span&gt;&lt;span&gt; tagname, code[&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;len&lt;&#x2F;span&gt;&lt;span&gt;(tagname):]
&lt;&#x2F;span&gt;&lt;span&gt;	} &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;else &lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;		&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;return&lt;&#x2F;span&gt;&lt;span&gt; Error
&lt;&#x2F;span&gt;&lt;span&gt;	}
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;然后就可以实现上面的几个函数了：&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;mul&lt;&#x2F;span&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;code&lt;&#x2F;span&gt;&lt;span&gt;: string) -&amp;gt; (Expression, string) | Error {
&lt;&#x2F;span&gt;&lt;span&gt;	&lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;&#x2F;&#x2F; 识别左操作数, ? 代表如果它前面的函数返回Error，则当前函数也返回Error
&lt;&#x2F;span&gt;&lt;span&gt;	lhs, rest = &lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;expression&lt;&#x2F;span&gt;&lt;span&gt;(code)?
&lt;&#x2F;span&gt;&lt;span&gt;	&lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;&#x2F;&#x2F; 识别*号
&lt;&#x2F;span&gt;&lt;span&gt;	op, rest = &lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;tag&lt;&#x2F;span&gt;&lt;span&gt;(&amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;*&lt;&#x2F;span&gt;&lt;span&gt;&amp;quot;, rest)?
&lt;&#x2F;span&gt;&lt;span&gt;	&lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;&#x2F;&#x2F; 识别右操作数
&lt;&#x2F;span&gt;&lt;span&gt;	rhs, rest = &lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;expression&lt;&#x2F;span&gt;&lt;span&gt;(rest)?
&lt;&#x2F;span&gt;&lt;span&gt;	&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;return&lt;&#x2F;span&gt;&lt;span&gt; Expression {lhs, &amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;*&lt;&#x2F;span&gt;&lt;span&gt;&amp;quot;, rhs}
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;&#x2F;&#x2F; add 函数同理，*变为+
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;expression&lt;&#x2F;span&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;code&lt;&#x2F;span&gt;&lt;span&gt;: string) -&amp;gt; (Expresion, string) | Error {
&lt;&#x2F;span&gt;&lt;span&gt;	&lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;&#x2F;&#x2F; 注意这里的顺序，优先级越低操作符对应的函数越要在前面
&lt;&#x2F;span&gt;&lt;span&gt;	&lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;&#x2F;&#x2F; 不理解的话考虑一下1+2*3会怎么被parse就知道了
&lt;&#x2F;span&gt;&lt;span&gt;	&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;return &lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;alt&lt;&#x2F;span&gt;&lt;span&gt;([
&lt;&#x2F;span&gt;&lt;span&gt;		add,
&lt;&#x2F;span&gt;&lt;span&gt;		mul,
&lt;&#x2F;span&gt;&lt;span&gt;		ident,
&lt;&#x2F;span&gt;&lt;span&gt;		constant,
&lt;&#x2F;span&gt;&lt;span&gt;		in_brackets,
&lt;&#x2F;span&gt;&lt;span&gt;	], code)
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;in_brackets&lt;&#x2F;span&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;code&lt;&#x2F;span&gt;&lt;span&gt;: string) -&amp;gt; (InBrackets, string) | Error {
&lt;&#x2F;span&gt;&lt;span&gt;	bracket, rest = &lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;tag&lt;&#x2F;span&gt;&lt;span&gt;(&amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;(&lt;&#x2F;span&gt;&lt;span&gt;&amp;quot;,code)?
&lt;&#x2F;span&gt;&lt;span&gt;	expr, rest = &lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;expression&lt;&#x2F;span&gt;&lt;span&gt;(rest)?
&lt;&#x2F;span&gt;&lt;span&gt;	bracket, rest = &lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;tag&lt;&#x2F;span&gt;&lt;span&gt;(&amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;)&lt;&#x2F;span&gt;&lt;span&gt;&amp;quot;,code)?
&lt;&#x2F;span&gt;&lt;span&gt;	&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;return&lt;&#x2F;span&gt;&lt;span&gt; InBrackets(expr), rest
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;ident&lt;&#x2F;span&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;code&lt;&#x2F;span&gt;&lt;span&gt;: string) -&amp;gt; (Ident, string) | Error {
&lt;&#x2F;span&gt;&lt;span&gt;	&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;return &lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;alt&lt;&#x2F;span&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;tag&lt;&#x2F;span&gt;&lt;span&gt;(&amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;a&lt;&#x2F;span&gt;&lt;span&gt;&amp;quot;, code), &lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;tag&lt;&#x2F;span&gt;&lt;span&gt;(&amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;b&lt;&#x2F;span&gt;&lt;span&gt;&amp;quot;, code),........) 
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;digit&lt;&#x2F;span&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;code&lt;&#x2F;span&gt;&lt;span&gt;: string) -&amp;gt; (string, string) | Error {
&lt;&#x2F;span&gt;&lt;span&gt;	&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;return &lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;alt&lt;&#x2F;span&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;tag&lt;&#x2F;span&gt;&lt;span&gt;(&amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;0&lt;&#x2F;span&gt;&lt;span&gt;&amp;quot;, code), &lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;tag&lt;&#x2F;span&gt;&lt;span&gt;(&amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;1&lt;&#x2F;span&gt;&lt;span&gt;&amp;quot;, code),........) 
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;constant&lt;&#x2F;span&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;code&lt;&#x2F;span&gt;&lt;span&gt;: string) -&amp;gt; (Constant, string) | Error {
&lt;&#x2F;span&gt;&lt;span&gt;	&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;return &lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;many0&lt;&#x2F;span&gt;&lt;span&gt;(digit, code)
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;h3 id=&quot;zuo-di-gui&quot;&gt;左递归&lt;&#x2F;h3&gt;
&lt;p&gt;实际写出来之后会发现这里有一个问题：&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;expression&lt;&#x2F;span&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;code&lt;&#x2F;span&gt;&lt;span&gt;: string) -&amp;gt; (Expresion, string) | Error {
&lt;&#x2F;span&gt;&lt;span&gt;	&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;return &lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;alt&lt;&#x2F;span&gt;&lt;span&gt;([
&lt;&#x2F;span&gt;&lt;span&gt;		add,
&lt;&#x2F;span&gt;&lt;span&gt;		mul,
&lt;&#x2F;span&gt;&lt;span&gt;		ident,
&lt;&#x2F;span&gt;&lt;span&gt;		constant,
&lt;&#x2F;span&gt;&lt;span&gt;		in_brackets,
&lt;&#x2F;span&gt;&lt;span&gt;	], code)
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;其中的&lt;code&gt;mul&lt;&#x2F;code&gt;，间接调用了&lt;code&gt;expression(code)&lt;&#x2F;code&gt;，而这时又会反过去调用&lt;code&gt;mul(code)&lt;&#x2F;code&gt;，且其中的&lt;code&gt;code&lt;&#x2F;code&gt;参数一直没有变化，&lt;code&gt;add&lt;&#x2F;code&gt;也有这个问题，这样在程序中就会造成无限递归。&lt;&#x2F;p&gt;
&lt;p&gt;这也是为什么课上说在做自顶而下文法分析的时候要先消除左递归的原因。&lt;&#x2F;p&gt;
&lt;p&gt;怎么消除也很简单，我们要让&lt;code&gt;mul&lt;&#x2F;code&gt;和&lt;code&gt;add&lt;&#x2F;code&gt;至少从&lt;code&gt;code&lt;&#x2F;code&gt;中“消耗”一个优先级比其自身高的expression，即：&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#2b303b;color:#c0c5ce;&quot;&gt;&lt;code&gt;&lt;span&gt;fn higher_than_mul(code: string) -&amp;gt; (Expression, string) | Error {
&lt;&#x2F;span&gt;&lt;span&gt;	return alt([
&lt;&#x2F;span&gt;&lt;span&gt;		ident,
&lt;&#x2F;span&gt;&lt;span&gt;		constant,
&lt;&#x2F;span&gt;&lt;span&gt;		in_brackets
&lt;&#x2F;span&gt;&lt;span&gt;	], code)
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;fn mul(code: string) -&amp;gt; (Expression, string) | Error {
&lt;&#x2F;span&gt;&lt;span&gt;	&#x2F;&#x2F; 识别左操作数, 消耗掉一个优先级高于*结果的语法元素
&lt;&#x2F;span&gt;&lt;span&gt;	lhs, rest = higher_than_mul(code)?
&lt;&#x2F;span&gt;&lt;span&gt;	&#x2F;&#x2F; 识别*号
&lt;&#x2F;span&gt;&lt;span&gt;	op, rest = tag(&amp;quot;*&amp;quot;, rest)?
&lt;&#x2F;span&gt;&lt;span&gt;	&#x2F;&#x2F; 识别右操作数
&lt;&#x2F;span&gt;&lt;span&gt;	rhs, rest = expression(rest)?
&lt;&#x2F;span&gt;&lt;span&gt;	return Expression {lhs, &amp;quot;*&amp;quot;, rhs}
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;&#x2F;&#x2F; add 同理，你应该自己能想到的
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;实际上就相当于将Expression部分的文法改成了：
$$
\displaylines {
Expression \rightarrow Add | Mul | Ident | Constant | InBrackets \\
Add \rightarrow HigherThanAdd + Expression \\
Mul \rightarrow HigherThanMul * Expression \\
HigherThanMul \rightarrow Ident | Constant|InBrackets \\
HigherThanAdd \rightarrow Mul | HighterThanMul
}
$$
和书上讲的消除左递归的方案是不是很像？&lt;&#x2F;p&gt;
&lt;p&gt;这样一个简单表达式的parser就完成了。&lt;&#x2F;p&gt;
&lt;h2 id=&quot;you-shi-yu-bu-zu&quot;&gt;优势与不足&lt;&#x2F;h2&gt;
&lt;h3 id=&quot;you-shi&quot;&gt;优势&lt;&#x2F;h3&gt;
&lt;p&gt;这种parser的优势有：&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;容易理解与实现&lt;&#x2F;li&gt;
&lt;li&gt;写出的代码是完全可读可调试的&lt;&#x2F;li&gt;
&lt;li&gt;这种分析器可以分析 $LL(k)$ 文法，在实践中，这一分析器可以应用于几乎所有可能会碰到的文法，当然，除了C++之外，C++不是$CFG$……。&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;h3 id=&quot;bu-zu&quot;&gt;不足&lt;&#x2F;h3&gt;
&lt;p&gt;这种parser的不足有：&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;效率问题，回朔可能会带来一定的性能问题，因此可能不适用于一些极其要求性能的场合&lt;sup class=&quot;footnote-reference&quot;&gt;&lt;a href=&quot;#3&quot;&gt;3&lt;&#x2F;a&gt;&lt;&#x2F;sup&gt;&lt;&#x2F;li&gt;
&lt;li&gt;一般来说生成的所有运算符都是右结合的，上面的例子由于加法和乘法都有交换律所以也没关系，但是减法和除法就会出现问题，需要在 AST 上做 hack 解决，hack 的一个方案如下：
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;将文法的相应部分改写成：
$$
\displaylines {
Add \rightarrow HigherThanAdd\ (+ HigherThanAdd)* \\
Mul \rightarrow HigherThanMul\ (* HigherThanMul)* \\
}
$$&lt;&#x2F;p&gt;
&lt;p&gt;然后将 parse 得到的东西用如下方法转换（折叠）为 AST：&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;to_ast&lt;&#x2F;span&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;first&lt;&#x2F;span&gt;&lt;span&gt;: RValue, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;rest&lt;&#x2F;span&gt;&lt;span&gt;: Vec&amp;lt;(String, RValue)&amp;gt;) -&amp;gt; BinOp {
&lt;&#x2F;span&gt;&lt;span&gt;  &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;let mut&lt;&#x2F;span&gt;&lt;span&gt; current_lhs = first;
&lt;&#x2F;span&gt;&lt;span&gt;  &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;for &lt;&#x2F;span&gt;&lt;span&gt;(op, value) in rest.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;into_iter&lt;&#x2F;span&gt;&lt;span&gt;() {
&lt;&#x2F;span&gt;&lt;span&gt;      current_lhs = BinOp {
&lt;&#x2F;span&gt;&lt;span&gt;          operator: op,
&lt;&#x2F;span&gt;&lt;span&gt;          lhs: Box::new(current_lhs),
&lt;&#x2F;span&gt;&lt;span&gt;          rhs: Box::new(value),
&lt;&#x2F;span&gt;&lt;span&gt;      }
&lt;&#x2F;span&gt;&lt;span&gt;      .&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;into&lt;&#x2F;span&gt;&lt;span&gt;()
&lt;&#x2F;span&gt;&lt;span&gt;  }
&lt;&#x2F;span&gt;&lt;span&gt;  current_lhs.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;try_into&lt;&#x2F;span&gt;&lt;span&gt;().&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;unwrap&lt;&#x2F;span&gt;&lt;span&gt;()
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;div class=&quot;footnote-definition&quot; id=&quot;1&quot;&gt;&lt;sup class=&quot;footnote-definition-label&quot;&gt;1&lt;&#x2F;sup&gt;
&lt;p&gt;本文中的代码均为伪代码，返回类型也不太严谨（如果你一定要深究的话，那么可以把它们看作是协变的），实际实现可以参考&lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;Geal&#x2F;nom&quot;&gt;Geal&#x2F;nom&lt;&#x2F;a&gt;及&lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;longfangsong&#x2F;tiny-nom&quot;&gt;我对其的简化实现&lt;&#x2F;a&gt;。&lt;&#x2F;p&gt;
&lt;&#x2F;div&gt;
&lt;div class=&quot;footnote-definition&quot; id=&quot;2&quot;&gt;&lt;sup class=&quot;footnote-definition-label&quot;&gt;2&lt;&#x2F;sup&gt;
&lt;p&gt;你可以认为tag是用来识别“终结符”的&lt;&#x2F;p&gt;
&lt;&#x2F;div&gt;
&lt;div class=&quot;footnote-definition&quot; id=&quot;3&quot;&gt;&lt;sup class=&quot;footnote-definition-label&quot;&gt;3&lt;&#x2F;sup&gt;
&lt;p&gt;一般的编译器中，文法分析器的性能其实是无需首先考虑的（后端每个步骤的耗时常常是整个前端的耗时的十倍甚至百倍之多），但在部分场合比如数据库中SQL的解释中，较慢的文法分析器可能会带来性能瓶颈。&lt;&#x2F;p&gt;
&lt;&#x2F;div&gt;
</content>
	</entry>
	<entry xml:lang="zh">
		<title>分布式系统 • 两阶段提交</title>
		<published>2020-04-23T16:09:46.815+00:00</published>
		<updated>2020-04-23T16:09:46.815+00:00</updated>
		<link href="https://longfangsong.github.io/2pc/" type="text/html"/>
		<id>https://longfangsong.github.io/2pc/</id>
		<content type="html">&lt;blockquote&gt;
&lt;p&gt;经典的分布式数据库模型中，同一个数据库的各个副本运行在不同的节点上，每个副本的数 据要求完全一致。数据库中的操作都是事务 (transaction)，一个事务是一系列读、写操作，事务满足 ACID。每个事务的最终状态要么是提交 (commit)，要么是失败 (abort)。一旦一个事务成功提交，那么这个事务中所有的写操作中成功，否则所有的写操作都失败。&lt;&#x2F;p&gt;
&lt;&#x2F;blockquote&gt;
&lt;p&gt;为了适应这种 ACID 模型，2PC 提供的解决方案是：首先由一个节点（提议者）询问每个其他节点（参与者）是否同意提交某个事务，如果全部同意，则实际提交这个事务，否则拒绝提交这个事务。&lt;&#x2F;p&gt;
&lt;h2 id=&quot;gong-zuo-liu-cheng&quot;&gt;工作流程&lt;&#x2F;h2&gt;
&lt;h3 id=&quot;cheng-gong-ti-jiao&quot;&gt;成功提交&lt;&#x2F;h3&gt;
&lt;p&gt;在任何一个新的事务到来时，master会先将事务开始的相关信息写入日志。&lt;&#x2F;p&gt;
&lt;p&gt;注意要 commit 的内容在第一次询问时会被 cache 在各个 node 上，如果决定了 commit，直接做这个 cache 里的内容就好了，这部分 cache 也被用于决定后续的事务是否可以被提交。&lt;&#x2F;p&gt;
&lt;p&gt;&lt;img src=&quot;2pc-step1.svg&quot; alt=&quot;2pc-step1&quot; &#x2F;&gt;&lt;&#x2F;p&gt;
&lt;hr &#x2F;&gt;
&lt;p&gt;&lt;img src=&quot;2pc-step2-all-agree.svg&quot; alt=&quot;2pc-step2-all-agree&quot; &#x2F;&gt;&lt;&#x2F;p&gt;
&lt;hr &#x2F;&gt;
&lt;p&gt;&lt;img src=&quot;2pc-step3-do-commit.svg&quot; alt=&quot;2pc-step3-do-commit&quot; &#x2F;&gt;&lt;&#x2F;p&gt;
&lt;hr &#x2F;&gt;
&lt;p&gt;注意最后的 commit 请求完成后node还需要通知一声master，让master记录此次事务完成。&lt;&#x2F;p&gt;
&lt;h3 id=&quot;shi-bai&quot;&gt;失败&lt;&#x2F;h3&gt;
&lt;p&gt;失败提交的可能场景是某些节点上其他事务（可能是上一步留下来还没有完成提交的事务）和待提交的事务有冲突。&lt;&#x2F;p&gt;
&lt;p&gt;&lt;img src=&quot;2pc-step1-8094287.svg&quot; alt=&quot;2pc-step1&quot; &#x2F;&gt;&lt;&#x2F;p&gt;
&lt;hr &#x2F;&gt;
&lt;p&gt;&lt;img src=&quot;2pc-step2-has-disagree.svg&quot; alt=&quot;2pc-step2-has-disagree&quot; &#x2F;&gt;&lt;&#x2F;p&gt;
&lt;hr &#x2F;&gt;
&lt;p&gt;&lt;img src=&quot;2pc-step3-do-reject.svg&quot; alt=&quot;2pc-step3-do-reject&quot; &#x2F;&gt;&lt;&#x2F;p&gt;
&lt;h2 id=&quot;yi-chang-qing-kuang-chu-li&quot;&gt;异常情况处理&lt;&#x2F;h2&gt;
&lt;h3 id=&quot;dang-ji&quot;&gt;宕机&lt;&#x2F;h3&gt;
&lt;p&gt;宕机恢复后可以通过日志确定自己处于何种状态。&lt;&#x2F;p&gt;
&lt;h4 id=&quot;master&quot;&gt;Master&lt;&#x2F;h4&gt;
&lt;p&gt;Master宕机后恢复，如果发现自己处于：&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;事务开始了，但还没有作出决定是否commit最后一个事务的状态&lt;&#x2F;p&gt;
&lt;p&gt;那么重新询问全部节点是否可以commit，然后继续一般流程即可。&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;已经决定是否commit最后一个事务，但还没有实际commit&#x2F;reject的状态&lt;&#x2F;p&gt;
&lt;p&gt;简单地从通知所有节点实际进行commit&#x2F;reject这步开始继续一般流程即可。&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;h4 id=&quot;node&quot;&gt;Node&lt;&#x2F;h4&gt;
&lt;p&gt;Node宕机后恢复，如果发现自己处于：&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;已经接到对某个事务的投票请求，但还未投票&lt;&#x2F;p&gt;
&lt;p&gt;检查并投票，然后继续流程。&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;已经投票，但还没有实际提交&lt;&#x2F;p&gt;
&lt;p&gt;等待Master发送&#x2F;重发commit&#x2F;reject消息即可&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;h3 id=&quot;chao-shi&quot;&gt;超时&lt;&#x2F;h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Node为某次事务是否commit的投票超时&lt;&#x2F;p&gt;
&lt;p&gt;Master直接认为它选择了reject这个事务。&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;Node某次事务实际提交&#x2F;拒绝后的确认超时&lt;&#x2F;p&gt;
&lt;p&gt;不断重试要求其提交，直到Node再次上线并返回确认。&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;Node迟迟没有收到Master对某次事务的最终决定&lt;&#x2F;p&gt;
&lt;p&gt;不断重发自己的投票结果，直到收到决定。&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;这种不断重试的机制决定了2PC如果不加修改的话，A和P都是很糟糕的，不过相应地也换来了完全的C。&lt;&#x2F;p&gt;
</content>
	</entry>
	<entry xml:lang="zh">
		<title>分布式系统 • CAP 定理</title>
		<published>2020-04-23T16:09:46.815+00:00</published>
		<updated>2020-04-23T16:09:46.815+00:00</updated>
		<link href="https://longfangsong.github.io/cap-theorem/" type="text/html"/>
		<id>https://longfangsong.github.io/cap-theorem/</id>
		<content type="html">&lt;p&gt;CAP 定理是说，对于一个分布式系统来说，不可能同时满足以下三点：&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;（强外部）一致性（&lt;strong&gt;C&lt;&#x2F;strong&gt;onsistency）&lt;&#x2F;li&gt;
&lt;li&gt;可用性（&lt;strong&gt;A&lt;&#x2F;strong&gt;vailability）（即每次请求没有物理上不可用的节点时都能获取到非错的响应）&lt;&#x2F;li&gt;
&lt;li&gt;分区容错性（&lt;strong&gt;P&lt;&#x2F;strong&gt;artition tolerance）（即如果分布式系统由于某些原因，存在互相不能通信的两&#x2F;几组节点，那么这个系统仍然应该正常的提供服务）&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;h2 id=&quot;li-zi-zhi-guan-de-bu-yan-ge-zheng-ming&quot;&gt;例子（直观的不严格证明）&lt;&#x2F;h2&gt;
&lt;p&gt;假设有两个节点和一个Client：&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;如果要保证可用性（A）和分区容错性（P），那么在网络出现分区时，无论用户的请求被发送到了两个节点中的任何一个，无论如何都要做出相应，而在一个节点上的插入请求无法被另一个节点知道，这样两个节点间不可能保持一致性，即放弃了C。&lt;&#x2F;p&gt;
&lt;p&gt;&lt;img src=&quot;AP.png&quot; alt=&quot;AP&quot; &#x2F;&gt;&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;如果要保证一致性（C）和分区容错性（P），那么为了修正上一个系统的问题，对在插入某个数据时没有得到插入的节点，或者其上对应数据不是最新的节点，在被请求这个数据时只能返回错误，这就放弃了A。&lt;&#x2F;p&gt;
&lt;p&gt;&lt;img src=&quot;CP.png&quot; alt=&quot;CP&quot; &#x2F;&gt;&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;如果要保证一致性（C）和可用性（A），那么不得不允许两个节点之间可以通信，在每次插入时将数据分发到每一个节点上，但此时如果节点之间网络不可达，那么这个分发操作就不可行。&lt;&#x2F;p&gt;
&lt;p&gt;&lt;img src=&quot;CA.png&quot; alt=&quot;CA&quot; &#x2F;&gt;&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;h2 id=&quot;chang-jian-wu-qu&quot;&gt;常见误区&lt;&#x2F;h2&gt;
&lt;p&gt;要注意的是，实践中并不是说去选择 CAP 中的两个，放弃另外一个。CAP 里的每个标准都不是绝对的“有”或者“没有”的关系，而是一个程度的问题，例如一致性可以降低到任何一个一致性等级，可用性可以做到 n 个 9，而分区容错性可以降低到有“部分”节点和其他部分不能通信时整个系统可用的程度。&lt;&#x2F;p&gt;
</content>
	</entry>
	<entry xml:lang="zh">
		<title>分布式系统 • 基本概念</title>
		<published>2020-04-22T16:09:46.815+00:00</published>
		<updated>2020-04-22T16:09:46.815+00:00</updated>
		<link href="https://longfangsong.github.io/distributed-system/" type="text/html"/>
		<id>https://longfangsong.github.io/distributed-system/</id>
		<content type="html">&lt;p&gt;先拜一拜伟大的 &lt;strong&gt;Leslie Lamport&lt;&#x2F;strong&gt; 祖师爷。&lt;&#x2F;p&gt;
&lt;p&gt;&lt;img src=&quot;https:&#x2F;&#x2F;upload.wikimedia.org&#x2F;wikipedia&#x2F;commons&#x2F;thumb&#x2F;5&#x2F;50&#x2F;Leslie_Lamport.jpg&#x2F;150px-Leslie_Lamport.jpg&quot; alt=&quot;Leslie Lamport&quot; &#x2F;&gt;&lt;&#x2F;p&gt;
&lt;h2 id=&quot;shi-yao-shi-fen-bu-shi-xi-tong&quot;&gt;什么是分布式系统&lt;&#x2F;h2&gt;
&lt;blockquote&gt;
&lt;p&gt;分布式系统是一组电脑，透过网络相互连接传递消息与通信后并协调它们的行为而形成的系统。 —— wikipedia&lt;&#x2F;p&gt;
&lt;&#x2F;blockquote&gt;
&lt;p&gt;当然我觉得这个定义有点狭窄了，我扩展范围后的定义是：&lt;&#x2F;p&gt;
&lt;blockquote&gt;
&lt;p&gt;分布式系统是一组抽象的计算和存储单元，通过某种方式相互连接传递消息并协调它们的行为而形成的系统。&lt;&#x2F;p&gt;
&lt;&#x2F;blockquote&gt;
&lt;p&gt;讲道理，单机上的一组进程其实也一定程度上具有分布式系统的功能，也存在分布式系统中的问题，只不过部分问题的发生率降低了而已，因此我觉得将分布式系统窄化到多个物理计算机之间是不甚合理的。&lt;sup class=&quot;footnote-reference&quot;&gt;&lt;a href=&quot;#1&quot;&gt;1&lt;&#x2F;a&gt;&lt;&#x2F;sup&gt;&lt;&#x2F;p&gt;
&lt;h2 id=&quot;fen-bu-shi-xi-tong-de-zuo-yong&quot;&gt;分布式系统的作用&lt;&#x2F;h2&gt;
&lt;p&gt;主要是：&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;满足扩展性（Scalability）需求：一台机器吃不消了，多上几台机器就能顶住&lt;&#x2F;li&gt;
&lt;li&gt;满足高可用性（Availability）需求：某几个机器down了，整个服务不能down&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;h2 id=&quot;fen-bu-shi-xi-tong-de-nan-dian&quot;&gt;分布式系统的难点&lt;&#x2F;h2&gt;
&lt;p&gt;分布式系统涉及到多个计算与存储单元（称为节点），故：&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;相比单个节点，更容易出现某些节点故障&lt;&#x2F;li&gt;
&lt;li&gt;节点之间的通信可能出现问题，消息可能会丢失、重复、乱序&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;相对来说，分布式“计算”的门槛是相对较低的，如果某个节点烂了直接换个节点算就行了，而存储问题就比较大了。&lt;&#x2F;p&gt;
&lt;h2 id=&quot;chang-yong-gai-nian&quot;&gt;常用概念&lt;&#x2F;h2&gt;
&lt;h3 id=&quot;nei-bu-yi-zhi-xing&quot;&gt;内部一致性&lt;&#x2F;h3&gt;
&lt;p&gt;内部一致性（Consistency in ACID）指数据库内部的数据完整性（由各类约束、触发器，再加上数据库的隔离性保证）。&lt;&#x2F;p&gt;
&lt;p&gt;当我们在说：&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;zh.wikipedia.org&#x2F;wiki&#x2F;%E5%8F%AF%E4%B8%B2%E8%A1%8C%E6%80%A7&quot;&gt;可串行化&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;zh.wikipedia.org&#x2F;wiki&#x2F;%E5%BF%AB%E7%85%A7%E9%9A%94%E7%A6%BB&quot;&gt;快照隔离&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;zh.wikipedia.org&#x2F;wiki&#x2F;%E4%BA%8B%E5%8B%99%E9%9A%94%E9%9B%A2#%E5%8F%AF%E9%87%8D%E5%A4%8D%E8%AF%BB&quot;&gt;可重复读&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;zh.wikipedia.org&#x2F;wiki&#x2F;%E4%BA%8B%E5%8B%99%E9%9A%94%E9%9B%A2#%E6%8F%90%E4%BA%A4%E8%AF%BB&quot;&gt;读已提交&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;zh.wikipedia.org&#x2F;wiki&#x2F;%E4%BA%8B%E5%8B%99%E9%9A%94%E9%9B%A2#%E6%9C%AA%E6%8F%90%E4%BA%A4%E8%AF%BB&quot;&gt;读未提交&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;li&gt;脏写&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;zh.wikipedia.org&#x2F;wiki&#x2F;%E4%BA%8B%E5%8B%99%E9%9A%94%E9%9B%A2#%E8%84%8F%E8%AF%BB&quot;&gt;脏读&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;zh.wikipedia.org&#x2F;wiki&#x2F;%E4%BA%8B%E5%8B%99%E9%9A%94%E9%9B%A2#%E4%B8%8D%E5%8F%AF%E9%87%8D%E5%A4%8D%E8%AF%BB&quot;&gt;不可重复读&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;zh.wikipedia.org&#x2F;wiki&#x2F;%E4%BA%8B%E5%8B%99%E9%9A%94%E9%9B%A2#%E5%B9%BB%E5%BD%B1%E8%AF%BB&quot;&gt;幻读&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;li&gt;Read Skew&lt;&#x2F;li&gt;
&lt;li&gt;Write Skew&lt;&#x2F;li&gt;
&lt;li&gt;Lost Update&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;我们说的就和内部一致性有关。&lt;&#x2F;p&gt;
&lt;h3 id=&quot;wai-bu-yi-zhi-xing&quot;&gt;外部一致性&lt;&#x2F;h3&gt;
&lt;p&gt;指 Read 和 Write 应该遵守怎样的时间线顺序，比如 Linearizability 外部一致性级别就保证了每一个读操作都将返回“（某个标准时钟规定的）最近的写操作”。
CAP 中的 C 指的是外部一致性。
当我们在说：&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;zh.wikipedia.org&#x2F;wiki&#x2F;%E7%BA%BF%E6%80%A7%E4%B8%80%E8%87%B4%E6%80%A7&quot;&gt;线性一致性&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Sequential_consistency&quot;&gt;顺序一致性&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Causal_consistency&quot;&gt;因果一致性&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;zh.wikipedia.org&#x2F;wiki&#x2F;%E6%9C%80%E7%BB%88%E4%B8%80%E8%87%B4%E6%80%A7&quot;&gt;最终一致性&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;zh.wikipedia.org&#x2F;wiki&#x2F;Raft&quot;&gt;Raft 共识算法&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;zh.wikipedia.org&#x2F;wiki&#x2F;Paxos%E7%AE%97%E6%B3%95&quot;&gt;Paxos 共识算法&lt;&#x2F;a&gt;&lt;sup class=&quot;footnote-reference&quot;&gt;&lt;a href=&quot;#2&quot;&gt;2&lt;&#x2F;a&gt;&lt;&#x2F;sup&gt;&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;我们所说的就和外部一致性相关。&lt;&#x2F;p&gt;
&lt;div class=&quot;footnote-definition&quot; id=&quot;1&quot;&gt;&lt;sup class=&quot;footnote-definition-label&quot;&gt;1&lt;&#x2F;sup&gt;
&lt;p&gt;我记得伟大的羊学长说过，集群是操作系统在网络上scale的结果。&lt;&#x2F;p&gt;
&lt;&#x2F;div&gt;
&lt;div class=&quot;footnote-definition&quot; id=&quot;2&quot;&gt;&lt;sup class=&quot;footnote-definition-label&quot;&gt;2&lt;&#x2F;sup&gt;
&lt;p&gt;有些人称 “XX 共识算法” 为 “XX 一致性算法”，个人觉得可以理解为“用来解决一致性问题的算法”，问题也不大。&lt;&#x2F;p&gt;
&lt;&#x2F;div&gt;
</content>
	</entry>
	<entry xml:lang="zh">
		<title>Hello zola!</title>
		<published>2020-01-02T15:00:00+00:00</published>
		<updated>2020-01-02T15:00:00+00:00</updated>
		<link href="https://longfangsong.github.io/hello-zola/" type="text/html"/>
		<id>https://longfangsong.github.io/hello-zola/</id>
		<content type="html">&lt;p&gt;I wrote a lot of blogs, and I used to use hexo as a static site generator, it kind of work well, but I&#x27;m afraid with more and more posts I have, the speed of hexo become unacceptable, moreover, the plugin system works well if I add only one plugin, but become odd if there&#x27;re many plugins work together:&lt;&#x2F;p&gt;
&lt;p&gt;Here&#x27;s an image from my origin blog, powered by hexo:&lt;&#x2F;p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;img src=&quot;ouch.png&quot; alt=&quot;ouch&quot; &#x2F;&gt;&lt;&#x2F;p&gt;
&lt;&#x2F;blockquote&gt;
&lt;p&gt;Ouch!&lt;&#x2F;p&gt;
&lt;p&gt;And then, since I&#x27;m a big fan of Rust, I found zola, though this tool is not as complete as hexo, I can use its shortcodes feature to embed different of things to my blog!&lt;&#x2F;p&gt;
&lt;p&gt;For example, terminal record:&lt;&#x2F;p&gt;
&lt;script id=&quot;asciicast-9EhVw8rujVjpPVBV5kQMdAIHe&quot; src=&quot;https:&#x2F;&#x2F;asciinema.org&#x2F;a&#x2F;9EhVw8rujVjpPVBV5kQMdAIHe.js&quot; async&gt;&lt;&#x2F;script&gt;
&lt;p&gt;Which I never imagined when using hexo!&lt;&#x2F;p&gt;
&lt;p&gt;And zola do make it easier to customize a theme, in hexo, if I want to customize a theme, I have to fork it, and do some edit on it. But in zola I can do this easily by override a template block.&lt;&#x2F;p&gt;
&lt;p&gt;But there remains some problems:&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;The &lt;code&gt;translations&lt;&#x2F;code&gt; in a theme cannot be used in the site based on that theme. Hope will fixed after &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;getzola&#x2F;zola&#x2F;pull&#x2F;1148&quot;&gt;#1148&lt;&#x2F;a&gt;.&lt;&#x2F;li&gt;
&lt;li&gt;Cannot paginate over another section.&lt;sup class=&quot;footnote-reference&quot;&gt;&lt;a href=&quot;#1&quot;&gt;1&lt;&#x2F;a&gt;&lt;&#x2F;sup&gt;&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;Anyway, I&#x27;ll absolutly move my blog to zola.&lt;&#x2F;p&gt;
&lt;p&gt;Also I&#x27;m looking forward to contribute something to this project, and I started with &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;getzola&#x2F;themes&#x2F;pull&#x2F;49&quot;&gt;migrating a theme&lt;&#x2F;a&gt;, which I&#x27;ll also used on my blog.&lt;&#x2F;p&gt;
&lt;p&gt;Hope zola will become a better project in the future!&lt;&#x2F;p&gt;
&lt;div class=&quot;footnote-definition&quot; id=&quot;1&quot;&gt;&lt;sup class=&quot;footnote-definition-label&quot;&gt;1&lt;&#x2F;sup&gt;
&lt;p&gt;Or maybe I misunderstood the &lt;code&gt;pagination&lt;&#x2F;code&gt; feature ...&lt;&#x2F;p&gt;
&lt;&#x2F;div&gt;
</content>
	</entry>
</feed>
