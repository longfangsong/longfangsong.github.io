<!DOCTYPE html>
<html lang="en"  class="theme--light" >

<head>
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1, viewport-fit=cover">
  <link rel="apple-touch-icon-precomposed" sizes="144x144" href="https://longfangsong.github.io/images/apple-touch-icon-144x144.png" />
  <link rel="apple-touch-icon-precomposed" sizes="120x120" href="https://longfangsong.github.io/images/apple-touch-icon-120x120.png" />
  <link rel="apple-touch-icon-precomposed" sizes="72x72" href="https://longfangsong.github.io/images/apple-touch-icon-72x72.png" />
  <link rel="apple-touch-icon-precomposed" sizes="57x57" href="https://longfangsong.github.io/images/apple-touch-icon-57x57.png" />
  <link rel="short icon" href="https://longfangsong.github.io/images/favicon.png" type="image/x-icon" />
  <link rel="stylesheet" href="https://longfangsong.github.io/style.css">
  <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.2.0/css/all.min.css" rel="stylesheet">
  <title>Blog • Automata Theory • Büchi Automata</title>
  
  
  <link rel="alternate" type="application/rss+xml" title="Blog" href="https://longfangsong.github.io/en/rss.xml">
  
  
  
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar" content="#ffffff" />
<meta name="theme-color" content="#ffffff" />
<link rel="stylesheet" href="https://longfangsong.github.io/blog.css">
<link rel="manifest" href="https://longfangsong.github.io/manifest.json">
<script src="//cdn.wordart.com/wordart.min.js" async defer></script>
<script async src="https://www.googletagmanager.com/gtag/js?id=G-YG5Z4J086Y" defer></script>
<meta name="google-site-verification" content="eIlbRaKM-jgH9zQg2VFwWY4H-027wQlW6K-TWdEvI1g" />
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag() { dataLayer.push(arguments); }
  gtag('js', new Date());

  gtag('config', 'G-YG5Z4J086Y');
</script>
<script type="module">
  import { Workbox } from 'https://storage.googleapis.com/workbox-cdn/releases/6.2.0/workbox-window.prod.mjs';

  if ('serviceWorker' in navigator && window.location.href.startsWith("https://longfangsong.github.io")) {
    const wb = new Workbox('/serviceWorker.js');
    console.log("load serviceWorker");
    wb.register();
  }
</script>

</head>

<body>
  <div id="sidebar" class="animated fadeInDown">
    <div class="logo-title">
      <div class="title">
        <img src=https://longfangsong.github.io/images/logo@2x.png style="width:127px;" alt="logo" />
        <h3><a href="https://longfangsong.github.io/en/">Blog</a></h3>
        <div class="description">
          <p>Und grün des Theorie goldner Baum</p>
        </div>
      </div>
    </div>
    <ul class="social-links"><li><a href="https://github.com/longfangsong" aria-label="Go to Github profile page"><i class="fab fa-github"></i></a></li><li><a href="https://twitter.com/longfangsong" aria-label="Go to Twitter profile page"><i class="fab fa-twitter"></i></a></li><li><a rel="me" href="https://mathstodon.xyz&#x2F;@longfangsong"
                      aria-label="Go to Mastodon profile page"><i class="fab fa-mastodon"></i></a>
      </li><li><a href="https://www.facebook.com/longfangsong" aria-label="Go to FaceBook profile page"><i class="fab fa-facebook"></i></a></li>
<div id="pirate" data-wordart-src="//cdn.wordart.com/json/bre8vfj02ejl" style="width: 100%;"
  data-wordart-show-attribution></div>

    </ul>
    <div class="footer">
      
      <span>Designed by </span><a href="https://www.caicai.me">CaiCai</a>
      <div class="by_zola"><a href="https://www.getzola.org/" target="_blank">Proudly published with Zola!</a></div>
      
    </div>
  </div>
  <div id="main">
    <div class="page-top animated fadeInDown">
      <div class="nav">
        
        
        
        
        <li><a  href="https://longfangsong.github.io/en/">Home</a></li>
        <li><a  href="https://longfangsong.github.io/en/about/">About</a></li><li><a  href="https://longfangsong.github.io/en/tags">Tags</a></li><li><a 
            href="https://longfangsong.github.io/en/archive/">Archive</a></li><li><a  href="https://longfangsong.github.io/en/links/">Links</a></li></div>
      <div class="information">
        <div class="back_btn">
          <a onclick="window.history.go(-1)" ><i
              class="fas fa-chevron-left"></i></a>
        </div>
        
        
          
        
          
        
        
        <div id="language-switch">
          <button onclick="showLanguages()" aria-label="show languages"><i class="fas fa-globe"></i></button>
          <div id="languages" style="display: none">
            
            <a onclick="window.location.href='https:&#x2F;&#x2F;longfangsong.github.io&#x2F;sv&#x2F;'"> Svenska </a>
            
            <a onclick="window.location.href='https:&#x2F;&#x2F;longfangsong.github.io&#x2F;'"> 中文 </a>
            
          </div>
        </div>
        
        <div class="avatar"><img src="https://longfangsong.github.io/images/avatar.jpg"></div>
      </div>
    </div>
    <div class="autopagerize_page_element">
      <div class="content">
        
<article class="post animated fadeInDown">
  <h1><a href="https:&#x2F;&#x2F;longfangsong.github.io&#x2F;en&#x2F;automata-4&#x2F;">Automata Theory • Büchi Automata</a></h1>
  
  <div class="post-content"><h2 id="o-languages">ω-Languages</h2>
<blockquote>
<p>Let $Σ$ be a set of symbols (not necessarily finite).
Following the standard definition from formal language theory, $Σ*$ is the set of all finite words over $Σ$.
Every finite word has a length, which is a natural number.
Given a word w of length n, w can be viewed as a function from the set $\{0,1,...,n−1\} → Σ$,
with the value at i giving the symbol at position i.
The infinite words, or ω-words, can likewise be viewed as functions from $\mathbb{N}$ to $Σ$.
The set of all infinite words over $Σ$ is denoted $Σ^{\omega}$.
The set of all finite and infinite words over $Σ$ is sometimes written $Σ^{\infty}$ or $Σ^{\leq \omega}$.
—— <a href="https://en.wikipedia.org/wiki/Omega_language">Wikipedia</a></p>
</blockquote>
<p>In simple terms, given an alphabet $Σ$, $Σ^{\omega}$ is the set of all <strong>infinite</strong> strings formed from it, and an ω-language over $Σ$ is a subset of this set.</p>
<p>For comparison: $\Sigma^*$ is all finite-length strings from alphabet $Σ$.</p>
<p>$$
Σ^{\infty} = \Sigma^* \cup \Sigma^{\omega}
$$</p>
<h3 id="operations-on-o-languages">Operations on ω-Languages</h3>
<h4 id="left-concatenation">Left Concatenation</h4>
<p>$KL$, where K is a language containing only finite-length strings, and L is an ω-language, represents left concatenation of K to L, meaning for each string $k \in K$ and $l \in L$ there is a new string $kl \in KL$.</p>
<p>Note that right concatenation ($LK$) is meaningless, because $L$ is already an ω-language containing infinite-length strings, and adding finite-length strings after infinite-length strings makes no sense.</p>
<h4 id="omega">$^\omega$</h4>
<p>$L^ω$ represents the language obtained by "infinitely repeating" all finite strings in language $L$.</p>
<h3 id="o-regular-languages">ω-Regular Languages</h3>
<p>A language is an ω-regular language if it can be written as:</p>
<ul>
<li>$A^ω$, where $A$ is a regular language that doesn't contain the empty string, or:</li>
<li>$A\cdot B$, where $A$ is a regular language and B is an ω-regular language</li>
<li>$A \cup B$, where both $A$ and $B$ are ω-regular languages, note that $\cup$ can only be performed finitely many times</li>
</ul>
<h2 id="o-regular-expressions">ω-Regular Expressions</h2>
<p>$\cdot$, $|$<sup class="footnote-reference"><a href="#1">1</a></sup> and $*$ have the same meanings in normal regular expressions.</p>
<p>However, in ω-regular expressions, we have a new operator $^{\omega}$, where $E^{\omega}$ means $E$ should be repeated infinitely many times.</p>
<p>For example, an ω-regular expression describing an infinite repeating binary decimal can be written as:</p>
<p>$$
(0|1)(0|1)*'.'(0|1)(0|1)*((0|1)*)^{\omega}
$$</p>
<p>where the final $((0|1)*)^{\omega}$ part represents the repeating section.</p>
<h2 id="buchi-automata">Büchi Automata<sup class="footnote-reference"><a href="#2">2</a></sup></h2>
<blockquote>
<p>A deterministic Büchi automaton is a tuple A = (Q,Σ,δ,q0,F) that consists of the following components:<br />
Q is a finite set. The elements of Q are called the states of A.<br />
Σ is a finite set called the alphabet of A.<br />
δ: Q × Σ → Q is a function, called the transition function of A.<br />
q0 is an element of Q, called the initial state of A.<br />
F⊆Q is the acceptance condition. A accepts exactly those runs in which at least one of the infinitely often occurring states is in F.<br />
In a (non-deterministic) Büchi automaton, the transition function δ is replaced with a transition relation Δ that returns a set of states, and the single initial state q0 is replaced by a set I of initial states.<br />
—— <a href="https://en.wikipedia.org/wiki/B%C3%BCchi_automaton">Wikipedia</a></p>
</blockquote>
<p>Basically, Büchi automata and finite automata "look the same", with the only difference being:</p>
<ul>
<li>Finite automata must stop in an accepting state after the input is "exhausted" to accept the input string, while Büchi automata require the input string to enter an accepting state "infinitely many times".</li>
</ul>
<p>Note: The deterministic and non-deterministic versions of Büchi automata are not equivalent. Deterministic Büchi automata are strictly weaker than their non-deterministic counterparts, while non-deterministic Büchi automata can recognize all ω-regular expressions.</p>
<p>Example: $(0|1)*0^\omega$ can be recognized by the following non-deterministic Büchi automaton, but cannot be accepted by a deterministic Büchi automaton.</p>
<p><img src="https://upload.wikimedia.org/wikipedia/commons/0/02/Buchi_non_deterministic_example.svg" alt="" /></p>
<h2 id="o-regular-expressions-rightarrow-buchi-automata">ω-Regular Expressions $\rightarrow$ Büchi Automata</h2>
<p>Inductively, we need to consider 3 cases:</p>
<ul>
<li>
<p>Top-level ω-regular expression of the form $A^ω$.
In this case, $A$ must be a regular expression, which we can convert to a non-deterministic finite automaton (NFA).
Then, for all accepting states of this NFA, add a transition arrow to each successor of A's initial state, with the transition character being the character on the arrow from the initial state to that successor, as shown:</p>
<p><img src="https://longfangsong.github.io/en/automata-4/A-to-Aw.svg" alt="A-to-A-w" /></p>
<p>I've only drawn one accepting state, but there can be multiple accepting states, each following the pattern of $a_0$ in the diagram, connecting back to each successor of the entry.</p>
</li>
<li>
<p>Top-level ω-regular expression of the form $A\cdot B$.
In this case, $A$ must be a regular expression which we can convert to an NFA, while $B$ must be an ω-regular expression that can be (recursively) converted to a Büchi automaton using our current algorithm.
Then, downgrade A's accepting states to normal states and directly connect them to each successor of B's initial state, as shown:</p>
<p><img src="https://longfangsong.github.io/en/automata-4/A-B.svg" alt="A-B" />
<img src="https://longfangsong.github.io/en/automata-4/AB.svg" alt="AB" /></p>
</li>
<li>
<p>Top-level ω-regular expression of the form $A | B$.
Where both $A$ and $B$ are ω-regular expressions that can be (recursively) converted to Büchi automata using our current algorithm.
In this case, simply merge the initial states of $A$ and $B$.</p>
<p><img src="https://longfangsong.github.io/en/automata-4/A%7CB.svg" alt="A|B" /></p>
<p><img src="https://longfangsong.github.io/en/automata-4/A%7C%7CB.svg" alt="A||B" /></p>
</li>
</ul>
<h3 id="example">Example</h3>
<p>Provided by the Formal Methods example exam, in our course $|$ is written as $+$.</p>
<p>$$
a(b^ω + cc*ab^ω)
$$</p>
<p>The top level is of the form $A\cdot B$, where $A \rightarrow a$, $B \rightarrow b^ω + cc*ab^ω$.</p>
<p>We can first complete the NFA part of $a$.</p>
<p><img src="https://longfangsong.github.io/en/automata-4/a-%3Eunexp.svg" alt="A-&gt;unexp" /></p>
<p>Continue expanding $b^ω + cc*ab^ω$, where the top level is $+$.</p>
<p>Expand into two parts:</p>
<p><img src="https://longfangsong.github.io/en/automata-4/a-%3Eunexp12.svg" alt="a-&gt;unexp12" /></p>
<p>First consider the $b^\omega$ part, of the form $A^ω$, where $A \rightarrow b$, which can be expanded directly.</p>
<p><img src="https://longfangsong.github.io/en/automata-4/a-%3Eb*%7Ca-%3Eunexp2.svg" alt="a-&gt;b*|a-&gt;unexp2" /></p>
<p>The $cc*ab^ω$ part is of the form $AB$, where $A \rightarrow cc*a$, $B \rightarrow b^\omega$.</p>
<p><img src="https://longfangsong.github.io/en/automata-4/a-%3Eb*%7Ca-%3Ecc*a-%3Eunexp2.svg" alt="a-&gt;b*|a-&gt;cc*a-&gt;unexp2" /></p>
<p>Finally expand $b^\omega$.</p>
<p><img src="https://longfangsong.github.io/en/automata-4/full-expanded.svg" alt="full-expanded" /></p>
<p>And we get the final result.</p>
<h2 id="buchi-automata-rightarrow-o-regular-expressions">Büchi Automata $\rightarrow$ ω-Regular Expressions</h2>
<p>From the process of converting ω-regular expressions to Büchi automata above, we can see that all ω-regular expressions:</p>
<ul>
<li>May be of the form $A^ω$, corresponding to loops containing accepting states<sup class="footnote-reference"><a href="#3">3</a></sup> in the Büchi automaton graph.</li>
<li>May be of the form $AB$, corresponding to:
<ul>
<li>A "path" $q_{start} \to q_{k}$ starting from the initial state $q_{start}$, not containing accepting state $q_{k}$, where $q_{k}$ is an accepting state.</li>
<li>$q_{k}$ is in a loop<sup class="footnote-reference"><a href="#3">3</a></sup>.</li>
</ul>
</li>
<li>May be of the form $A|B$, corresponding to both $A$ and $B$ having at least one loop containing an accepting state.</li>
</ul>
<p>So, to convert a Büchi automaton back to an ω-regular expression, we need to:</p>
<ul>
<li>Identify all loops containing accepting states $q_k$ and convert these subgraphs to regular expressions $L_k$.</li>
<li>Identify all paths from the initial state $q_{start}$ to $q_k$ (without passing through $q_k$) and convert these subgraphs to regular expressions $R_{0k}$.</li>
<li>The desired ω-regular expression is $\Sigma_k^{0\le k&lt;\text{accept state count}}(R_{0k}\cdot L_{k})$.</li>
</ul>
<h3 id="example-1">Example</h3>
<p><img src="https://longfangsong.github.io/en/automata-4/am-full.svg" alt="am-full" /></p>
<p>For accepting state $q_1$:</p>
<ul>
<li>
<p>Its cycle:</p>
<p><img src="https://longfangsong.github.io/en/automata-4/bw.svg" alt="am-full" /></p>
<p>Corresponding regex is $b$<sup class="footnote-reference"><a href="#4">4</a></sup>.</p>
</li>
<li>
<p>Path from initial state $e$ to $q_1$:</p>
<p><img src="https://longfangsong.github.io/en/automata-4/e-to-q1.svg" alt="e-to-q1" /></p>
<p>Corresponding regex is: $((bc*a)|a)*c$.</p>
</li>
</ul>
<p>Therefore this branch's ω-regular expression is $((bc*a)|a)*c(b^\omega)$.</p>
<p>For accepting state $q_2$:</p>
<ul>
<li>
<p>Its cycle:</p>
<p><img src="https://longfangsong.github.io/en/automata-4/complex-w.svg" alt="complex-w" /></p>
<p>Corresponding regex is: $(c*)|(aa*b)$</p>
</li>
<li>
<p>Path from initial state $e$ to $q_2$:</p>
<p><img src="https://longfangsong.github.io/en/automata-4/e-to-q2.svg" alt="e-to-q2" /></p>
<p>Corresponding regex is: $a*b$.</p>
</li>
</ul>
<p>Therefore this branch's ω-regular expression is $a*b ((c*)|(aa*b))^\omega$.</p>
<p>Combining both branches, the overall ω-regular expression is $(((bc*a)|a)*c(b^\omega)) | (a*b ((c*)|(aa*b))^\omega)$</p>
<h2 id="references">References</h2>
<ul>
<li><a href="https://archive.model.in.tum.de/um/courses/auto/ws1213/slides1213/omega-automata-powerpoint.pdf">Slide from TUM</a>.</li>
</ul>
<div class="footnote-definition" id="1"><sup class="footnote-definition-label">1</sup>
<p>Sometimes written as $+$, $\cup$ or even $\uplus$ - mathematicians/computer scientists really should standardize their notation!</p>
</div>
<div class="footnote-definition" id="2"><sup class="footnote-definition-label">2</sup>
<p>I mention Büchi automata here because it was covered in our Formal Methods course, but there are actually many types of automata that can handle ω-languages, see <a href="https://en.wikipedia.org/wiki/%CE%A9-automaton">Wikipedia</a>, among which Rabin automata are probably the most interesting.</p>
</div>
<div class="footnote-definition" id="3"><sup class="footnote-definition-label">3</sup>
<p>A more accurate term would be "strongly connected component".</p>
</div>
<div class="footnote-definition" id="4"><sup class="footnote-definition-label">4</sup>
<p>Could also be $b*$, though $(b*)^\omega \equiv b^\omega$.</p>
</div>
</div>
  <div class="post-footer">
    <div class="meta">
      <div class="info">
        
        <i class="far fa-sun"></i><span class="date">2024-10-26</span>
        
        
        <i class="fas fa-tags"></i>
        
        <a class="tag" href="https://longfangsong.github.io/en/tags/automata">&nbsp;automata</a>
        
        
      </div>
    </div>
  </div>
</article>
<div class="share">
  <div class="weibo">
    <a class="fab fa-weibo"
      href="javascript:void((function(s,d,e){try{}catch(e){}var f='http://service.weibo.com/share/share.php?',u=d.location.href,p=['url=',e(u),'&title=',e(d.title),'&appkey=2924220432'].join('');function a(){if(!window.open([f,p].join(''),'mb',['toolbar=0,status=0,resizable=1,width=620,height=450,left=',(s.width-620)/2,',top=',(s.height-450)/2].join('')))u.href=[f,p].join('');};if(/Firefox/.test(navigator.userAgent)){setTimeout(a,0)}else{a()}})(screen,document,encodeURIComponent));"></a>
  </div>
  <div class="twitter">
    <a class="fab fa-twitter"
      href="http://twitter.com/share?text=Automata Theory • Büchi Automata&url=https:&#x2F;&#x2F;longfangsong.github.io&#x2F;en&#x2F;automata-4&#x2F;&hashtags=automata"></a>
  </div>
</div>





  <script src="https://utteranc.es/client.js"
    repo="longfangsong&#x2F;longfangsong.github.io"
    issue-term="pathname"
    theme="github-light"
    crossorigin="anonymous"
    async>
  </script>



<script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
<script>
  MathJax = {
    tex: {
      displayMath: [['$$', '$$'], ["\\[", "\\]"]],
      inlineMath: [['$', '$'], ['\\(', '\\)']]
    }
  };
</script>
<script type="text/javascript" id="MathJax-script" async
  src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js">
  </script>




      </div>
    </div>
  </div>
  
  
  <script>
    function showLanguages() {
      let currentDisplay = document.getElementById("languages").style.display;
      if (currentDisplay == 'none') {
        document.getElementById("languages").style.display = 'block';
      } else {
        document.getElementById("languages").style.display = 'none';
      }
    }
  </script>
</body>

</html>
