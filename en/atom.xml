<?xml version="1.0" encoding="UTF-8"?>
<feed xmlns="http://www.w3.org/2005/Atom" xml:lang="en">
	<title>Blog</title>
	<subtitle>Und grün des Theorie goldner Baum</subtitle>
	<link href="https://longfangsong.github.io/en/atom.xml" rel="self" type="application/atom+xml"/>
  <link href="https://longfangsong.github.io"/>
	<generator uri="https://www.getzola.org/">Zola</generator>
	<updated>2022-07-18T05:15:33.302+00:00</updated>
	<id>https://longfangsong.github.io/en/atom.xml</id>
	<entry xml:lang="en">
		<title>HoTTEST Summer School HoTT Notes 3</title>
		<published>2022-07-18T05:15:33.302+00:00</published>
		<updated>2022-07-18T05:15:33.302+00:00</updated>
		<link rel="alternate" href="https://longfangsong.github.io/en/hottest-notes-hott-3/" type="text/html"/>
		<id>https://longfangsong.github.io/en/hottest-notes-hott-3/</id>
		<content type="html">&lt;h2 id=&quot;identity-types&quot;&gt;Identity Types&lt;&#x2F;h2&gt;
&lt;blockquote&gt;
&lt;p&gt;In intensional type theory under the propositions as types paradigm, an identity type (or equality type) is the incarnation of equality. That is, for any type $A$ and any terms $x,y:A$, the type $Id_A(x,y)$ is “the type of proofs that $x=y$” or “the type of reasons why $x=y$”. —— nLab&lt;&#x2F;p&gt;
&lt;&#x2F;blockquote&gt;
&lt;h3 id=&quot;judgemental-equality-vs-propositional-equality&quot;&gt;Judgemental Equality vs Propositional Equality&lt;&#x2F;h3&gt;
&lt;p&gt;Judgemental equality, or definitional equality since we won&#x27;t pay much attention to the difference in this course, is intensional equality, or equality of meaning (synonymy).
Or in words understandable for normal human beings, definitional equality is something equals to another thing &amp;quot;magically&amp;quot;, they are equal to each other just because we SAY IT.&lt;&#x2F;p&gt;
&lt;p&gt;For example, in all the rules mentioned in past several notes and proofs built by these rules, we use judgemental equality $\doteq$.&lt;&#x2F;p&gt;
&lt;p&gt;As we all see, there are many terms which are judgmental equal and we can prove them, but there&#x27;re also some terms which &amp;quot;should&amp;quot; be equal but we cannot prove, eg. we cannot find a proof for $add(0, x) \doteq x$, and that&#x27;s where propositional equality and identity types come for help, which basically is a type which stands for &amp;quot;equal&amp;quot;.&lt;&#x2F;p&gt;
&lt;h3 id=&quot;type-constructors-often-internalize-structure&quot;&gt;Type Constructors Often Internalize Structure&lt;&#x2F;h3&gt;
&lt;p&gt;(Don&#x27;t really get what the teacher want to show by saying these.)&lt;&#x2F;p&gt;
&lt;p&gt;Maybe used to show that types are used to describe some certain property of something, so we can think identity types internalize the property that something is propositional equal to another thing.&lt;&#x2F;p&gt;
&lt;h3 id=&quot;rules-on-identity-types&quot;&gt;Rules on Identity Types&lt;&#x2F;h3&gt;
&lt;p&gt;$$
=-form:
\require{bussproofs}
\begin{prooftree}
\AxiomC{$A\ type\ a:A\ b:A$}
\UnaryInfC{$a=_A b\ type$}
\end{prooftree}
$$&lt;&#x2F;p&gt;
&lt;p&gt;$$
=-intro:
\require{bussproofs}
\begin{prooftree}
\AxiomC{$a:A$}
\UnaryInfC{$refl_a : a=_A a\ type$}
\end{prooftree}
$$&lt;&#x2F;p&gt;
&lt;p&gt;$$
=-elim:
\require{bussproofs}
\begin{prooftree}
\AxiomC{$x:A, y:A, z:x=_A y \vdash D(x,y,z)\ type$}
\AxiomC{$x:A \vdash d:D(x,x,refl_x)\ type$}
\BinaryInfC{$x:A, y:A, z:x=_A y \vdash ind_=(d,x,y,z) : D(x,y,z)\ type$}
\end{prooftree}
$$&lt;&#x2F;p&gt;
&lt;p&gt;$$
=-comp:
\require{bussproofs}
\begin{prooftree}
\AxiomC{$x:A, y:A, z:x=_A y \vdash D(x,y,z)\ type$}
\AxiomC{$x:A \vdash d:D(x,x,refl_x)\ type$}
\BinaryInfC{$x:A \vdash ind_=(d,x,x,refl_x) \doteq d: D(x,x,refl_x)$}
\end{prooftree}
$$&lt;&#x2F;p&gt;
&lt;h3 id=&quot;reflexivity&quot;&gt;Reflexivity&lt;&#x2F;h3&gt;
&lt;p&gt;We can use $refl_x$ to internalize (or &amp;quot;downgrade&amp;quot;, if you prefer human being&#x27;s language) judgmental equality to propositional equality, ie.&lt;&#x2F;p&gt;
&lt;p&gt;Since we have&lt;&#x2F;p&gt;
&lt;p&gt;If $a \doteq b : A$, then $(a =_A b) \doteq (a =_A a)$, and&lt;&#x2F;p&gt;
&lt;p&gt;if $refl_a:a =_A a$ and $(a =_A b) \doteq (a =_A a)$, then $r_a:a=_Ab$.&lt;&#x2F;p&gt;
&lt;p&gt;So we can internalize $a \doteq b : A$ with $r_a:a=_Ab$.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;functoriality&quot;&gt;Functoriality&lt;sup class=&quot;footnote-reference&quot;&gt;&lt;a href=&quot;#1&quot;&gt;1&lt;&#x2F;a&gt;&lt;&#x2F;sup&gt;&lt;&#x2F;h2&gt;
&lt;blockquote&gt;
&lt;p&gt;Functoriality means that something is a functor. e.g. when someone asks about the functoriality of some construction, they&#x27;re asking whether or not it can be upgraded to a functor. —— &lt;a href=&quot;https:&#x2F;&#x2F;math.stackexchange.com&#x2F;questions&#x2F;1922113&#x2F;what-exactly-is-functoriality&quot;&gt;stackexchange problem&lt;&#x2F;a&gt;&lt;&#x2F;p&gt;
&lt;&#x2F;blockquote&gt;
&lt;p&gt;So basically it is the property of whether a construction is a functor.&lt;&#x2F;p&gt;
&lt;p&gt;Arrrrgh, functor, another classical Haskell thing.&lt;&#x2F;p&gt;
&lt;blockquote&gt;
&lt;p&gt;In functional programming, a functor is a design pattern inspired by the definition from category theory, that allows for a generic type to apply a function inside without changing the structure of the generic type. —— Wikipedia&lt;&#x2F;p&gt;
&lt;&#x2F;blockquote&gt;
&lt;p&gt;Or, functors are functions act on paths&#x2F;terms of the identity type.&lt;&#x2F;p&gt;
&lt;p&gt;For any two types $A$, $B$, any function $f:A\rightarrow B$, and any two terms $a:A, a&#x27;:A$, there exists a functor:
$$
ap_f: a=_Aa&#x27; \rightarrow f\ a=_B f\ a&#x27;
$$&lt;&#x2F;p&gt;
&lt;p&gt;Or in math language:&lt;&#x2F;p&gt;
&lt;p&gt;$$
ap: \Pi_{(f:A\rightarrow B)} \Pi_{(a,a&#x27;:A)} a =_A a&#x27; \rightarrow b =_A b&#x27;
$$&lt;&#x2F;p&gt;
&lt;p&gt;We can prove this by using $=-elim$ rule.&lt;&#x2F;p&gt;
&lt;p&gt;$$
\require{bussproofs}
\begin{prooftree}
\AxiomC{$f:A\rightarrow B, a:A \vdash refl_{f\ a}:f\ a=_B f\ a$}
\UnaryInfC{$f:A\rightarrow B, a:A, a&#x27;:A, p: a=_Aa&#x27; \vdash ind_=(refl_{f\ a},a,a&#x27;,p): f\ a =_B f\ a&#x27; $}
\UnaryInfC{$\lambda f. \lambda a.\lambda a&#x27;. ind_=(refl_{f\ a},a,a&#x27;,p):\Pi_{(f:A\rightarrow B)} \Pi_{(a,a&#x27;:A)} a =_A a&#x27; \rightarrow f\ a =_B f\ a&#x27;$}
\end{prooftree}
$$&lt;&#x2F;p&gt;
&lt;h3 id=&quot;proof-example&quot;&gt;Proof Example&lt;&#x2F;h3&gt;
&lt;p&gt;Prove: $\Pi_{(n:\mathbb N)} add(0,n) = n$.&lt;&#x2F;p&gt;
&lt;p&gt;You can use the following two judgemental equality rules, which is provable before we have $refl$ or such things:
$$
add(n, 0) \doteq n
$$&lt;&#x2F;p&gt;
&lt;p&gt;$$
add(n, succ(m)) \doteq succ(add(n, m))
$$&lt;&#x2F;p&gt;
&lt;p&gt;We start as normal:&lt;&#x2F;p&gt;
&lt;p&gt;$$
\require{bussproofs}
\begin{prooftree}
\AxiomC{$$}
\UnaryInfC{$?:\Pi_{(n:\mathbb N)} add(0,n)=n$}
\end{prooftree}
$$&lt;&#x2F;p&gt;
&lt;p&gt;Then let&#x27;s use $\Pi-intro$:&lt;&#x2F;p&gt;
&lt;p&gt;$$
\require{bussproofs}
\begin{prooftree}
\AxiomC{$n:\mathbb N \vdash ?:add(0,n)=n$}
\UnaryInfC{$?:\Pi_{(n:\mathbb N)} add(0,n)=n$}
\end{prooftree}
$$&lt;&#x2F;p&gt;
&lt;p&gt;Then $\mathbb N-elim$:&lt;&#x2F;p&gt;
&lt;p&gt;$$
\require{bussproofs}
\begin{prooftree}
\AxiomC{$?: add(0,0)=0$}
\AxiomC{$n:\mathbb N, p: add(0, n)=n \vdash ?: add(0,succ(n))=succ(n)$}
\BinaryInfC{$n:\mathbb N \vdash ?:add(0,n)=n$}
\UnaryInfC{$?:\Pi_{(n:\mathbb N)} add(0,n)=n$}
\end{prooftree}
$$&lt;&#x2F;p&gt;
&lt;p&gt;For $add(0,0)=0$, we can downgrade judgemental equal rule $add(n, 0) \doteq n$ where $n=0$ with $refl_0$.&lt;&#x2F;p&gt;
&lt;p&gt;For $add(0,succ(n))=succ(n)$, we can use $ap_{succ}$ on $p$:&lt;&#x2F;p&gt;
&lt;p&gt;$$
\displaylines {
ap_{succ}: a=a&#x27; \rightarrow succ(a)=succ(a&#x27;)\\
ap_{succ}\ p: (a=a&#x27; \rightarrow succ(a)=succ(a&#x27;))\ (add(0, n)=n)  \\
ap_{succ}\ p: succ(add(0, n))=succ(n)
}
$$&lt;&#x2F;p&gt;
&lt;p&gt;Let&#x27;s put them in:&lt;&#x2F;p&gt;
&lt;p&gt;$$
\require{bussproofs}
\begin{prooftree}
\AxiomC{$refl_0: add(0,0)=0$}
\AxiomC{$n:\mathbb N, p: add(0, n)=n \vdash ap_{succ}\ p: add(0,succ(n))=succ(n)$}
\BinaryInfC{$n:\mathbb N \vdash ?:add(0,n)=n$}
\UnaryInfC{$?:\Pi_{(n:\mathbb N)} add(0,n)=n$}
\end{prooftree}
$$&lt;&#x2F;p&gt;
&lt;p&gt;And fill the holes:&lt;&#x2F;p&gt;
&lt;p&gt;$$
\require{bussproofs}
\begin{prooftree}
\AxiomC{$refl_0: add(0,0)=0$}
\AxiomC{$n:\mathbb N, p: add(0, n)=n \vdash ap_{succ}\ p: add(0,succ(n))=succ(n)$}
\BinaryInfC{$n:\mathbb N \vdash ind_{\mathbb N}(refl_0, ap_{succ}\ p, n):add(0,n)=n$}
\UnaryInfC{$\lambda n. ind_{\mathbb N}(refl_0, ap_{succ}\ p, n):\Pi_{(n:\mathbb N)} add(0,n)=n$}
\end{prooftree}
$$&lt;&#x2F;p&gt;
&lt;p&gt;In agda, note &lt;code&gt;ap&lt;&#x2F;code&gt; is called &lt;code&gt;cong&lt;&#x2F;code&gt; in agda:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;agda&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-agda &quot;&gt;&lt;code class=&quot;language-agda&quot; data-lang=&quot;agda&quot;&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;add&lt;&#x2F;span&gt;&lt;span&gt;-&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;0&lt;&#x2F;span&gt;&lt;span&gt;-&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;n &lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;∀&lt;&#x2F;span&gt;&lt;span&gt; (&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;n &lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;ℕ&lt;&#x2F;span&gt;&lt;span&gt;) → &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;0 &lt;&#x2F;span&gt;&lt;span&gt;+ &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;n &lt;&#x2F;span&gt;&lt;span&gt;≡ &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;n
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;add&lt;&#x2F;span&gt;&lt;span&gt;-&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;0&lt;&#x2F;span&gt;&lt;span&gt;-&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;n zero &lt;&#x2F;span&gt;&lt;span&gt;= &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;refl
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;add&lt;&#x2F;span&gt;&lt;span&gt;-&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;0&lt;&#x2F;span&gt;&lt;span&gt;-&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;n&lt;&#x2F;span&gt;&lt;span&gt; (&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;suc n&lt;&#x2F;span&gt;&lt;span&gt;) = &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;cong suc refl 
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;h2 id=&quot;the-groupoidal-behaviour-of-types&quot;&gt;The Groupoidal Behaviour of Types&lt;&#x2F;h2&gt;
&lt;p&gt;We can think terms as points, and we can use paths&#x2F;homotopies which stands for identity to connect them.&lt;&#x2F;p&gt;
&lt;p&gt;&lt;img src=&quot;https:&#x2F;&#x2F;longfangsong.github.io&#x2F;en&#x2F;hottest-notes-hott-3&#x2F;.&#x2F;connected.png&quot; alt=&quot;connected&quot; &#x2F;&gt;&lt;&#x2F;p&gt;
&lt;p&gt;Here are three terms a, b and c, and a is proportional equal to b and b is proportional equal to c, which we represent with p and q.&lt;&#x2F;p&gt;
&lt;p&gt;And we can play freely with these terms and equals, eg.&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;We can have multiple equalities of the same type
&lt;img src=&quot;https:&#x2F;&#x2F;longfangsong.github.io&#x2F;en&#x2F;hottest-notes-hott-3&#x2F;&quot; alt=&quot;&quot; &#x2F;&gt;&lt;&#x2F;li&gt;
&lt;li&gt;We can take the inverse of an equality
&lt;img src=&quot;https:&#x2F;&#x2F;longfangsong.github.io&#x2F;en&#x2F;hottest-notes-hott-3&#x2F;&quot; alt=&quot;&quot; &#x2F;&gt;&lt;&#x2F;li&gt;
&lt;li&gt;We can take composition of equalities
&lt;img src=&quot;https:&#x2F;&#x2F;longfangsong.github.io&#x2F;en&#x2F;hottest-notes-hott-3&#x2F;&quot; alt=&quot;&quot; &#x2F;&gt;&lt;&#x2F;li&gt;
&lt;li&gt;We can have equalities of equalities
&lt;img src=&quot;https:&#x2F;&#x2F;longfangsong.github.io&#x2F;en&#x2F;hottest-notes-hott-3&#x2F;&quot; alt=&quot;&quot; &#x2F;&gt;&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;And that&#x27;s how homotopies in space behave.&lt;&#x2F;p&gt;
&lt;h3 id=&quot;proof-of-these-properties&quot;&gt;Proof of these properties&lt;&#x2F;h3&gt;
&lt;h4 id=&quot;inverse-of-an-equality&quot;&gt;Inverse of an Equality&lt;&#x2F;h4&gt;
&lt;p&gt;$$
\require{bussproofs}
\begin{prooftree}
\AxiomC{$a:A\vdash refl_a:a=_A a$}
\UnaryInfC{$a,b:A, p: a=_A b \vdash ind_=(refl_a,a,b,p):b=_A a$}
\UnaryInfC{$\lambda a,b,p. ind_=(refl_a,a,b,p):\Pi_{(a,b:A)}a=_Ab \rightarrow b=_Aa$}
\end{prooftree}
$$&lt;&#x2F;p&gt;
&lt;h4 id=&quot;composition-of-equalities&quot;&gt;Composition of Equalities&lt;&#x2F;h4&gt;
&lt;p&gt;$$
\require{bussproofs}
\begin{prooftree}
\AxiomC{$a,c:A\vdash \lambda x.x: a=_Ac \rightarrow a=_A c$}
\UnaryInfC{$a,b,c:A, p:a=_Ab \vdash ind_=(\lambda x.x, a, b,p):b=_Ac \rightarrow a=_Ac$}
\UnaryInfC{$\lambda a,b,c,p. ind_=(\lambda x.x, a, b,p): \Pi_{(a,b,c:A)} a=_Ab \rightarrow b=_Ac \rightarrow a=_Ac$}
\end{prooftree}
$$&lt;&#x2F;p&gt;
&lt;h4 id=&quot;composition-of-equalities-1&quot;&gt;Composition of Equalities&lt;&#x2F;h4&gt;
&lt;h2 id=&quot;the-space-interpretation-of-types&quot;&gt;The Space Interpretation of Types&lt;&#x2F;h2&gt;
&lt;p&gt;There&#x27;s an interpretation of dependent type theory into space (the category of Kan complexes&lt;sup class=&quot;footnote-reference&quot;&gt;&lt;a href=&quot;#2&quot;&gt;2&lt;&#x2F;a&gt;&lt;&#x2F;sup&gt;) in which:&lt;&#x2F;p&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;Type theory&lt;&#x2F;th&gt;&lt;th&gt;Homotopy theory&lt;&#x2F;th&gt;&lt;th&gt;Kan complexes&lt;&#x2F;th&gt;&lt;&#x2F;tr&gt;&lt;&#x2F;thead&gt;&lt;tbody&gt;
&lt;tr&gt;&lt;td&gt;Types&lt;&#x2F;td&gt;&lt;td&gt;Spaces&lt;&#x2F;td&gt;&lt;td&gt;Kan complexes&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;Terms&lt;&#x2F;td&gt;&lt;td&gt;Points&lt;&#x2F;td&gt;&lt;td&gt;0-Cells&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;Equalities&lt;&#x2F;td&gt;&lt;td&gt;Path fibration&lt;&#x2F;td&gt;&lt;td&gt;0-Cells of path object&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;$\pi: \Sigma_{(b:B)}E(b)\rightarrow B$&lt;&#x2F;td&gt;&lt;td&gt;&lt;&#x2F;td&gt;&lt;td&gt;Kan fibrations&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;$\pi: \Pi_{(b:B)}E(b)$&lt;&#x2F;td&gt;&lt;td&gt;&lt;&#x2F;td&gt;&lt;td&gt;The space of sections of $\pi: \Pi_{(b:B)}E(b)$&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;Dependent types&lt;&#x2F;td&gt;&lt;td&gt;Fibrations&lt;&#x2F;td&gt;&lt;td&gt;&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;Dependent pair type&lt;&#x2F;td&gt;&lt;td&gt;Total Space&lt;&#x2F;td&gt;&lt;td&gt;&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;&#x2F;tbody&gt;&lt;&#x2F;table&gt;
&lt;h2 id=&quot;transport&quot;&gt;Transport&lt;&#x2F;h2&gt;
&lt;p&gt;For any dependent type $x:B\vdash E(B)\ type$,
any terms $b,b&#x27;:B$ and any equality $p:b=_Bb&#x27;$, there is
a function $tr_B:E(b)\rightarrow E(b&#x27;)$&lt;&#x2F;p&gt;
&lt;p&gt;Basically it means propositional qquality remains when apply some dependent type &amp;quot;over&amp;quot; it.&lt;&#x2F;p&gt;
&lt;p&gt;This is part of a more sophisticated relationship between type theory and homotopy theory (Quillen model category theory)
Transport says
that $\pi: \Sigma_{(b:B)}E(b)\rightarrow B$ behaves like a fibration in a QMC.&lt;&#x2F;p&gt;
&lt;h3 id=&quot;proof&quot;&gt;Proof&lt;&#x2F;h3&gt;
&lt;p&gt;$$
\require{bussproofs}
\begin{prooftree}
\AxiomC{$b:B\vdash \lambda x.x: E(b) \rightarrow E(b)$}
\UnaryInfC{$b,b&#x27;:B,p:b=_Bb&#x27;\vdash ind_=(\lambda x.x, b, b&#x27;, p): E(b) \rightarrow E(b&#x27;)$}
\UnaryInfC{$\lambda b,b,p.ind_=(\lambda x.x, b, b&#x27;, p): \Pi_{(b,b&#x27;:B)}(b=_Bb&#x27;) \rightarrow E(b) \rightarrow E(b&#x27;)$}
\end{prooftree}
$$&lt;&#x2F;p&gt;
&lt;div class=&quot;footnote-definition&quot; id=&quot;1&quot;&gt;&lt;sup class=&quot;footnote-definition-label&quot;&gt;1&lt;&#x2F;sup&gt;
&lt;p&gt;The VSCode spell checker told me this is not even an existing word, and so do many mathematic terms in this article, mathematicians are really good at inventing terms!&lt;&#x2F;p&gt;
&lt;&#x2F;div&gt;
&lt;div class=&quot;footnote-definition&quot; id=&quot;2&quot;&gt;&lt;sup class=&quot;footnote-definition-label&quot;&gt;2&lt;&#x2F;sup&gt;
&lt;p&gt;WTF is that 😭 TODO: learn it.&lt;&#x2F;p&gt;
&lt;&#x2F;div&gt;
</content>
	</entry>
	<entry xml:lang="en">
		<title>HoTTEST Summer School HoTT Notes 2</title>
		<published>2022-07-16T05:45:57.294+00:00</published>
		<updated>2022-07-16T05:45:57.294+00:00</updated>
		<link rel="alternate" href="https://longfangsong.github.io/en/hottest-notes-hott-2/" type="text/html"/>
		<id>https://longfangsong.github.io/en/hottest-notes-hott-2/</id>
		<content type="html">&lt;h2 id=&quot;inductive-types&quot;&gt;Inductive Types&lt;&#x2F;h2&gt;
&lt;blockquote&gt;
&lt;p&gt;In type theory, a system has inductive types if it has facilities for creating a new type from constants and functions that create terms of that type. —— Wikipedia&lt;&#x2F;p&gt;
&lt;&#x2F;blockquote&gt;
&lt;p&gt;eg.&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;agda&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-agda &quot;&gt;&lt;code class=&quot;language-agda&quot; data-lang=&quot;agda&quot;&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;data &lt;&#x2F;span&gt;&lt;span&gt;Bool: Type &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;where
&lt;&#x2F;span&gt;&lt;span&gt;  &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;true false&lt;&#x2F;span&gt;&lt;span&gt;: Bool
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;h3 id=&quot;examples&quot;&gt;Examples&lt;&#x2F;h3&gt;
&lt;h4 id=&quot;bool&quot;&gt;bool&lt;&#x2F;h4&gt;
&lt;p&gt;$$
bool-form: 
\require{bussproofs}
\begin{prooftree}
\AxiomC{}
\UnaryInfC{$\Gamma \vdash bool\ type$}
\end{prooftree}
$$&lt;&#x2F;p&gt;
&lt;p&gt;$$
bool-intro: 
\require{bussproofs}
\begin{prooftree}
\AxiomC{}
\UnaryInfC{$\Gamma \vdash true:bool$}
\end{prooftree}
\ \ \ \ 
\require{bussproofs}
\begin{prooftree}
\AxiomC{}
\UnaryInfC{$\Gamma \vdash false:bool$}
\end{prooftree}
$$&lt;&#x2F;p&gt;
&lt;p&gt;$$
bool-elim: 
\require{bussproofs}
\begin{prooftree}
\AxiomC{$\Gamma,x:bool \vdash D(x)\ type$}
\AxiomC{$\Gamma \vdash a: D(true)$}
\AxiomC{$\Gamma \vdash a: D(false)$}
\TrinaryInfC{$\Gamma,x:bool \vdash ind_{bool}(a,b,x):D(x)$}
\end{prooftree}
$$&lt;&#x2F;p&gt;
&lt;p&gt;$$
bool-comp: 
\require{bussproofs}
\begin{prooftree}
\AxiomC{$\Gamma,x:bool \vdash D(x)\ type$}
\AxiomC{$\Gamma \vdash a: D(true)$}
\AxiomC{$\Gamma \vdash a: D(false)$}
\TrinaryInfC{$\displaylines {\Gamma \vdash ind_{bool}(a,b,true) \doteq a:D(true)\\ \Gamma \vdash ind_{bool}(a,b,false) \doteq b:D(false)}$}
\end{prooftree}
$$&lt;&#x2F;p&gt;
&lt;h4 id=&quot;coproduct&quot;&gt;Coproduct&lt;&#x2F;h4&gt;
&lt;p&gt;$$
+-form: 
\require{bussproofs}
\begin{prooftree}
\AxiomC{$\Gamma \vdash P\ type$}
\AxiomC{$\Gamma \vdash Q\ type$}
\BinaryInfC{$\Gamma \vdash P+Q\ type$}
\end{prooftree}
$$&lt;&#x2F;p&gt;
&lt;p&gt;$$
+-intro: 
\require{bussproofs}
\begin{prooftree}
\AxiomC{$\Gamma \vdash p:P$}
\UnaryInfC{$\Gamma \vdash inl(p):P+Q$}
\end{prooftree}
\ \ \ \ 
\require{bussproofs}
\begin{prooftree}
\AxiomC{$\Gamma \vdash q:Q$}
\UnaryInfC{$\Gamma \vdash inr(q):P+Q$}
\end{prooftree}
$$&lt;&#x2F;p&gt;
&lt;p&gt;$$
+-elim: 
\require{bussproofs}
\begin{prooftree}
\AxiomC{$\Gamma,x:P+Q \vdash D(x)\ type$}
\AxiomC{$\Gamma \vdash a: D(inl(p))$}
\AxiomC{$\Gamma \vdash b: D(inr(q))$}
\TrinaryInfC{$\Gamma,x:P+Q \vdash ind_+(a,b,x):D(x)$}
\end{prooftree}
$$&lt;&#x2F;p&gt;
&lt;p&gt;$$
+-comp: 
\require{bussproofs}
\begin{prooftree}
\AxiomC{$\Gamma,x:P+Q \vdash D(x)\ type$}
\AxiomC{$\Gamma \vdash a: D(inl(p))$}
\AxiomC{$\Gamma \vdash b: D(inr(q))$}
\TrinaryInfC{$\displaylines {\Gamma \vdash ind_+(a,b,inl(p)) \doteq a:D(inl(p))\\ \Gamma \vdash ind_+(a,b,inr(q)) \doteq b:D(inr(q))}$}
\end{prooftree}
$$&lt;&#x2F;p&gt;
&lt;h5 id=&quot;proving-example&quot;&gt;Proving example&lt;&#x2F;h5&gt;
&lt;p&gt;Prove: For any types A,B,C, there&#x27;s a function $A\times B + A\times C \rightarrow A \times (B+C)$.&lt;&#x2F;p&gt;
&lt;p&gt;We start from writing what we want to prove down:&lt;&#x2F;p&gt;
&lt;p&gt;$$
\require{bussproofs}
\begin{prooftree}
\AxiomC{}
\UnaryInfC{$\vdash\ \ ?:A\times B + A\times C \rightarrow A \times (B+C)$}
\end{prooftree}
$$&lt;&#x2F;p&gt;
&lt;p&gt;When we want to construct a term which is of type $P\rightarrow Q$, the most natural way is to use the $\rightarrow-intro$ rule, ie. assume there exists a term which is of type $A\times B + A\times C$.&lt;&#x2F;p&gt;
&lt;p&gt;$$
\require{bussproofs}
\begin{prooftree}
\AxiomC{$x:A\times B + A\times C \vdash\ ?\ : A \times (B+C)$}
\UnaryInfC{$\Gamma\ \ ?:A\times B + A\times C \rightarrow A \times (B+C)$}
\end{prooftree}
$$&lt;&#x2F;p&gt;
&lt;p&gt;Now on the left side of $\vdash$, we have a term in the form of $P + Q$, which leads us to use
$+-elim$.&lt;&#x2F;p&gt;
&lt;p&gt;$$
\require{bussproofs}
\begin{prooftree}
\AxiomC{$x_1: A\times B \vdash\ ?\ : A \times (B+C)$}
\AxiomC{$x_2: A\times C \vdash\ ?\ : A \times (B+C)$}
\BinaryInfC{$x:A\times B + A\times C \vdash\ ?\ : A \times (B+C)$}
\UnaryInfC{$\Gamma\ \ ?:A\times B + A\times C \rightarrow A \times (B+C)$}
\end{prooftree}
$$&lt;&#x2F;p&gt;
&lt;p&gt;Let&#x27;s take the left one for example, to construct a term in type $A \times (B+C)$, we can just use pairing to construct a term in type $P\times Q$.&lt;&#x2F;p&gt;
&lt;p&gt;So now we just need to construct a term like $(p, q): (A, B+C)$, note $()$s here means pair.&lt;&#x2F;p&gt;
&lt;p&gt;For the first element of the pair, which type is A, we just need to take the first element of the pair $x_1$, ie $pr_1x_1$.&lt;&#x2F;p&gt;
&lt;p&gt;And for the second element, which type is B+C, we should use the $+-intro$ rule and put the second element of the pair $x_2$ in with $inl$.&lt;&#x2F;p&gt;
&lt;p&gt;And this is what we got:&lt;&#x2F;p&gt;
&lt;p&gt;$$
\require{bussproofs}
\begin{prooftree}
\AxiomC{$x_1: A\times B \vdash(pr_1x_1, inl(pr_2x_1)): A \times (B+C)$}
\AxiomC{$x_2: A\times C \vdash\ ?\ : A \times (B+C)$}
\BinaryInfC{$x:A\times B + A\times C \vdash\ ?\ : A \times (B+C)$}
\UnaryInfC{$\Gamma\ \ ?:A\times B + A\times C \rightarrow A \times (B+C)$}
\end{prooftree}
$$&lt;&#x2F;p&gt;
&lt;p&gt;The similar technique can be used on the right side:&lt;&#x2F;p&gt;
&lt;p&gt;$$
\require{bussproofs}
\begin{prooftree}
\AxiomC{$x_1: A\times B \vdash(pr_1x_1, inl(pr_2x_1)): A \times (B+C)$}
\AxiomC{$x_2: A\times C \vdash(pr_1x_2, inr(pr_2x_2)): A \times (B+C)$}
\BinaryInfC{$x:A\times B + A\times C \vdash\ ?\ : A \times (B+C)$}
\UnaryInfC{$\Gamma\ \ ?:A\times B + A\times C \rightarrow A \times (B+C)$}
\end{prooftree}
$$&lt;&#x2F;p&gt;
&lt;p&gt;Then fill the hole we left when applying $+-elim$:&lt;&#x2F;p&gt;
&lt;p&gt;$$
\require{bussproofs}
\begin{prooftree}
\AxiomC{$x_1: A\times B \vdash(pr_1x_1, inl(pr_2x_1)): A \times (B+C)$}
\AxiomC{$x_2: A\times C \vdash(pr_1x_2, inr(pr_2x_2)): A \times (B+C)$}
\BinaryInfC{$x:A\times B + A\times C \vdash ind_+((pr_1x_1, inl(pr_2x_1)), (pr_1x_2, inr(pr_2x_2)), x) : A \times (B+C)$}
\UnaryInfC{$\Gamma\ \ ?:A\times B + A\times C \rightarrow A \times (B+C)$}
\end{prooftree}
$$&lt;&#x2F;p&gt;
&lt;p&gt;Now fill the last hole by introducing a $λ$ and we are done:&lt;&#x2F;p&gt;
&lt;p&gt;$$
\require{bussproofs}
\begin{prooftree}
\AxiomC{$x_1: A\times B \vdash(pr_1x_1, inl(pr_2x_1)): A \times (B+C)$}
\AxiomC{$x_2: A\times C \vdash(pr_1x_2, inr(pr_2x_2)): A \times (B+C)$}
\BinaryInfC{$x:A\times B + A\times C \vdash ind_+((pr_1x_1, inl(pr_2x_1)), (pr_1x_2, inr(pr_2x_2)), x) : A \times (B+C)$}
\UnaryInfC{$\vdash\ \lambda\ x. ind_+((pr_1x_1, inl(pr_2x_1)), (pr_1x_2, inr(pr_2x_2)), x): A\times B + A\times C \rightarrow A \times (B+C)$}
\end{prooftree}
$$&lt;&#x2F;p&gt;
&lt;p&gt;In agda:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;agda&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-agda &quot;&gt;&lt;code class=&quot;language-agda&quot; data-lang=&quot;agda&quot;&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;open &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;import &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;Data&lt;&#x2F;span&gt;&lt;span&gt;.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;Product
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;open &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;import &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;Data&lt;&#x2F;span&gt;&lt;span&gt;.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;Sum renaming&lt;&#x2F;span&gt;&lt;span&gt; (&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;_&lt;&#x2F;span&gt;&lt;span&gt;⊎&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;_ to _&lt;&#x2F;span&gt;&lt;span&gt;+&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;_&lt;&#x2F;span&gt;&lt;span&gt;)
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;t &lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;∀&lt;&#x2F;span&gt;&lt;span&gt; (&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;A B C &lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;Set&lt;&#x2F;span&gt;&lt;span&gt;) → &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;A &lt;&#x2F;span&gt;&lt;span&gt;× &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;B &lt;&#x2F;span&gt;&lt;span&gt;+ &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;A &lt;&#x2F;span&gt;&lt;span&gt;× &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;C &lt;&#x2F;span&gt;&lt;span&gt;→ &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;A &lt;&#x2F;span&gt;&lt;span&gt;× (&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;B &lt;&#x2F;span&gt;&lt;span&gt;+ &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;C&lt;&#x2F;span&gt;&lt;span&gt;)
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;t &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;A B C&lt;&#x2F;span&gt;&lt;span&gt; (&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;inj&lt;&#x2F;span&gt;&lt;span&gt;₁ (&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;fst &lt;&#x2F;span&gt;&lt;span&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;snd&lt;&#x2F;span&gt;&lt;span&gt;)) = &lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;fst &lt;&#x2F;span&gt;&lt;span&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;inj&lt;&#x2F;span&gt;&lt;span&gt;₁ &lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;snd
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;t &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;A B C&lt;&#x2F;span&gt;&lt;span&gt; (&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;inj&lt;&#x2F;span&gt;&lt;span&gt;₂ (&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;fst &lt;&#x2F;span&gt;&lt;span&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;snd&lt;&#x2F;span&gt;&lt;span&gt;)) = &lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;fst &lt;&#x2F;span&gt;&lt;span&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;inj&lt;&#x2F;span&gt;&lt;span&gt;₂ &lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;snd
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;h4 id=&quot;dependent-pair-type-s-type&quot;&gt;Dependent Pair Type (Σ type)&lt;&#x2F;h4&gt;
&lt;blockquote&gt;
&lt;p&gt;In computer science, a tagged union, also called a variant, variant record, choice type, discriminated union, disjoint union, sum type or coproduct, is a data structure used to hold a value that could take on several different, but fixed, types. —— Wikipedia&lt;&#x2F;p&gt;
&lt;&#x2F;blockquote&gt;
&lt;p&gt;$$
\Sigma-form: 
\require{bussproofs}
\begin{prooftree}
\AxiomC{$\Gamma, x: P \vdash Q(x)$}
\UnaryInfC{$\Gamma \vdash \Sigma_{(x:P)} Q(x)$}
\end{prooftree}
$$&lt;&#x2F;p&gt;
&lt;p&gt;$$
\Sigma-intro: 
\require{bussproofs}
\begin{prooftree}
\AxiomC{$\Gamma \vdash p:P$}
\AxiomC{$\Gamma \vdash q:Q(p)$}
\BinaryInfC{$\Gamma \vdash pair(p, q):\Sigma_{(x:P)} Q(x)$}
\end{prooftree}
$$&lt;&#x2F;p&gt;
&lt;p&gt;$$
\Sigma-elim: 
\require{bussproofs}
\begin{prooftree}
\AxiomC{$\Gamma,z:\Sigma_{(x:P)} Q(x) \vdash D(z)\ type$}
\AxiomC{$\Gamma,x:P,y:Q(x) \vdash a: D(pair(x,y))$}
\BinaryInfC{$\Gamma,z:\Sigma_{(x:P)} \vdash ind_{\Sigma}(a,z):D(z)$}
\end{prooftree}
$$&lt;&#x2F;p&gt;
&lt;p&gt;$$
\Sigma-comp: 
\require{bussproofs}
\begin{prooftree}
\AxiomC{$\Gamma,z:\Sigma_{(x:P)} Q(x) \vdash D(z)\ type$}
\AxiomC{$\Gamma,x:P,y:Q(x) \vdash a: D(pair(x,y))$}
\BinaryInfC{$\Gamma,x:P,y:Q(x) \vdash ind_{\Sigma} (a, pair(x,y)) \doteq a:D(pair(x,y))$}
\end{prooftree}
$$&lt;&#x2F;p&gt;
&lt;h5 id=&quot;how-to-view-s-type&quot;&gt;How to view Σ type&lt;&#x2F;h5&gt;
&lt;p&gt;Assume there&#x27;s a set named as P and a predicate named as Q, then $\Sigma_{(x:P)}Q(x)$ means there &lt;strong&gt;exists&lt;&#x2F;strong&gt; an element $x$ in $P$ such that $Q(x)$ holds, ie. we can regard Σ in types as ∃ in logic.&lt;&#x2F;p&gt;
&lt;h5 id=&quot;proving-example-1&quot;&gt;Proving example&lt;&#x2F;h5&gt;
&lt;p&gt;Prove: for any $x:P\vdash Q(x)\ type$, there exists a projection function $\pi : \Sigma_{(x:P)} Q(x) \rightarrow P$.&lt;&#x2F;p&gt;
&lt;p&gt;By using $\rightarrow-intro$ and $\Sigma-elim$, we can prove it like this:&lt;&#x2F;p&gt;
&lt;p&gt;$$
\require{bussproofs}
\begin{prooftree}
\AxiomC{$x:P,y:Q(x) \vdash x:P$}
\UnaryInfC{$z:\Sigma_{(x:P)}Q(x)\vdash ind_{\Sigma}(x,z):P$}
\UnaryInfC{$\vdash \lambda z.ind_{\Sigma}(x,z):\Sigma_{(x:P)}Q(x)\rightarrow P$}
\end{prooftree}
$$&lt;&#x2F;p&gt;
&lt;p&gt;In agda:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;agda&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-agda &quot;&gt;&lt;code class=&quot;language-agda&quot; data-lang=&quot;agda&quot;&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;π &lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;∀&lt;&#x2F;span&gt;&lt;span&gt; (&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;A &lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;Set&lt;&#x2F;span&gt;&lt;span&gt;) (&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;B &lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;A &lt;&#x2F;span&gt;&lt;span&gt;→ &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;Set&lt;&#x2F;span&gt;&lt;span&gt;) → &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;Σ A B &lt;&#x2F;span&gt;&lt;span&gt;→ &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;A
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;π &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;A B&lt;&#x2F;span&gt;&lt;span&gt; (&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;fst &lt;&#x2F;span&gt;&lt;span&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;snd&lt;&#x2F;span&gt;&lt;span&gt;) = &lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;fst
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;h4 id=&quot;natural-numbers&quot;&gt;Natural Numbers&lt;&#x2F;h4&gt;
&lt;p&gt;$$
\mathbb N-form: 
\require{bussproofs}
\begin{prooftree}
\AxiomC{}
\UnaryInfC{$\Gamma \vdash \mathbb N\ type$}
\end{prooftree}
$$&lt;&#x2F;p&gt;
&lt;p&gt;$$
\mathbb N-intro: 
\require{bussproofs}
\begin{prooftree}
\AxiomC{}
\UnaryInfC{$\Gamma \vdash 0:\mathbb N$}
\end{prooftree}
\ \ \ \ 
\require{bussproofs}
\begin{prooftree}
\AxiomC{$\Gamma \vdash n:\mathbb N$}
\UnaryInfC{$\Gamma \vdash succ(n):\mathbb N$}
\end{prooftree}
$$&lt;&#x2F;p&gt;
&lt;p&gt;$$
\mathbb N-elim: 
\require{bussproofs}
\begin{prooftree}
\AxiomC{$\Gamma,x:\mathbb N \vdash D(x)\ type$}
\AxiomC{$\Gamma \vdash a:D(0)$}
\AxiomC{$\Gamma,x:\mathbb N,y:D(x) \vdash b: D(succ(x))$}
\TrinaryInfC{$\Gamma,x:\mathbb N \vdash ind_{\mathbb N}(a,b,x):D(x)$}
\end{prooftree}
$$&lt;&#x2F;p&gt;
&lt;p&gt;$$
\mathbb N-comp: 
\require{bussproofs}
\begin{prooftree}
\AxiomC{$\Gamma,x:\mathbb N \vdash D(x)\ type$}
\AxiomC{$\Gamma \vdash a:D(0)$}
\AxiomC{$\Gamma,x:\mathbb N,y:D(x) \vdash b: D(succ(x))$}
\TrinaryInfC{$\displaylines {\Gamma \vdash ind_{\mathbb N}(a,b,0) \doteq a:D(0)\\ \Gamma,x:\mathbb N \vdash ind_{\mathbb N}(a,b,succ(x)) \doteq b[ind_{\mathbb N}(a,b,x)&#x2F;y]:D(succ(x))}$}
\end{prooftree}
$$&lt;&#x2F;p&gt;
&lt;h2 id=&quot;materials&quot;&gt;Materials&lt;&#x2F;h2&gt;
&lt;h3 id=&quot;lecture-note&quot;&gt;Lecture Note&lt;&#x2F;h3&gt;
&lt;p&gt;&lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;martinescardo&#x2F;HoTTEST-Summer-School&#x2F;blob&#x2F;main&#x2F;HoTT&#x2F;HoTTEST_Lecture_2.pdf&quot;&gt;HoTTEST_Lecture_2.pdf&lt;&#x2F;a&gt;&lt;&#x2F;p&gt;
&lt;h3 id=&quot;record-on-youtube&quot;&gt;Record on Youtube&lt;&#x2F;h3&gt;
&lt;div &gt;
    &lt;iframe src=&quot;https:&#x2F;&#x2F;www.youtube-nocookie.com&#x2F;embed&#x2F;GW0jV0l5NB4&quot; webkitallowfullscreen mozallowfullscreen allowfullscreen&gt;&lt;&#x2F;iframe&gt;
&lt;&#x2F;div&gt;
&lt;div class=&quot;footnote-definition&quot; id=&quot;1&quot;&gt;&lt;sup class=&quot;footnote-definition-label&quot;&gt;1&lt;&#x2F;sup&gt;
&lt;p&gt;It&#x27;s actually judgmentally equal, &lt;a href=&quot;https:&#x2F;&#x2F;jozefg.bitbucket.io&#x2F;posts&#x2F;2014-08-06-equality.html&quot;&gt;ref&lt;&#x2F;a&gt;.&lt;&#x2F;p&gt;
&lt;&#x2F;div&gt;
</content>
	</entry>
	<entry xml:lang="en">
		<title>HoTTEST Summer School HoTT Notes 1</title>
		<published>2022-07-14T02:51:09.783+00:00</published>
		<updated>2022-07-14T02:51:09.783+00:00</updated>
		<link rel="alternate" href="https://longfangsong.github.io/en/hottest-notes-hott-1/" type="text/html"/>
		<id>https://longfangsong.github.io/en/hottest-notes-hott-1/</id>
		<content type="html">&lt;h2 id=&quot;natural-deduction&quot;&gt;Natural deduction&lt;&#x2F;h2&gt;
&lt;p&gt;Trivial, not necessary to say too much here.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;simple-typed-lambda-calculus-stlc-or-stlc&quot;&gt;Simple typed lambda calculus (STλC or STLC)&lt;&#x2F;h2&gt;
&lt;p&gt;Still trivial, just need to clarify some notations the teacher is using.&lt;&#x2F;p&gt;
&lt;p&gt;$pr_1 (p, q)$ means take the first element out from pair $(p, q)$, which is always write as $(p, q).1$, eg.&lt;&#x2F;p&gt;
&lt;p&gt;$$
\require{bussproofs}
\begin{prooftree}
\AxiomC{p: P}
\AxiomC{q: Q}
\BinaryInfC{$pr_1 (p, q) \doteq p: P$}
\end{prooftree}
$$&lt;&#x2F;p&gt;
&lt;p&gt;Here $\doteq$ is by definition equal&lt;sup class=&quot;footnote-reference&quot;&gt;&lt;a href=&quot;#1&quot;&gt;1&lt;&#x2F;a&gt;&lt;&#x2F;sup&gt;, which I always use $\equiv$.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;dependent-type-theory&quot;&gt;Dependent type theory&lt;&#x2F;h2&gt;
&lt;p&gt;Tough I had some basic knowledge of this before (eg. Dependent types can be viewed as predicates due to Curry-Howard Corresponding), but I do learned some more.&lt;&#x2F;p&gt;
&lt;h3 id=&quot;the-meaning-of-the-word-dependent&quot;&gt;The meaning of the word &amp;quot;dependent&amp;quot;&lt;&#x2F;h3&gt;
&lt;p&gt;I used to understand this in an intuitive way, in the class the teacher introduced a semi-formal definition of &amp;quot;dependent&amp;quot;, ie. the items on the right side of $\vdash$ depends on those on the left side.&lt;&#x2F;p&gt;
&lt;h3 id=&quot;rules-of-p-types&quot;&gt;Rules of π-types&lt;&#x2F;h3&gt;
&lt;p&gt;$$
\Pi-form: 
\require{bussproofs}
\begin{prooftree}
\AxiomC{$\Gamma ,x:P \vdash Q\ type$}
\UnaryInfC{$\Gamma \vdash \Pi_{(x:P)} Q\ type$}
\end{prooftree}
$$&lt;&#x2F;p&gt;
&lt;p&gt;$$
\Pi-intro: 
\require{bussproofs}
\begin{prooftree}
\AxiomC{$\Gamma ,x:P \vdash q:Q$}
\UnaryInfC{$\Gamma \vdash \lambda x.q: \Pi_{(x:P)} Q$}
\end{prooftree}
$$&lt;&#x2F;p&gt;
&lt;p&gt;$$
\Pi-elim: 
\require{bussproofs}
\begin{prooftree}
\AxiomC{$\Gamma \vdash f:\Pi_{(x:P)} Q$}
\AxiomC{$\Gamma \vdash p:P$}
\BinaryInfC{$\Gamma \vdash f\ p:Q[p&#x2F;x]$}
\end{prooftree}
$$&lt;&#x2F;p&gt;
&lt;p&gt;$$
\Pi-comp-\beta: 
\require{bussproofs}
\begin{prooftree}
\AxiomC{$\Gamma ,x:P \vdash q:Q$}
\AxiomC{$\Gamma \vdash p:P$}
\BinaryInfC{$\Gamma \vdash (\lambda x.q) p \doteq q[p&#x2F;x]:Q[p&#x2F;x]$}
\end{prooftree}
$$&lt;&#x2F;p&gt;
&lt;p&gt;$$
\Pi-comp-\eta: 
\require{bussproofs}
\begin{prooftree}
\AxiomC{$\Gamma \vdash f:\Pi_{x:P} Q$}
\UnaryInfC{$\Gamma \vdash \lambda x.f\ x\doteq f:\Pi_{(x:P)} Q$}
\end{prooftree}
$$&lt;&#x2F;p&gt;
&lt;h2 id=&quot;materials&quot;&gt;Materials&lt;&#x2F;h2&gt;
&lt;h3 id=&quot;lecture-note&quot;&gt;Lecture Note&lt;&#x2F;h3&gt;
&lt;p&gt;&lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;martinescardo&#x2F;HoTTEST-Summer-School&#x2F;blob&#x2F;main&#x2F;HoTT&#x2F;HoTTEST_Lecture_1.pdf&quot;&gt;HoTTEST_Lecture_1.pdf&lt;&#x2F;a&gt;&lt;&#x2F;p&gt;
&lt;h3 id=&quot;record-on-youtube&quot;&gt;Record on Youtube&lt;&#x2F;h3&gt;
&lt;div &gt;
    &lt;iframe src=&quot;https:&#x2F;&#x2F;www.youtube-nocookie.com&#x2F;embed&#x2F;HvYYCHMeM-8&quot; webkitallowfullscreen mozallowfullscreen allowfullscreen&gt;&lt;&#x2F;iframe&gt;
&lt;&#x2F;div&gt;
&lt;div class=&quot;footnote-definition&quot; id=&quot;1&quot;&gt;&lt;sup class=&quot;footnote-definition-label&quot;&gt;1&lt;&#x2F;sup&gt;
&lt;p&gt;It&#x27;s actually judgmentally equal, &lt;a href=&quot;https:&#x2F;&#x2F;jozefg.bitbucket.io&#x2F;posts&#x2F;2014-08-06-equality.html&quot;&gt;ref&lt;&#x2F;a&gt;.&lt;&#x2F;p&gt;
&lt;&#x2F;div&gt;
</content>
	</entry>
	<entry xml:lang="en">
		<title>Hello zola!</title>
		<published>2020-01-02T15:00:00+00:00</published>
		<updated>2020-01-02T15:00:00+00:00</updated>
		<link rel="alternate" href="https://longfangsong.github.io/en/hello-zola/" type="text/html"/>
		<id>https://longfangsong.github.io/en/hello-zola/</id>
		<content type="html">&lt;p&gt;I wrote a lot of blogs, and I used to use hexo as a static site generator, it kind of work well, but I&#x27;m afraid with more and more posts I have, the speed of hexo become unacceptable, moreover, the plugin system works well if I add only one plugin, but become odd if there&#x27;re many plugins work together:&lt;&#x2F;p&gt;
&lt;p&gt;Here&#x27;s an image from my origin blog, powered by hexo:&lt;&#x2F;p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https:&#x2F;&#x2F;longfangsong.github.io&#x2F;en&#x2F;hello-zola&#x2F;ouch.png&quot; alt=&quot;ouch&quot; &#x2F;&gt;&lt;&#x2F;p&gt;
&lt;&#x2F;blockquote&gt;
&lt;p&gt;Ouch!&lt;&#x2F;p&gt;
&lt;p&gt;And then, since I&#x27;m a big fan of Rust, I found zola, though this tool is not as complete as hexo, I can use its shortcodes feature to embed different of things to my blog!&lt;&#x2F;p&gt;
&lt;p&gt;For example, terminal record:&lt;&#x2F;p&gt;
&lt;script id=&quot;asciicast-9EhVw8rujVjpPVBV5kQMdAIHe&quot; src=&quot;https:&#x2F;&#x2F;asciinema.org&#x2F;a&#x2F;9EhVw8rujVjpPVBV5kQMdAIHe.js&quot; async&gt;&lt;&#x2F;script&gt;
&lt;p&gt;Which I never imagined when using hexo!&lt;&#x2F;p&gt;
&lt;p&gt;And zola do make it easier to customize a theme, in hexo, if I want to customize a theme, I have to fork it, and do some edit on it. But in zola I can do this easily by override a template block.&lt;&#x2F;p&gt;
&lt;p&gt;But there remains some problems:&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;The &lt;code&gt;translations&lt;&#x2F;code&gt; in a theme cannot be used in the site based on that theme. Hope will fixed after &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;getzola&#x2F;zola&#x2F;pull&#x2F;1148&quot;&gt;#1148&lt;&#x2F;a&gt;.&lt;&#x2F;li&gt;
&lt;li&gt;Cannot paginate over another section.&lt;sup class=&quot;footnote-reference&quot;&gt;&lt;a href=&quot;#1&quot;&gt;1&lt;&#x2F;a&gt;&lt;&#x2F;sup&gt;&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;Anyway, I&#x27;ll absolutly move my blog to zola.&lt;&#x2F;p&gt;
&lt;p&gt;Also I&#x27;m looking forward to contribute something to this project, and I started with &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;getzola&#x2F;themes&#x2F;pull&#x2F;49&quot;&gt;migrating a theme&lt;&#x2F;a&gt;, which I&#x27;ll also used on my blog.&lt;&#x2F;p&gt;
&lt;p&gt;Hope zola will become a better project in the future!&lt;&#x2F;p&gt;
&lt;div class=&quot;footnote-definition&quot; id=&quot;1&quot;&gt;&lt;sup class=&quot;footnote-definition-label&quot;&gt;1&lt;&#x2F;sup&gt;
&lt;p&gt;Or maybe I misunderstood the &lt;code&gt;pagination&lt;&#x2F;code&gt; feature ...&lt;&#x2F;p&gt;
&lt;&#x2F;div&gt;
</content>
	</entry>
</feed>
