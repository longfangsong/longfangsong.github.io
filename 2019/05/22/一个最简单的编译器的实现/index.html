<!DOCTYPE html><html lang="zh-CN"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><meta name="author" content="龙方淞,longfangsong@icloud.com"><meta name="apple-mobile-web-app-capable" content="yes"><title>一个最简单的编译器的实现 · Blog</title><!-- hexo-inject:begin --><!-- hexo-inject:end --><meta name="description" content="本文将会带领读者做出一个简单的类C（但比C简单无数倍）语言的编译器。
参考代码在这里，本文完成时的版本是这个。
这个语言支持：

两种基本数据类型：int和double
上述数据类型的数组
两种控制结构：if（当然可以有可选的else）和while
基本数学和关系运算：+、-、*、/、&amp;lt;、&amp;l"><meta name="keywords"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="renderer" content="webkit"><link rel="short icon" href="/images/favicon.png" type="image/x-icon"><link rel="icon" sizes="any" href="/images/favicon.png" type="image/x-icon"><link rel="apple-touch-icon-precomposed" sizes="144x144" href="/images/apple-touch-icon-144x144.png"><link rel="apple-touch-icon-precomposed" sizes="120x120" href="/images/apple-touch-icon-120x120.png"><link rel="apple-touch-icon-precomposed" sizes="72x72" href="/images/apple-touch-icon-72x72.png"><link rel="apple-touch-icon-precomposed" sizes="57x57" href="/images/apple-touch-icon-57x57.png"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/blog_basic.css"><link rel="stylesheet" href="https://cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css"><link rel="stylesheet" href="/css/SourceCodeVariable-font.css"><link rel="alternate" type="application/atom+xml" title="ATOM 1.0" href="/atom.xml"><!-- hexo-inject:begin --><!-- hexo-inject:end --></head><body><div class="sidebar animated fadeInDown"><div class="logo-title"><div class="title"><img src="/images/logo@2x.png" style="width:127px;"><h3 title=""><a href="/">Blog</a></h3><div class="description"><p>生命是灰色的，而理论之树常青</p></div></div></div><div style="width: 100%;" id="pirate" data-wordart-src="//cdn.wordart.com/json/685czi4rqil5" data-wordart-show-attribution></div><script src="//cdn.wordart.com/wordart.min.js" async defer></script><ul class="social-links"><li><a href="http://github.com/longfangsong"><i class="fa fa-github"></i></a></li></ul><div class="footer"><a target="_blank" href="/"><span>Theme by</span></a><a href="https://www.caicai.me"> CaiCai</a><span>&</span><a href="https://github.com/Ben02/hexo-theme-Anatole"> Ben</a><div class="by_farbox"><a href="https://hexo.io/zh-cn/" target="_blank">Proudly published with Hexo&#65281;</a></div><span class="opacity" id="busuanzi_container_site_pv">访问量</span><span class="opacity" id="busuanzi_value_site_uv"></span><span class="opacity">人次</span><script src="//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></div><div class="main"><div class="page-top animated fadeInDown"><div class="nav"><li><a href="/">首页</a></li><li><a href="/about">关于</a></li><li><a href="/tags">标签</a></li><li><a href="/archives">归档</a></li><li><a href="/links">友链</a></li></div><div class="information"><div class="back_btn"><li><a class="fa fa-chevron-left" onclick="window.history.go(-1)"> </a></li></div><div class="avatar"><img src="/images/logo.png"></div></div></div><div class="autopagerize_page_element"><div class="content"><div class="post-page"><div class="post animated fadeInDown"><div class="post-title"><h3><a>一个最简单的编译器的实现</a></h3></div><div class="post-content"><p>本文将会带领读者做出一个简单的类C（但比C简单无数倍）语言的编译器。</p>
<!-- hexo-inject:begin --><!-- hexo-inject:end --><p>参考代码<a href="https://github.com/longfangsong/toylang" target="_blank" rel="noopener">在这里</a>，本文完成时的版本是<a href="https://github.com/longfangsong/toylang/tree/db02558dd658c0cf667f60c822eb4bd42ecb9ee7" target="_blank" rel="noopener">这个</a>。</p>
<p>这个语言支持：</p>
<ul>
<li>两种基本数据类型：<code>int</code>和<code>double</code></li>
<li>上述数据类型的数组</li>
<li>两种控制结构：<code>if</code>（当然可以有可选的<code>else</code>）和<code>while</code></li>
<li>基本数学和关系运算：<code>+</code>、<code>-</code>、<code>*</code>、<code>/</code>、<code>&lt;</code>、<code>&lt;=</code>、<code>&gt;</code>、<code>&gt;=</code>、<code>==</code>、<code>!=</code></li>
</ul>
<p>本文假设读者是一个比较熟练的C语言<sup><a href="#fn_1" id="reffn_1">1</a></sup>程序猿，并具有基本的正则表达式知识。</p>
<p>同时本文读者应当熟悉flex &amp; bison的基本使用，如果你对此不熟悉，可以参考<a href="https://longfangsong.github.io/2019/05/22/flex-bison入门/">我的另一篇文章</a>。</p>
<h2 id="编译过程"><a href="#编译过程" class="headerlink" title="编译过程"></a>编译过程</h2><p>首先本文中所述的编译器编译一个程序的过程如下<sup><a href="#fn_2" id="reffn_2">2</a></sup>：</p>
<p><img src="/Users/longfangsong/blog/source/_posts/一个最简单的编译器的实现/routine.svg" alt="routine"></p>
<p>显然很多代码都不用我们自己写，生在这样一个有丰富工具的时代既是幸运，也是一种不幸。</p>
<h2 id="词法分析"><a href="#词法分析" class="headerlink" title="词法分析"></a>词法分析</h2><p>在此给出flex的关键部分代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">&quot;char&quot;                      &#123;yylval.type=Char; return TYPE;&#125;</span><br><span class="line">&quot;int&quot;                       &#123;yylval.type=Int; return TYPE;&#125;</span><br><span class="line">&quot;double&quot;                    &#123;yylval.type=Double; return TYPE;&#125;</span><br><span class="line">&quot;string&quot;                    &#123;yylval.type=String; return TYPE;&#125;</span><br><span class="line">&quot;if&quot;                        &#123;return IF;&#125;</span><br><span class="line">&quot;else&quot;                      &#123;return ELSE;&#125;</span><br><span class="line">&quot;while&quot;                     &#123;return WHILE;&#125;</span><br><span class="line">&quot;print&quot;                     &#123;return PRINT;&#125;</span><br><span class="line">([-])?[0-9]+                &#123;yylval.int_value=atoi(yytext); return INT_LITERAL;&#125;</span><br><span class="line">([-])?[0-9]+\.[0-9]*        &#123;yylval.double_value=atof(yytext); return DOUBLE_LITERAL;&#125;</span><br><span class="line">[a-zA-Z][0-9a-zA-Z_]*       &#123;yylval.string_value=strdup(yytext); return IDENTIFY;&#125;</span><br><span class="line">&quot;==&quot;                        &#123;return EQUAL;&#125;</span><br><span class="line">&quot;!=&quot;                        &#123;return NONEQUAL;&#125;</span><br><span class="line">&quot;&lt;&quot;                         &#123;return *yytext;&#125;</span><br><span class="line">&quot;&lt;=&quot;                        &#123;return LESSEQ;&#125;</span><br><span class="line">&quot;&gt;&quot;                         &#123;return *yytext;&#125;</span><br><span class="line">&quot;&gt;=&quot;                        &#123;return GREATEREQ;&#125;</span><br><span class="line">&quot;+&quot;                         &#123;return *yytext;&#125;</span><br><span class="line">&quot;-&quot;                         &#123;return *yytext;&#125;</span><br><span class="line">&quot;*&quot;                         &#123;return *yytext;&#125;</span><br><span class="line">&quot;/&quot;                         &#123;return *yytext;&#125;</span><br><span class="line">&quot;[&quot;                         &#123;return *yytext;&#125;</span><br><span class="line">&quot;]&quot;                         &#123;return *yytext;&#125;</span><br><span class="line">[ \t]                       &#123;&#125;</span><br><span class="line">.                           &#123;return *yytext;&#125;</span><br></pre></td></tr></table></figure>
<h2 id="语法分析"><a href="#语法分析" class="headerlink" title="语法分析"></a>语法分析</h2><p>在此给出bison的关键部分代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line">program:</span><br><span class="line">    program statement           </span><br><span class="line">    |                          </span><br><span class="line">    ;</span><br><span class="line"></span><br><span class="line">assign:</span><br><span class="line">    &apos;=&apos; expression             </span><br><span class="line">    ;</span><br><span class="line"></span><br><span class="line">defineStatement:</span><br><span class="line">    TYPE IDENTIFY &apos;;&apos;</span><br><span class="line">    | TYPE IDENTIFY &apos;[&apos; INT_LITERAL &apos;]&apos; &apos;;&apos; </span><br><span class="line">    | TYPE IDENTIFY assign &apos;;&apos;</span><br><span class="line">    ;</span><br><span class="line"></span><br><span class="line">assignStatement:</span><br><span class="line">    referenceExpression assign &apos;;&apos;</span><br><span class="line">    ;</span><br><span class="line"></span><br><span class="line">statementList:</span><br><span class="line">    statementList statement                 </span><br><span class="line">    |                                       </span><br><span class="line">    ;</span><br><span class="line"></span><br><span class="line">block:</span><br><span class="line">    &apos;&#123;&apos; statementList &apos;&#125;&apos; </span><br><span class="line">    ;</span><br><span class="line"></span><br><span class="line">ifStatement:</span><br><span class="line">    IF expression block                   </span><br><span class="line">    | IF expression block ELSE block        </span><br><span class="line">    ;</span><br><span class="line"></span><br><span class="line">whileStatement:</span><br><span class="line">    WHILE expression block                  </span><br><span class="line">;</span><br><span class="line"></span><br><span class="line">printStatement:</span><br><span class="line">    PRINT &apos;(&apos; expression &apos;)&apos; &apos;;&apos;</span><br><span class="line">;</span><br><span class="line"></span><br><span class="line">statement:</span><br><span class="line">    defineStatement</span><br><span class="line">    | assignStatement</span><br><span class="line">    | block</span><br><span class="line">    | ifStatement</span><br><span class="line">    | whileStatement</span><br><span class="line">    | printStatement</span><br><span class="line">;</span><br><span class="line"></span><br><span class="line">referenceExpression:</span><br><span class="line">    IDENTIFY </span><br><span class="line">    | IDENTIFY &apos;[&apos; expression &apos;]&apos; </span><br><span class="line"></span><br><span class="line">atomExpression:</span><br><span class="line">    INT_LITERAL                            </span><br><span class="line">    | DOUBLE_LITERAL                      </span><br><span class="line">    | referenceExpression                  </span><br><span class="line">    | &apos;(&apos; expression &apos;)&apos;                  </span><br><span class="line">    ;</span><br><span class="line"></span><br><span class="line">unaryOperator:</span><br><span class="line">    &apos;+&apos;</span><br><span class="line">    | &apos;-&apos;</span><br><span class="line">    | &apos;!&apos;</span><br><span class="line">    ;</span><br><span class="line"></span><br><span class="line">unaryExpression:</span><br><span class="line">    atomExpression                        </span><br><span class="line">    | unaryOperator atomExpression         </span><br><span class="line">;</span><br><span class="line"></span><br><span class="line">binaryOrAtomExpression:</span><br><span class="line">    unaryExpression                                    </span><br><span class="line">    | binaryOrAtomExpression &apos;+&apos; unaryExpression       </span><br><span class="line">    | binaryOrAtomExpression &apos;-&apos; unaryExpression   </span><br><span class="line">    | binaryOrAtomExpression &apos;*&apos; unaryExpression        </span><br><span class="line">    | binaryOrAtomExpression &apos;/&apos; unaryExpression      </span><br><span class="line">    | binaryOrAtomExpression &apos;&lt;&apos; unaryExpression       </span><br><span class="line">    | binaryOrAtomExpression &apos;&gt;&apos; unaryExpression       </span><br><span class="line">    | binaryOrAtomExpression LESSEQ     unaryExpression </span><br><span class="line">    | binaryOrAtomExpression GREATEREQ  unaryExpression</span><br><span class="line">    | binaryOrAtomExpression EQUAL      unaryExpression </span><br><span class="line">    | binaryOrAtomExpression NONEQUAL   unaryExpression </span><br><span class="line">;</span><br><span class="line"></span><br><span class="line">expression:</span><br><span class="line">    binaryOrAtomExpression </span><br><span class="line">    ;</span><br></pre></td></tr></table></figure>
<p>注意此处没有给出相应的行为代码，因为首先需要理解AST才能明白这些行为。</p>
<h2 id="AST（抽象语法树）"><a href="#AST（抽象语法树）" class="headerlink" title="AST（抽象语法树）"></a>AST（抽象语法树）</h2><p>抽象语法树将语法分析得到的语法单元组织成树状。</p>
<p>基本上每个<code>statement</code>和<code>expression</code>都可以对应AST上的一个node。</p>
<h3 id="本编译器的AST设计"><a href="#本编译器的AST设计" class="headerlink" title="本编译器的AST设计"></a>本编译器的AST设计</h3><p>部分参考了llvm的AST设计。</p>
<p><img src="/2019/05/22/一个最简单的编译器的实现/AST.svg" alt="AST"></p>
<p>因此我们就能写出<code>%union</code>和<code>%type</code>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">%<span class="keyword">union</span> &#123;</span><br><span class="line">    <span class="keyword">int</span> int_value;</span><br><span class="line">    <span class="keyword">double</span> double_value;</span><br><span class="line">    <span class="keyword">char</span>* string_value;</span><br><span class="line">    ASTNode *node;</span><br><span class="line">    SymbolType type;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">%token &lt;type&gt; TYPE</span><br><span class="line">%token &lt;string_value&gt; IDENTIFY</span><br><span class="line">%token &lt;int_value&gt; INT_LITERAL</span><br><span class="line">%token &lt;double_value&gt; DOUBLE_LITERAL</span><br><span class="line">%token &lt;type&gt; STRING INT DOUBLE</span><br><span class="line">%token &lt;<span class="keyword">void</span>&gt; IF ELSE WHILE FOR</span><br><span class="line">%token &lt;<span class="keyword">void</span>&gt; LESSEQ GREATEREQ EQUAL NONEQUAL</span><br><span class="line">%token &lt;<span class="keyword">void</span>&gt; PRINT</span><br><span class="line"></span><br><span class="line">%left <span class="string">'&gt;'</span> <span class="string">'&lt;'</span> LESSEQ GREATEREQ EQUAL NONEQUAL</span><br><span class="line">%left <span class="string">'+'</span> <span class="string">'-'</span></span><br><span class="line">%left <span class="string">'*'</span> <span class="string">'/'</span></span><br><span class="line"></span><br><span class="line">%type &lt;node&gt; statement assignStatement statementList block ifStatement whileStatement defineStatement printStatement</span><br><span class="line">%type &lt;node&gt; expression referenceExpression assign atomExpression unaryExpression binaryOrAtomExpression</span><br><span class="line">%type &lt;node&gt; program</span><br></pre></td></tr></table></figure>
<p>整个程序是一个<code>CompoundStatement</code>，我们要把结果存在一个全局变量中：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CompoundStatement *result;</span><br></pre></td></tr></table></figure>
<p>然后向bison代码中加入行为部分，以<code>program</code>和<code>binaryOrAtomExpression</code>为例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">program:</span><br><span class="line">    program statement           &#123;add_statement((CompoundStatement *)$1, (Statement*)$2);&#125;</span><br><span class="line">    |                           &#123;result=create_compound_statement(); $$=(ASTNode*)result;&#125;</span><br><span class="line">    ;</span><br><span class="line"></span><br><span class="line">binaryOrAtomExpression:</span><br><span class="line">    unaryExpression                                     &#123;$$=$1;&#125;</span><br><span class="line">    | binaryOrAtomExpression &apos;+&apos; unaryExpression        &#123;$$=(ASTNode*)create_binary_operation_result(&apos;+&apos;,(RValue*)$1,(RValue*)$3);&#125;</span><br><span class="line">    | binaryOrAtomExpression &apos;-&apos; unaryExpression        &#123;$$=(ASTNode*)create_binary_operation_result(&apos;-&apos;,(RValue*)$1,(RValue*)$3);&#125;</span><br><span class="line">    | binaryOrAtomExpression &apos;*&apos; unaryExpression        &#123;$$=(ASTNode*)create_binary_operation_result(&apos;*&apos;,(RValue*)$1,(RValue*)$3);&#125;</span><br><span class="line">    | binaryOrAtomExpression &apos;/&apos; unaryExpression        &#123;$$=(ASTNode*)create_binary_operation_result(&apos;/&apos;,(RValue*)$1,(RValue*)$3);&#125;</span><br><span class="line">    | binaryOrAtomExpression &apos;&lt;&apos; unaryExpression        &#123;$$=(ASTNode*)create_binary_operation_result(&apos;&lt;&apos;,(RValue*)$1,(RValue*)$3);&#125;</span><br><span class="line">    | binaryOrAtomExpression &apos;&gt;&apos; unaryExpression        &#123;$$=(ASTNode*)create_binary_operation_result(&apos;&gt;&apos;,(RValue*)$1,(RValue*)$3);&#125;</span><br><span class="line">    | binaryOrAtomExpression LESSEQ     unaryExpression &#123;$$=(ASTNode*)create_binary_operation_result(LESSEQ, (RValue*)$1,(RValue*)$3);&#125;</span><br><span class="line">    | binaryOrAtomExpression GREATEREQ  unaryExpression &#123;$$=(ASTNode*)create_binary_operation_result(GREATEREQ,(RValue*)$1,(RValue*)$3);&#125;</span><br><span class="line">    | binaryOrAtomExpression EQUAL      unaryExpression &#123;$$=(ASTNode*)create_binary_operation_result(EQUAL, (RValue*)$1,(RValue*)$3);&#125;</span><br><span class="line">    | binaryOrAtomExpression NONEQUAL   unaryExpression &#123;$$=(ASTNode*)create_binary_operation_result(NONEQUAL, (RValue*)$1,(RValue*)$3);&#125;</span><br></pre></td></tr></table></figure>
<h2 id="符号表与作用域"><a href="#符号表与作用域" class="headerlink" title="符号表与作用域"></a>符号表与作用域</h2><p>这个编译器由于不涉及多文件，也没有复杂类型，符号表的设计较为简单，维护一个全局符号表栈即可：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">enum</span> &#123;</span><br><span class="line">    Bool,</span><br><span class="line">    Int,</span><br><span class="line">  	String,</span><br><span class="line">    Double,</span><br><span class="line">    Array</span><br><span class="line">&#125; SymbolType;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    SymbolType type;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">mutable</span>;</span><br><span class="line">    <span class="keyword">char</span> *name;</span><br><span class="line">    <span class="keyword">size_t</span> namespace_id;</span><br><span class="line">&#125; Symbol;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    Symbol base;</span><br><span class="line">    SymbolType elementType;</span><br><span class="line">    <span class="keyword">size_t</span> length;</span><br><span class="line">&#125; ArraySymbol;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="keyword">size_t</span> length;</span><br><span class="line">    Symbol **symbols;</span><br><span class="line">    <span class="keyword">size_t</span> namespace_id;</span><br><span class="line">&#125; SymbolTableFrame;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="keyword">size_t</span> length;</span><br><span class="line">    SymbolTableFrame **frames;</span><br><span class="line">&#125; SymbolTableStack;</span><br><span class="line"></span><br><span class="line">SymbolTableStack symbol_table_stack = &#123;<span class="number">0</span>, <span class="literal">NULL</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">push_frame</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pop_frame</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add_symbol</span><span class="params">(Symbol *symbol)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function">Symbol *<span class="title">get_symbol</span><span class="params">(<span class="keyword">char</span> *name)</span></span>;</span><br></pre></td></tr></table></figure>
<p>其中<code>get_symbol</code>从栈顶向栈底寻找名字为<code>name</code>的符号。</p>
<p>在<code>add_symbol</code>时，会设置<code>symbol</code>的<code>namespace_id</code>为<code>frame</code>的<code>namespace_id</code>，这在代码生成时会作为变量名称的一部分出现。</p>
<p>在语法分析时：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">block:</span><br><span class="line">    &apos;&#123;&apos; &#123;push_frame();&#125; statementList &apos;&#125;&apos;   &#123;$$=$3;pop_frame();&#125;</span><br><span class="line">    ;</span><br></pre></td></tr></table></figure></p>
<p>每遇到一个<code>block</code>，就<code>push</code>一个<code>frame</code>，离开<code>block</code>时<code>pop</code>即可，这样这个<code>block</code>内声明的<code>symbol</code>就会获得一个和这个<code>block</code>对应的<code>namespace_id</code>。</p>
<p>在使用<code>symbol</code>时，由于刚刚进入的<code>block</code>对应的<code>frame</code>在栈顶附近，故会优先在这个<code>frame</code>中寻找名字为<code>name</code>的符号，在这个<code>frame</code>中找不到时才会逐级向上寻找，这样就实现了作用域。</p>
<h2 id="目标代码生成"><a href="#目标代码生成" class="headerlink" title="目标代码生成"></a>目标代码生成</h2><p>为了方便代码跨平台和借用llvm的优秀的代码优化能力<sup><a href="#fn_3" id="reffn_3">3</a></sup>，我们的目标代码是LLVM IR。</p>
<p>LLVM IR兼有高级语言和汇编的特点，比如：</p>
<ul>
<li>LLVM IR是强类型的</li>
<li>LLVM IR中的许多控制结构类似汇编，如<code>if</code>、<code>while</code>等控制结构都通过<code>br</code>跳转来表示</li>
<li>LLVM IR中的”局部变量”相当程度上是一个”寄存器”，但LLVM IR逻辑上有无限多的这种”寄存器”，需要注意的是LLVM IR是一种SSA形式的IR，所以一个”寄存器”只能赋值一次。</li>
<li>LLVM的很多操作都类似汇编的格式，如：<code>%a = add i32 1, %b</code>类似<code>add %a, 1, %b</code></li>
</ul>
<p>在此讲一些我们用到的LLVM IR：</p>
<h3 id="变量定义"><a href="#变量定义" class="headerlink" title="变量定义"></a>变量定义</h3><p>用<code>alloca</code>在栈上开辟一块空间：</p>
<figure class="highlight llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">%i_0</span> = <span class="keyword">alloca</span> <span class="keyword">i32</span></span><br></pre></td></tr></table></figure>
<p>注意<code>alloca</code>返回的是一个指针。</p>
<h3 id="变量的赋值"><a href="#变量的赋值" class="headerlink" title="变量的赋值"></a>变量的赋值</h3><p>使用<code>store</code>：</p>
<figure class="highlight llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">store</span> <span class="keyword">i32</span> <span class="number">0</span>, <span class="keyword">i32</span>* <span class="symbol">%i_0</span></span><br></pre></td></tr></table></figure>
<p>即将0放入<code>%i_0</code>所指的变量中。</p>
<h3 id="读取变量的值"><a href="#读取变量的值" class="headerlink" title="读取变量的值"></a>读取变量的值</h3><p>用<code>load</code>：</p>
<figure class="highlight llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">%temp</span> = <span class="keyword">load</span> <span class="keyword">i32</span>, <span class="keyword">i32</span>* <span class="symbol">%i_0</span></span><br></pre></td></tr></table></figure>
<p>即将<code>%i_0</code>所指的变量中的值放入<code>%temp</code>寄存器中。</p>
<h3 id="运算"><a href="#运算" class="headerlink" title="运算"></a>运算</h3><p>以加法为例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">%temp_22 = add i32 %temp_21, 1</span><br></pre></td></tr></table></figure>
<p>即将<code>%temp_21</code>+<code>1</code>的值放入<code>%temp_22</code>中。</p>
<p>对于浮点数，用<code>fadd</code>代替<code>add</code>。</p>
<h3 id="比较"><a href="#比较" class="headerlink" title="比较"></a>比较</h3><p>使用<code>icmp</code>与比较类型：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">%temp_2 = icmp slt i32 %temp_1, 10</span><br></pre></td></tr></table></figure>
<p>其中<code>slt</code>是“Signed Less Than”，即<code>&lt;</code>。</p>
<p>浮点相应的有<code>fcmp</code>、<code>olt</code>等。</p>
<h3 id="跳转"><a href="#跳转" class="headerlink" title="跳转"></a>跳转</h3><p>使用<code>br</code>进行跳转：</p>
<ul>
<li><p>无条件：</p>
<figure class="highlight llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">br</span> label <span class="symbol">%label1</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>有条件</p>
<figure class="highlight llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">br</span> <span class="keyword">i1</span> <span class="symbol">%condition</span>, label <span class="symbol">%condition_true</span>, label <span class="symbol">%condition_false</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>有这些个东西就够了。</p>
<p>然后我们就可以进行代码生成了。</p>
<p>例如变量声明：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">generate_code</span><span class="params">(DeclareStatement *node)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%%%s_%zu = alloca %s\n"</span>, node-&gt;variable-&gt;name, node-&gt;variable-&gt;namespace_id, type_name(node-&gt;variable));</span><br><span class="line">    <span class="comment">// 带初始化，则再生成一个赋值语句</span></span><br><span class="line">    <span class="keyword">if</span> (node-&gt;initial != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        ((Statement *) (node-&gt;initial))-&gt;generate_code((Statement *) (node-&gt;initial));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>赋值：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">generate_code</span><span class="params">(AssignStatement *node)</span> </span>&#123;</span><br><span class="line">    ((LValue *) (node-&gt;lhs))-&gt;generate_lvalue_code((LValue *) (node-&gt;lhs));</span><br><span class="line">    node-&gt;rhs-&gt;generate_rvalue_code(node-&gt;rhs);</span><br><span class="line">    <span class="keyword">char</span> *rvalue_ir = node-&gt;rhs-&gt;rvalue_ir(node-&gt;rhs);</span><br><span class="line">    <span class="keyword">char</span> *lvalue_ir = node-&gt;lhs-&gt;lvalue_ir(node-&gt;lhs);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"store %s %s, %s* %s\n"</span>,</span><br><span class="line">           type_string(((RValue *) (node-&gt;lhs))-&gt;type),</span><br><span class="line">           rvalue_ir,</span><br><span class="line">           type_string(((RValue *) (node-&gt;lhs))-&gt;type),</span><br><span class="line">           lvalue_ir);</span><br><span class="line">    <span class="built_in">free</span>(rvalue_ir);</span><br><span class="line">    <span class="built_in">free</span>(lvalue_ir);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对<code>expression</code>来说，左值右值要分开，以普通变量为例：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 右值需从变量读取到寄存器才能使用</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">generate_rvalue_code</span><span class="params">(VariableReference *rValue)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> *rvalue_ir_string = ((RValue *) rValue)-&gt;rvalue_ir((RValue *) rValue);</span><br><span class="line">    <span class="keyword">char</span> *lvalue_ir_string = ((LValue *) rValue)-&gt;lvalue_ir((LValue *) rValue);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%s = load %s, %s* %s\n"</span>,</span><br><span class="line">           rvalue_ir_string,</span><br><span class="line">           type_name(rValue-&gt;variable),</span><br><span class="line">           type_name(rValue-&gt;variable),</span><br><span class="line">           lvalue_ir_string);</span><br><span class="line">    <span class="built_in">free</span>(rvalue_ir_string);</span><br><span class="line">    <span class="built_in">free</span>(lvalue_ir_string);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 左值无需读取出来</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">generate_lvalue_code</span><span class="params">(VariableReference *lValue)</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 做左值时ir中的变量名</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">char</span> *<span class="title">lvalue_ir</span><span class="params">(VariableReference *lValue)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> *result = <span class="built_in">malloc</span>(<span class="number">128</span>);</span><br><span class="line">    <span class="built_in">sprintf</span>(result, <span class="string">"%%%s_%zu"</span>, lValue-&gt;variable-&gt;name, lValue-&gt;variable-&gt;namespace_id);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 做右值时ir中的变量名</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">char</span> *<span class="title">rvalue_ir</span><span class="params">(VariableReference *rValue)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> *result = <span class="built_in">malloc</span>(<span class="number">128</span>);</span><br><span class="line">    <span class="built_in">sprintf</span>(result, <span class="string">"%%temp_%zu"</span>, rValue-&gt;temp_register_id);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其他代码如何生成可以由读者自己想出来，对我的实现感兴趣的话请自行<a href="https://github.com/longfangsong/toylang" target="_blank" rel="noopener">阅读代码</a>。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><h3 id="编译原理"><a href="#编译原理" class="headerlink" title="编译原理"></a>编译原理</h3><p>龙虎鲸三连：</p>
<ul>
<li>《编译原理》——“龙书”</li>
<li>《现代编译原理：Ｃ语言描述》——“虎书”</li>
<li>《高级编译器设计与实现》——“鲸书”</li>
</ul>
<h3 id="参考词法-amp-文法"><a href="#参考词法-amp-文法" class="headerlink" title="参考词法&amp;文法"></a>参考词法&amp;文法</h3><ul>
<li><a href="http://www.lysator.liu.se/c/ANSI-C-grammar-l.html#check-type" target="_blank" rel="noopener">C语言的词法</a></li>
<li><a href="http://www.lysator.liu.se/c/ANSI-C-grammar-y.html#unary-expression" target="_blank" rel="noopener">C语言的文法</a></li>
</ul>
<h3 id="LLVM-IR"><a href="#LLVM-IR" class="headerlink" title="LLVM IR"></a>LLVM IR</h3><ul>
<li><a href="https://llvm.org，尤其是其[语言参考](https://llvm.org/docs/LangRef.html" target="_blank" rel="noopener">https://llvm.org，尤其是其[语言参考](https://llvm.org/docs/LangRef.html</a>)</li>
<li><a href="https://mapping-high-level-constructs-to-llvm-ir.readthedocs.io" target="_blank" rel="noopener">mapping high level constructs to llvm ir</a></li>
</ul>
<blockquote id="fn_1">
<sup>1</sup>. 代码中将会使用C语言的面向对象编程，见<a href="https://longfangsong.github.io/2018/03/17/用纯C实现面向对象编程/">用纯C实现面向对象编程</a>。这东西用多了就有一种C语言远比C++好用的感觉（Linus一点都没说错）。<a href="#reffn_1" title="Jump back to footnote [1] in the text."> &#8617;</a>
</blockquote>
<blockquote id="fn_2">
<sup>2</sup>. 其实在构造AST里我偷偷摸摸做了一丁点语义分析。<a href="#reffn_2" title="Jump back to footnote [2] in the text."> &#8617;</a>
</blockquote>
<blockquote id="fn_3">
<sup>3</sup>. 其实是因为我懒<a href="#reffn_3" title="Jump back to footnote [3] in the text."> &#8617;</a>
</blockquote>
</div><div class="post-footer"><div class="meta"><div class="info"><i class="fa fa-sun-o"></i><span class="date">2019-05-22</span><i class="fa fa-tag"></i><a class="tag" href="/tags/编译原理/" title="编译原理">编译原理 </a></div></div></div></div><div class="share"><div class="evernote"><a class="fa fa-bookmark" href="javascript:(function(){EN_CLIP_HOST='http://www.evernote.com';try{var%20x=document.createElement('SCRIPT');x.type='text/javascript';x.src=EN_CLIP_HOST+'/public/bookmarkClipper.js?'+(new%20Date().getTime()/100000);document.getElementsByTagName('head')[0].appendChild(x);}catch(e){location.href=EN_CLIP_HOST+'/clip.action?url='+encodeURIComponent(location.href)+'&amp;title='+encodeURIComponent(document.title);}})();" ref="nofollow" target="_blank"></a></div><div class="weibo"><a class="fa fa-weibo" href="javascript:void((function(s,d,e){try{}catch(e){}var f='http://service.weibo.com/share/share.php?',u=d.location.href,p=['url=',e(u),'&amp;title=',e(d.title),'&amp;appkey=2924220432'].join('');function a(){if(!window.open([f,p].join(''),'mb',['toolbar=0,status=0,resizable=1,width=620,height=450,left=',(s.width-620)/2,',top=',(s.height-450)/2].join('')))u.href=[f,p].join('');};if(/Firefox/.test(navigator.userAgent)){setTimeout(a,0)}else{a()}})(screen,document,encodeURIComponent));"></a></div><div class="twitter"><a class="fa fa-twitter" href="http://twitter.com/home?status=,http://longfangsong.github.io/2019/05/22/一个最简单的编译器的实现/,Blog,一个最简单的编译器的实现,;"></a></div></div><div class="pagination"><ul class="clearfix"><li class="pre pagbuttons"><a class="btn" role="navigation" href="/2019/05/22/flex-bison入门/" title="flex &amp; bison入门">上一篇</a></li><li class="next pagbuttons"><a class="btn" role="navigation" href="/2019/04/18/Travis-ssh-配置/" title="Travis ssh 配置">下一篇</a></li></ul></div><a id="comments"></a><div id="vcomments" style="margin:0 30px;"></div><script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script><script src="//unpkg.com/valine/dist/Valine.min.js"></script><script>var valine = new Valine({
  el:'#vcomments',
  notify:false || false,
  verify:false|| false,
  app_id:'HcCTt2sXmRChcaE4nMoSibwJ-gzGzoHsz',
  app_key:'6eevqWRr7jsWPUavkkAQjIMi',
  placeholder:'随便说点啥吧……',
  path: window.location.pathname,
  avatar:'mm'
})</script></div></div></div></div><script src="https://cdn.bootcss.com/jquery/3.3.1/jquery.min.js"></script><script src="https://cdn.bootcss.com/jquery-migrate/3.0.1/jquery-migrate.min.js"></script><script src="https://cdn.bootcss.com/jquery.appear/0.3.6/jquery.appear.min.js"></script><!-- hexo-inject:begin --><!-- hexo-inject:end --></body></html>